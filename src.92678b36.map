{"version":3,"sources":["src/classes/Point.js","src/classes/Circle.js","src/classes/Polygon.js","src/config.js","src/util.js","src/perlin.js","src/classes/Heatmap.js","src/classes/Collision.js","src/classes/Road.js","src/classes/SegmentFactory.js","src/classes/Segment.js","src/classes/QuadTree.js","src/generation.js","src/draw.js","src/interaction.js","src/index.js"],"names":["EPSILON","Point","x","y","Math","sqrt","length2","other","v","minus","length","diff","s","radians","acos","dot","PI","scalarMultiply","start","end","toStart","line","projected","project","result","add","sign","distance2","pointOnLine","lineProj2","Circle","d","r","Polygon","edges","color","options","minX","canvas","width","maxX","minY","height","maxY","point","boundaries","debugMode","context","lineWidth","strokeStyle","strokeRect","currentSize","points","scale","offsetX","min","random","offsetY","push","round","fillStyle","fillRect","edgesMap","forEach","lastCrossing","intersections","i","includes","DEFAULT_SEGMENT_WIDTH","HIGHWAY_SEGMENT_WIDTH","DEFAULT_SEGMENT_LENGTH","HIGHWAY_SEGMENT_LENGTH","SEGMENT_COUNT_LIMIT","BRANCH_ANGLE","FORWARD_ANGLE","SKYSCRAPER_BRANCH_ANGLE","SKYSCRAPER_FORWARD_ANGLE","HIGHWAY_BRANCH_PROBABILITY","DEFAULT_BRANCH_PROBABILITY","HIGHWAY_BRANCH_POPULATION_THRESHOLD","NORMAL_BRANCH_POPULATION_THRESHOLD","ROAD_SNAP_DISTANCE","MINIMUM_INTERSECTION_DEVIATION","MIN_SPEED_PROPORTION","NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY","QUADTREE_MAX_OBJECTS","QUADTREE_MAX_LEVELS","randomRange","max","minDegreeDifference","a","b","abs","randomAngle","limit","value","nonUniformNorm","pow","minAndIndex","array","min_i","entry","maxAndIndex","max_i","Grad","z","grad3","p","perm","Array","gradP","seed","floor","F2","G2","F3","G3","simplex2","xin","yin","n0","j","t","x0","y0","i1","j1","x1","y1","x2","y2","gi0","gi1","gi2","t0","t1","t2","dot2","Heatmap","one","noise","two","three","road","populationAt","Collision","object","type","properties","collisionRevision","limitsRevision","undefined","cachedLimits","RECT","LINE","CIRCLE","prop","axis","minCorner","corners","corner","maxCorner","Type","center","radius","limits","otherLimits","rectCircleCollision","rectRectIntersection","circle","rectPropsFromLine","distanceToLine","axes","center0","center2","projections","dots","direction","perpendicular","halfWidth","rect","cornersA","cornersB","overlaps","projectionsA","map","projectionsB","positionsA","vector","positionsB","util","maxA","maxA_i","minA","minA_i","maxB","maxB_i","minB","minB_i","maxAminB","maxBminA","minVector","Road","segment","collider","updateCollisionProperties","roadRevision","starts","numerator","cross","denominator","u","intersect","SegmentFactory","time","params","Segment","sin","cos","highway","links","backwards","forwards","users","maxSpeed","capacity","START","END","directionRevision","vertical","cachedDirection","angle","lengthRevision","cachedLength","distance","equals","currentSpeed","fromFraction","segmentEnd","endContaining","fraction","End","cost","concat","startIsBackwards","segments","tree","splitPart","fromExisting","addSegment","setEnd","setStart","slice","firstSplit","secondSplit","link","index","indexOf","insert","QuadTree","bounds","maxObjects","maxLevels","level","objects","nodes","midpointX","midpointY","top","bottom","getIndex","subdivide","splice","retrieve","node","clear","localConstraints","action","priority","matches","match","intersection","intersects","actions","split","severed","duplicates","some","linksForEndContaining","globalGoals","previousSegment","newBranches","template","usingDirection","templateContinue","templateBranch","continueStraight","straightPop","popOnRoad","F_ANGLE","B_ANGLE","randomStraight","randomPop","roadPop","leftHighwayBranch","rightHighwayBranch","leftBranch","rightBranch","branch","setUpBranchLinks","generate","queue","rootSegment","oppositeDirection","newEnd","treeParams","minT","minT_i","minSegment","id","drawSegment","beginPath","moveTo","lineTo","closePath","stroke","SUPPORTS_POINTER","window","SUPPORTS_TOUCH","drawing","xClicks","yClicks","dragClicks","currentBrush","document","querySelector","classList","lastBrush","parseInt","getElementById","brushes","prototype","call","getElementsByClassName","brushColors","skyscrapers","residential","commercial","water","parks","clickData","innerPoints","polygons","polygonIndex","render","addClick","dragging","clearActiveBrushes","brush","remove","onEventDown","event","detectEdges","mouseX","pageX","offsetLeft","mouseY","pageY","offsetTop","onEventMove","onEventUp","n","rgb","currX","getImageData","data","addEdge","prev","neighbors","prevIndex","findIndex","shift","firstNot","pixel","firstSame","next","interpretInput","polygon","boundingBox","scatterPoints","init","lineJoin","brushSize","currentBrushSize","addEventListener","innerWidth","innerHeight","innerText","target","checked","style","display","disabled","console","log","getCenter","generator","draw","getContext","interaction"],"mappings":"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","file":"src.92678b36.map","sourceRoot":"..","sourcesContent":["const EPSILON = 0.00000001;\n\nexport default class Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  length() {\n    return Math.sqrt(this.length2());\n  }\n\n  length2() {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  distance(other) {\n    const v = other.minus(this);\n    return v.length();\n  }\n\n  distance2(other) {\n    const v = other.minus(this);\n    return v.length2();\n  }\n\n  equals(other) {\n    const diff = this.minus(other);\n    return diff.length2() < EPSILON;\n  }\n\n  scalarMultiply(s) {\n    return new Point(this.x * s, this.y * s);\n  }\n\n  add(other) {\n    return new Point(this.x + other.x, this.y + other.y);\n  }\n\n  minus(other) {\n    return new Point(this.x - other.x, this.y - other.y);\n  }\n\n  dot(other) {\n    return this.x * other.x + this.y * other.y;\n  }\n\n  cross(other) {\n    return this.x * other.y - this.y * other.x;\n  }\n\n  angle(other) {\n    const radians = Math.acos(this.dot(other) / (this.length() * other.length()));\n    return radians * 180 / Math.PI;\n  }\n\n  project(other) {\n    return other.scalarMultiply(this.dot(other) / other.length2());\n  }\n\n  distanceToLine(start, end) {\n    const toStart = this.minus(start);\n    const line = end.minus(start);\n    const projected = toStart.project(line);\n    const result = start.add(projected);\n    const dot = toStart.dot(line);\n    const sign = dot < 0 ? -1 : dot > 0 ? 1 : 0;\n\n    return {\n      distance2: result.distance2(this),\n      pointOnLine: result,\n      // distance along line of projected point\n      lineProj2:  sign * projected.length2(),\n      length2: line.length2()\n    }\n  }\n}\n","export default class Circle {\n  constructor(x, y, d) {\n    this.x = x;\n    this.y = y;\n    this.r = d / 2;\n  }\n}\n","import Point from './Point.js';\n\nexport default class Polygon {\n  constructor(edges, color) {\n    this.edges = edges;\n    this.color = color;\n  }\n\n  getCenter(options) {\n    let minX = options.canvas.width, maxX = 0;\n    let minY = options.canvas.height, maxY = 0;\n    for (const point of this.edges) {\n      minX = point.x < minX ? point.x : minX;\n      maxX = point.x > maxX ? point.x : maxX;\n      minY = point.y < minY ? point.y : minY;\n      maxY = point.y > maxY ? point.y : maxY;\n    }\n\n    // find center from average of min and max\n    return new Point((minX + maxX) / 2, (minY + maxY) / 2);\n  }\n\n  /* Calculates the bounding box for a given Polygon. */\n  boundingBox(options) {\n    let minX = options.canvas.width, maxX = 0;\n    let minY = options.canvas.height, maxY = 0;\n    for (const point of this.edges) {\n      minX = point.x < minX ? point.x : minX;\n      maxX = point.x > maxX ? point.x : maxX;\n      minY = point.y < minY ? point.y : minY;\n      maxY = point.y > maxY ? point.y : maxY;\n    }\n    this.boundaries = [\n      new Point(minX, minY), // top left\n      new Point(maxX, minY), // top right\n      new Point(maxX, maxY), // bottom right\n      new Point(minX, maxY)  // bottom left\n    ];\n\n    // DEBUG MODE: draw bounding box\n    if (options.debugMode) {\n      options.context.lineWidth = 1;\n      options.context.strokeStyle = '#FF0000';\n      options.context.strokeRect(minX, minY, maxX - minX, maxY - minY);\n      options.context.lineWidth = options.currentSize;\n    }\n  }\n\n  /* Uses stratified sampling to scatter points within the Polygon for roads. */\n  scatterPoints(options) {\n    // we don't want to generate roads in parks or water\n    if (this.color === 'parks' || this.color === 'water') return;\n\n    const points = [];\n    // scatter points using stratified sampling within bounding box\n    const minX = this.boundaries[0].x, minY = this.boundaries[0].y;\n    const maxX = this.boundaries[1].x, maxY = this.boundaries[3].y;\n    for (let x = minX; x < maxX; x+=options.scale) {\n      for (let y = minY; y < maxY; y+=options.scale) {\n        // TODO: change scatter based on brush? (ex. less scatter on skyscrapers)\n        const offsetX = Math.min(x + Math.random() * options.scale, maxX);\n        const offsetY = Math.min(y + Math.random() * options.scale, maxY);\n        points.push(new Point(Math.round(offsetX), Math.round(offsetY)));\n      }\n    }\n\n    // DEBUG MODE: draw all of the stratified sampled points\n    if (options.debugMode) {\n      for (const point of points) {\n        options.context.fillStyle = '#000';\n        options.context.fillRect(point.x, point.y, 1, 1);\n      }\n    }\n\n    // map edge points y values to their x values\n    const edgesMap = {};\n    this.edges.forEach(point => {\n      if (edgesMap[point.y]) {\n        edgesMap[point.y].push(point.x);\n      } else {\n        edgesMap[point.y] = [point.x];\n      }\n    });\n\n    // starting at the point, go right and count the edges we hit\n    // TODO: handle when points cross tangent to the polygon\n    this.points = [];\n    points.forEach(point => {\n      // keep track of the last time we crossed the polygon's edge\n      let lastCrossing = 0;\n      let intersections = 0;\n      for (let i = point.x; i < maxX + 1; i++) {\n        if (edgesMap[point.y].includes(i)) {\n          // only count the intersection if the point isn't immediately next\n          if (i - lastCrossing > 1) intersections++;\n          lastCrossing = i;\n        }\n      }\n      // points are in the polygon if they hit an odd number of edges\n      if (intersections % 2 !== 0) this.points.push(point);\n    });\n\n    // DEBUG MODE: draw the points within the polygon in red\n    if (options.debugMode) {\n      for (const point of this.points) {\n        options.context.fillStyle = '#FF0000';\n        options.context.fillRect(point.x, point.y, 1, 1);\n      }\n    }\n  }\n}\n","export const DEFAULT_SEGMENT_WIDTH = 1;\nexport const HIGHWAY_SEGMENT_WIDTH = 2;\nexport const DEFAULT_SEGMENT_LENGTH = 25;\nexport const HIGHWAY_SEGMENT_LENGTH = 30;\nexport const SEGMENT_COUNT_LIMIT = 500;\n\nexport const BRANCH_ANGLE = 3; // in degrees\nexport const FORWARD_ANGLE = 10; // in degrees\nexport const SKYSCRAPER_BRANCH_ANGLE = 1; // in degrees\nexport const SKYSCRAPER_FORWARD_ANGLE = 1; // in degrees\n\nexport const HIGHWAY_BRANCH_PROBABILITY = 0.05;\nexport const DEFAULT_BRANCH_PROBABILITY = 0.4;\n\nexport const HIGHWAY_BRANCH_POPULATION_THRESHOLD = 0.1;\nexport const NORMAL_BRANCH_POPULATION_THRESHOLD = 0.1;\n\nexport const ROAD_SNAP_DISTANCE = 5;\nexport const MINIMUM_INTERSECTION_DEVIATION = 30; // in degrees\n\nexport const MIN_SPEED_PROPORTION = 0.1;\nexport const NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY = 5;\n\nexport const QUADTREE_MAX_OBJECTS = 10;\nexport const QUADTREE_MAX_LEVELS = 10;\n","function randomRange(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nexport function minDegreeDifference(a, b) {\n  const diff = Math.abs(a - b) % 180;\n  return Math.min(diff, Math.abs(diff - 180));\n}\n\nexport function randomAngle(limit) {\n  const nonUniformNorm = Math.pow(Math.abs(limit), 3);\n  let value = 0;\n  while (value === 0 || Math.random() < Math.pow(Math.abs(value), 3) / nonUniformNorm) {\n    value = randomRange(-limit, limit);\n  }\n  return value;\n}\n\nexport function minAndIndex(array) {\n  let min = array[0];\n  let min_i = 0;\n  array.forEach((entry, i) => {\n    if (entry < min) {\n      min = entry;\n      min_i = i;\n    }\n  });\n  return [min, min_i];\n}\n\nexport function maxAndIndex(array) {\n  let max = array[0];\n  let max_i = 0;\n  array.forEach((entry, i) => {\n    if (entry > max) {\n      max = entry;\n      max_i = i;\n    }\n  });\n  return [max, max_i];\n}\n","/*\n * Adapted from https://github.com/josephg/noisejs\n */\n\nclass Grad {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  dot2(x, y) {\n    return this.x * x + this.y * y;\n  }\n}\n\nconst grad3 = [\n  new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),\n  new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),\n  new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)\n];\n\nconst p = [151,160,137,91,90,15,\n131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\nconst perm = new Array(512);\nconst gradP = new Array(512);\n\nexport function seed(seed) {\n  if (seed > 0 && seed < 1) {\n    // Scale the seed out\n    seed *= 65536;\n  }\n\n  seed = Math.floor(seed);\n  if (seed < 256) {\n    seed |= seed << 8;\n  }\n\n  for (let i = 0; i < 256; i++) {\n    const v = i & 1 ? p[i] ^ (seed & 255) : p[i] ^ ((seed>>8) & 255);\n    perm[i] = perm[i + 256] = v;\n    gradP[i] = gradP[i + 256] = grad3[v % 12];\n  }\n}\n\nseed(0);\n\n// Skewing and unskewing factors for 2, 3, and 4 dimensions\nconst F2 = 0.5 * (Math.sqrt(3) - 1);\nconst G2 = (3 - Math.sqrt(3)) / 6;\n\nconst F3 = 1 / 3;\nconst G3 = 1 / 6;\n\n// 2D simplex noise\nexport function simplex2(xin, yin) {\n  let n0, n1, n2; // Noise contributions from the three corners\n  // Skew the input space to determine which simplex cell we're in\n  const s = (xin + yin) * F2; // Hairy factor for 2D\n  let i = Math.floor(xin + s);\n  let j = Math.floor(yin + s);\n  const t = (i + j) * G2;\n  const x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n  const y0 = yin - j + t;\n  // For the 2D case, the simplex shape is an equilateral triangle.\n  // Determine which simplex we are in.\n  // Offsets for second (middle) corner of simplex in (i,j) coords\n  const i1 = x0 > y0 ? 1 : 0;\n  const j1 = x0 > y0 ? 0 : 1;\n  // x0 > y0 is lower triangle, XY order: (0,0)->(1,0)->(1,1)\n  // otherwise is upper triangle, YX order: (0,0)->(0,1)->(1,1)\n  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n  // c = (3-sqrt(3))/6\n  const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n  const y1 = y0 - j1 + G2;\n  const x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n  const y2 = y0 - 1 + 2 * G2;\n  // Work out the hashed gradient indices of the three simplex corners\n  i &= 255;\n  j &= 255;\n  const gi0 = gradP[i + perm[j]];\n  const gi1 = gradP[i + i1 + perm[j + j1]];\n  const gi2 = gradP[i + 1 + perm[j + 1]];\n  // Calculate the contribution from the three corners\n  let t0 = 0.5 - x0 * x0 - y0 * y0;\n  if (t0 < 0) {\n    n0 = 0;\n  } else {\n    t0 *= t0;\n    n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\n  }\n  let t1 = 0.5 - x1 * x1 - y1 * y1;\n  if(t1 < 0) {\n    n1 = 0;\n  } else {\n    t1 *= t1;\n    n1 = t1 * t1 * gi1.dot2(x1, y1);\n  }\n  let t2 = 0.5 - x2 * x2 - y2 * y2;\n  if (t2 < 0) {\n    n2 = 0;\n  } else {\n    t2 *= t2;\n    n2 = t2 * t2 * gi2.dot2(x2, y2);\n  }\n  // Add contributions from each corner to get the final noise value.\n  // The result is scaled to return values in the interval [-1,1].\n  return 70 * (n0 + n1 + n2);\n}\n","import * as noise from './../perlin.js';\n\nexport default class Heatmap {\n  static populationAt(x, y) {\n    const one = (noise.simplex2(x / 500, y / 500) + 1) / 2;\n    const two = (noise.simplex2(x / 1000 + 50, y / 1000 + 50) + 1) / 2;\n    const three = (noise.simplex2(x / 1000 + 100, y / 1000 + 100) + 1) / 2;\n    return Math.pow((one * two + three) / 2, 2);\n  }\n\n  static popOnRoad(road) {\n    return (Heatmap.populationAt(road.start.x, road.start.y) + Heatmap.populationAt(road.end.x, road.end.y)) / 2;\n  }\n}\n","import Point from './Point.js';\n\nexport default class Collision {\n  static get Type() {\n    return { RECT: 'rect', LINE: 'line', CIRCLE: 'circle' };\n  }\n\n  constructor(object, type, properties) {\n    this.object = object;\n    this.type = type;\n    this.properties = properties;\n    this.collisionRevision = 0;\n    this.limitsRevision = undefined;\n    this.cachedLimits = undefined;\n  }\n\n  updateCollisionProperties(properties) {\n    this.collisionRevision++;\n    for (const prop in properties) {\n      this.properties[prop] = properties[prop];\n    }\n  }\n\n  minCorner(axis) {\n    let minCorner = this.properties.corners[0];\n    this.properties.corners.forEach(corner => {\n      if (corner[axis] < minCorner[axis]) minCorner = corner;\n    });\n    return minCorner;\n  }\n\n  maxCorner(axis) {\n    let maxCorner = this.properties.corners[0];\n    this.properties.corners.forEach(corner => {\n      if (corner[axis] > maxCorner[axis]) maxCorner = corner;\n    });\n    return maxCorner;\n  }\n\n  limits() {\n    if (this.collisionRevision !== this.limitsRevision) {\n      this.limitsRevision = this.collisionRevision;\n      if (this.type === Collision.Type.RECT) {\n        minX = this.minCorner('x').x;\n        minY = this.minCorner('y').y;\n        this.cachedLimits = {\n          x: minX,\n          y: minY,\n          width: this.maxCorner('x').x - minX,\n          height: this.maxCorner('y').y - minY,\n          object: this.object\n        }\n      } else if (this.type === Collision.Type.LINE) {\n        this.cachedLimits = {\n          x: Math.min(this.properties.start.x, this.properties.end.x),\n          y: Math.min(this.properties.start.y, this.properties.end.y),\n          width: Math.abs(this.properties.start.x - this.properties.end.x),\n          height: Math.abs(this.properties.start.y - this.properties.end.y),\n          object: this.object\n        }\n      } else if (this.type === Collision.Type.CIRCLE) {\n        this.cachedLimits = {\n          x: this.properties.center.x - this.properties.radius,\n          y: this.properties.center.y - this.properties.radius,\n          width: this.properties.radius * 2,\n          height: this.properties.radius * 2,\n          object: this.object\n        }\n      }\n    }\n    return this.cachedLimits;\n  }\n\n  collide(other) {\n    // avoid expensive collision check if possible\n    const limits = this.limits();\n    const otherLimits = other.limits();\n    if (limits && otherLimits &&\n        (limits.x + limits.width < otherLimits.x || otherLimits.x + otherLimits.width < limits.x) &&\n        (limits.y + limits.height < otherLimits.y || otherLimits.y + otherLimits.height < limits.y)) {\n      return false;\n    }\n\n    if (this.type === Collision.Type.CIRCLE) {\n      if (other.type === Collision.Type.RECT) {\n        other.rectCircleCollision(this);\n      }\n    } else if (this.type === Collision.Type.RECT) {\n      if (other.type !== Collision.Type.CIRCLE) {\n        this.rectRectIntersection(other);\n      } else {\n        this.rectCircleCollision(other);\n      }\n    } else if (this.type === Collision.Type.LINE) {\n      if (other.type !== Collision.Type.CIRCLE) {\n        this.rectRectIntersection(other);\n      }\n    }\n  }\n\n  rectCircleCollision(circle) {\n    // this must be a rectangle or line to call this function\n    if (this.type === Collision.Type.CIRCLE) return;\n    // other must be a circle to call this function\n    if (circle.type !== Collision.Type.CIRCLE) return;\n\n    // get the correct properties\n    const properties = this.type === Collision.Type.LINE ? this.rectPropsFromLine() : this.properties;\n    const corners = properties.corners;\n    const radius = circle.properties.radius;\n\n    // check for corner intersections with circle\n    for (const corner of corners) {\n      if (corner.distance2(circle.properties.center) <= radius * radius) {\n        return true;\n      }\n\n      // check for edge intersections with circle\n      for (let i = 0; i < corners.length; i++) {\n        const start = corners[i];\n        const end = corners[(i + 1) % corners.length];\n        const {distance2, pointOnLine, lineProj2, length2} = circle.properties.center.distanceToLine(start, end);\n        if (lineProj2 > 0 && lineProj2 < length2 && distance2 <= radius * radius) {\n          return true;\n        }\n      }\n\n      // check that the circle is not enclosed by the rectangle\n      const axes = [corners[3].minus(corners[0]), corners[3].minus(corners[2])];\n      const center0 = circle.properties.center.minus(corners[0]);\n      const center2 = circle.properties.center.minus(corners[2]);\n      const projections = [center0.project(axes[0]), center2.project(axes[1])];\n      const dots = [center0.dot(axes[0]), center2.dot(axes[1])];\n      if (dots[0] < 0 || projections[0].length2() > axes[0].length2() ||\n          dots[1] < 0 || projections[1].length2() > axes[1].length2()) {\n        return false;\n      }\n      return true;\n    }\n  }\n\n  rectPropsFromLine() {\n    // this must be a line to call this function\n    if (this.type !== Collision.Type.LINE) return;\n\n    const direction = this.properties.end.minus(this.properties.start);\n    const perpendicular = new Point(-direction.y, direction.x);\n    const halfWidth = perpendicular.scalarMultiply(0.5 * this.properties.width / perpendicular.length());\n    return {\n      corners: [\n        this.properties.start.add(halfWidth),\n        this.properties.start.minus(halfWidth),\n        this.properties.end.minus(halfWidth),\n        this.properties.end.add(halfWidth)\n      ]\n    }\n  }\n\n  rectRectIntersection(rect) {\n    // this must be a rectangle or line to call this function\n    if (this.type === Collision.Type.CIRCLE) return;\n    // other must be a rectangle or line to call this function\n    if (rect.type === Collision.Type.CIRCLE) return;\n\n    const cornersA = this.type === Collision.Type.LINE ? this.rectPropsFromLine().corners : this.properties.corners;\n    const cornersB = rect.type === Collision.Type.LINE ? rect.rectPropsFromLine().corners : rect.properties.corners;\n    const axes = [\n      cornersA[3].minus(cornersA[0]),\n      cornersA[3].minus(cornersA[2]),\n      cornersB[0].minus(cornersB[1]),\n      cornersB[0].minus(cornersB[3])\n    ]\n\n    // find axes with overlaps\n    const overlaps = [];\n    for (const axis of axes) {\n      const projectionsA = cornersA.map(corner => corner.project(axis));\n      const projectionsB = cornersB.map(corner => corner.project(axis));\n\n      const positionsA = projectionsA.map(vector => vector.dot(axis));\n      const positionsB = projectionsB.map(vector => vector.dot(axis));\n\n      const [maxA, maxA_i] = util.maxAndIndex(positionsA);\n      const [minA, minA_i] = util.minAndIndex(positionsA);\n      const [maxB, maxB_i] = util.maxAndIndex(positionsB);\n      const [minB, minB_i] = util.minAndIndex(positionsB);\n\n      // if the rectangles don't overlaps on at least one axis, they don't collide\n      if (maxA < minB || maxB < minA) {\n        return false;\n      } else {\n        // calculate the overlap between the rectangles on this axis\n        const maxAminB = projectionsA[maxA_i].minus(projectionsB[minB_i]);\n        const maxBminA = projectionsB[maxB_i].minus(projectionsA[minA_i]);\n        if (maxAminB.length2() < maxBminA.length2()) overlaps.push(maxAminB);\n        // the rectangles overlap on the other side, so invert the vector\n        else overlaps.push(maxBminA.scalarMultiply(-1));\n      }\n    }\n\n    // find axis with the least overlap\n    let minVector = overlaps[0];\n    overlaps.forEach(vector => {\n      if (vector.length2() < minVector.length2()) minVector = vector;\n    });\n\n    // return displacement required to remove the rectangle from the collision\n    return minVector.scalarMultiply(-1);\n  }\n}\n","import Point from './Point.js';\n\nexport default class Road {\n  constructor(start, end, segment) {\n    this.start = start;\n    this.end = end;\n    this.segment = segment;\n  }\n\n  setStart(start) {\n    this.start = start;\n    this.segment.collider.updateCollisionProperties({ start: start });\n    this.segment.roadRevision++;\n  }\n\n  setEnd(end) {\n    this.end = end;\n    this.segment.collider.updateCollisionProperties({ end: end });\n    this.segment.roadRevision++;\n  }\n\n  intersects(other) {\n    const r = this.end.minus(this.start);\n    const s = other.end.minus(other.start);\n    const starts = other.start.minus(this.start);\n\n    const numerator = starts.cross(r);\n    const denominator = r.cross(s);\n\n    if (denominator === 0 || numerator === 0) return false;\n\n    const u = numerator / denominator;\n    const t = starts.cross(s) / denominator;\n    const epsilon = 0.001;\n    const intersect = t > epsilon && t < 1 - epsilon && u > epsilon && u < 1 - epsilon;\n    return intersect ? new Point(this.start.x + t * r.x, this.start.y + t * r.y) : intersect;\n  }\n}\n","import Segment from './Segment.js';\nimport Point from './Point.js';\n\nexport default class SegmentFactory {\n  static fromExisting(segment, time, road, params) {\n    time = time || segment.time;\n    road = road || segment.road;\n    params = params || segment.params;\n    return new Segment(road.start, road.end, time, params);\n  }\n\n  static usingDirection(start, direction = 90, length = DEFAULT_SEGMENT_LENGTH, time = 0, params = {}) {\n    // convert direction to radians\n    direction *= Math.PI / 180;\n    const x = start.x + length * Math.sin(direction);\n    const y = start.y + length * Math.cos(direction);\n    return new Segment(start, new Point(x, y), time, params);\n  }\n}\n","import { DEFAULT_SEGMENT_WIDTH,\n         HIGHWAY_SEGMENT_WIDTH,\n         MIN_SPEED_PROPORTION } from './../config.js';\n\nimport Collision from './Collision.js';\nimport Road from './Road.js';\nimport Point from './Point.js';\nimport SegmentFactory from './SegmentFactory.js';\n\nexport default class Segment {\n  static get End() {\n    return { START: 'start', END: 'end' };\n  }\n\n  constructor(start, end, time = 0, params = {}) {\n    this.start = start;\n    this.end = end;\n    this.time = time;\n    this.params = params;\n\n    this.width = params.highway ? HIGHWAY_SEGMENT_WIDTH : DEFAULT_SEGMENT_WIDTH;\n    this.collider = new Collision(this, Collision.Type.LINE, {start: start, end: end, width: this.width});\n\n    this.roadRevision = 0;\n    this.road = new Road(start, end, this);\n\n    // time-step delay before this road is evaluated\n    this.time = time;\n    // meta-information relevant to global goals\n    this.params = params;\n\n    this.links = { backwards: [], forwards: [] };\n\n    this.users = [];\n    this.maxSpeed = params.highway ? 1200 : 800;\n    this.capacity = params.highway ? 12 : 6;\n  }\n\n  currentSpeed() {\n    return Math.min(MIN_SPEED_PROPORTION, 1 - Math.max(0, this.users.length - 1) / this.capacity) * this.maxSpeed;\n  }\n\n  direction() {\n    if (this.directionRevision !== this.roadRevision) {\n      this.directionRevision = this.roadRevision;\n      const vertical = new Point(0, 1);\n      const vector = this.road.end.minus(this.road.start);\n      const cross = vertical.cross(vector);\n      // we want the opposite of the cross sign\n      const sign = cross > 0 ? -1 : cross < 0 ? 1 : 0;\n      this.cachedDirection = sign * vertical.angle(vector);\n    }\n    return this.cachedDirection;\n  }\n\n  length() {\n    if (this.lengthRevision !== this.roadRevision) {\n      this.lengthRevision = this.roadRevision;\n      this.cachedLength = this.road.start.distance(this.road.end);\n    }\n    return this.cachedLength;\n  }\n\n  startIsBackwards() {\n    if (this.links.backwards.length) {\n      return this.links.backwards[0].road.start.equals(this.road.start) ||\n             this.links.backwards[0].road.end.equals(this.road.start);\n    } else {\n      return this.links.forwards[0].road.start.equals(this.road.end) ||\n             this.links.forwards[0].road.end.equals(this.road.end);\n    }\n  }\n\n  cost() {\n    return this.length() / this.currentSpeed();\n  }\n\n  costTo(other, fromFraction) {\n    const segmentEnd = this.endContaining(other);\n    const fraction = fromFraction ? (segmentEnd === Segment.End.START ? fromFraction : 1 - fromFraction) : 0.5;\n    return this.cost() * fraction;\n  }\n\n  neighbors() {\n    return this.links.forwards.concat(this.links.backwards);\n  }\n\n  endContaining(segment) {\n    const backwards = this.startIsBackwards();\n    if (this.links.backwards.includes(segment)) {\n      return backwards ? Segment.End.START : Segment.End.END;\n    } else if (this.links.forwards.includes(segment)) {\n      return backwards ? Segment.End.END : Segment.End.START;\n    }\n  }\n\n  linksForEndContaining(segment) {\n    if (this.links.backwards.includes(segment)) return this.links.backwards;\n    else if (this.links.forwards.includes(segment)) return this.links.forwards;\n  }\n\n  split(point, segment, segments, tree) {\n    const backwards = this.startIsBackwards();\n\n    const splitPart = SegmentFactory.fromExisting(this);\n    splitPart.addSegment(segments, tree);\n    splitPart.road.setEnd(point);\n    this.road.setStart(point);\n\n    splitPart.links.backwards = this.links.backwards.slice(0);\n    splitPart.links.forwards = this.links.forwards.slice(0);\n\n    // determine which links correspond to which end of the split segment\n    const firstSplit = backwards ? splitPart : this;\n    const secondSplit = backwards ? this : splitPart;\n    const fixLinks = backwards ? splitPart.links.backwards : splitPart.links.forwards;\n\n    fixLinks.forEach(link => {\n      let index = link.links.backwards.indexOf(this);\n      if (index !== -1) {\n        link.links.backwards[index] = splitPart;\n      } else {\n        index = link.links.forwards.indexOf(this);\n        link.links.forwards[index] = splitPart;\n      }\n    });\n\n    firstSplit.links.forwards = [segment, secondSplit];\n    secondSplit.links.backwards = [segment, firstSplit];\n\n    segment.links.forwards.push(firstSplit);\n    segment.links.forwards.push(secondSplit);\n  }\n\n  addSegment(segments, tree) {\n    segments.push(this);\n    tree.insert(this.collider.limits());\n  }\n}\n","export default class QuadTree {\n  constructor(bounds, maxObjects = 10, maxLevels = 4, level = 0) {\n    this.bounds = bounds;\n    this.maxObjects = maxObjects;\n    this.maxLevels = maxLevels;\n    this.level = level;\n\n    this.objects = [];\n    this.nodes = [];\n  }\n\n  subdivide() {\n    const width = Math.round(this.bounds.width / 2);\n    const height = Math.round(this.bounds.height / 2);\n    const x = Math.round(this.bounds.x);\n    const y = Math.round(this.bounds.y);\n\n    // top right node\n    this.nodes[0] = new QuadTree({\n      x: x + width,\n      y: y,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n\n    // top left node\n    this.nodes[1] = new QuadTree({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n\n    // bottom left node\n    this.nodes[2] = new QuadTree({\n      x: x,\n      y: y + height,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n\n    // bottom right node\n    this.nodes[3] = new QuadTree({\n      x: x + width,\n      y: y + height,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n  }\n\n  // determines which node the given rectangle is in\n  getIndex(rect) {\n    let index = -1;\n    const midpointX = this.bounds.x + this.bounds.width / 2;\n    const midpointY = this.bounds.y + this.bounds.height / 2;\n\n    const top = rect.y < midpointY && rect.y + rect.height < midpointY;\n    const bottom = rect.y > midpointY;\n\n    if (rect.x < midpointX && rect.x + rect.width < midpointX) {\n      index = top ? 1 : bottom ? 2 : index;\n    } else if (rect.x > midpointX) {\n      index = top ? 0 : bottom ? 3 : index;\n    }\n    return index;\n  }\n\n  insert(rect) {\n    if (this.nodes.length) {\n      const i = this.getIndex(rect);\n      if (i !== -1) return this.nodes[i].insert(rect);\n    }\n\n    this.objects.push(rect);\n\n    if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {\n      if (this.nodes.length === 0) this.subdivide();\n\n      let i = 0;\n      while (i < this.objects.length) {\n        const index = this.getIndex(this.objects[i]);\n        if (index !== -1) this.nodes[index].insert(this.objects.splice(i, 1)[0]);\n        else i++;\n      }\n    }\n  }\n\n  // returns all objects that collide with the given object\n  retrieve(rect) {\n    const index = this.getIndex(rect);\n    let objects = this.objects;\n\n    if (this.nodes.length) {\n      if (index !== -1) {\n        objects = objects.concat(this.nodes[index].retrieve(rect));\n      } else {\n        // check against all subnodes\n        for (const node of this.nodes) {\n          objects = objects.concat(node.retrieve(rect));\n        }\n      }\n    }\n    return objects;\n  }\n\n  clear() {\n    this.objects = [];\n    for (const node of this.nodes) {\n      node.clear();\n    }\n  }\n}\n","import { ROAD_SNAP_DISTANCE,\n         MINIMUM_INTERSECTION_DEVIATION,\n         DEFAULT_SEGMENT_LENGTH,\n         HIGHWAY_SEGMENT_LENGTH,\n         NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY,\n         BRANCH_ANGLE, FORWARD_ANGLE,\n         SKYSCRAPER_BRANCH_ANGLE, SKYSCRAPER_FORWARD_ANGLE,\n         HIGHWAY_BRANCH_POPULATION_THRESHOLD,\n         NORMAL_BRANCH_POPULATION_THRESHOLD,\n         HIGHWAY_BRANCH_PROBABILITY,\n         DEFAULT_BRANCH_PROBABILITY,\n         QUADTREE_PARAMS, QUADTREE_MAX_OBJECTS, QUADTREE_MAX_LEVELS,\n         SEGMENT_COUNT_LIMIT } from './config.js';\nimport * as util from './util.js';\nimport * as noise from './perlin.js';\n\nimport Point from './classes/Point.js';\nimport Heatmap from './classes/Heatmap.js';\nimport Segment from './classes/Segment.js';\nimport QuadTree from './classes/QuadTree.js';\nimport SegmentFactory from './classes/SegmentFactory.js';\n\nfunction localConstraints(segment, segments, tree) {\n  const action = { priority: 0, params: {} };\n\n  const matches = tree.retrieve(segment.collider.limits());\n  for (const match of matches) {\n    const other = match.object;\n\n    // intersection check\n    if (action.priority < 5) {\n      const intersection = segment.road.intersects(other.road);\n      if (intersection) {\n        if (!action.params.time || intersection.time < actions.params.time) {\n          action.params.time = intersection.time;\n          action.priority = 4;\n          // if intersecting lines are too similar don't continue\n          if (util.minDegreeDifference(other.direction(), segment.direction()) < MINIMUM_INTERSECTION_DEVIATION) {\n            return false;\n          }\n\n          other.split(intersection, segment, segments, tree);\n          segment.road.end = intersection;\n          segment.params.severed = true;\n\n          return true;\n        }\n      }\n    }\n\n    // snap to crossing within radius check\n    if (action.priority < 4) {\n      // current segment's start must have been checked to have been created\n      // other segment's start must have a corresponding end\n      if (segment.road.end.distance(other.road.end) <= ROAD_SNAP_DISTANCE) {\n        const point = other.road.end;\n        action.priority = 3;\n        segment.road.end = point;\n        segment.params.severed = true;\n\n        // update other's links corresponding to other.road.end\n        const links = other.startIsBackwards() ? other.links.forwards : other.links.backwards;\n\n        // check for duplicate lines, don't add if it exists\n        const duplicates = links.some(link => {\n          return (link.road.start.equals(segment.road.end) && link.road.end.equals(segment.road.start)) ||\n            (link.road.start.equals(segment.road.start) && link.road.end.equals(segment.road.end));\n        });\n        if (duplicates) return false;\n\n        links.forEach(link => {\n          // pick links of remaining segments at junction corresponding to other.road.end\n          link.linksForEndContaining(other).push(segment);\n\n          // add junction segments to snapped segment\n          segment.links.forwards.push(link);\n        });\n\n        links.push(segment);\n        segment.links.forwards.push(other);\n\n        return true;\n      }\n    }\n\n    // intersection with radius check\n    if (action.priority < 3) {\n      const { distance2, pointOnLine, lineProj2, length2 } =\n        segment.road.end.distanceToLine(other.road.start, other.road.end);\n      if (distance2 < ROAD_SNAP_DISTANCE * ROAD_SNAP_DISTANCE && lineProj2 >= 0 && lineProj2 <= length2) {\n        const point = pointOnLine;\n        action.priority = 2;\n        segment.road.end = point;\n        segment.params.severed = true;\n\n        // if intersecting lines are too similar don't continue\n        if (util.minDegreeDifference(other.direction(), segment.direction()) < MINIMUM_INTERSECTION_DEVIATION) {\n          return false;\n        }\n\n        other.split(point, segment, segments, tree);\n\n        return true;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction globalGoals(previousSegment, color) {\n  const newBranches = [];\n  if (!previousSegment.params.severed) {\n    const template = (direction, length, time, params) => SegmentFactory.usingDirection(previousSegment.road.end, direction, length, time, params);\n\n    // used for highways or going straight on a normal branch\n    const templateContinue = (direction) => template(direction, previousSegment.length(), 0, previousSegment.params);\n    // not using params, i.e. not highways\n    const templateBranch = (direction) => template(direction, DEFAULT_SEGMENT_LENGTH, previousSegment.params.highway ? NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY : 0);\n\n    const continueStraight = templateContinue(previousSegment.direction());\n    const straightPop = Heatmap.popOnRoad(continueStraight.road);\n\n    const F_ANGLE = color === 'skyscrapers' ? SKYSCRAPER_FORWARD_ANGLE : FORWARD_ANGLE;\n    const B_ANGLE = color === 'skyscrapers' ? SKYSCRAPER_BRANCH_ANGLE : BRANCH_ANGLE;\n\n    if (previousSegment.params.highway) {\n      const randomStraight = templateContinue(previousSegment.direction() + util.randomAngle(F_ANGLE));\n      const randomPop = Heatmap.popOnRoad(randomStraight.road);\n      const roadPop = randomPop > straightPop ? randomPop : straightPop;\n      newBranches.push(randomPop > straightPop ? randomStraight : continueStraight);\n\n      if (roadPop > HIGHWAY_BRANCH_POPULATION_THRESHOLD) {\n        if (Math.random() < HIGHWAY_BRANCH_PROBABILITY) {\n          const leftHighwayBranch = templateContinue(previousSegment.direction() - 90 + util.randomAngle(B_ANGLE));\n          newBranches.push(leftHighwayBranch);\n        } else if (Math.random() < HIGHWAY_BRANCH_PROBABILITY) {\n          const rightHighwayBranch = templateContinue(previousSegment.direction() + 90 + util.randomAngle(B_ANGLE));\n          newBranches.push(rightHighwayBranch);\n        }\n      }\n    } else if (straightPop > NORMAL_BRANCH_POPULATION_THRESHOLD) {\n      newBranches.push(continueStraight);\n    }\n\n    if (straightPop > NORMAL_BRANCH_POPULATION_THRESHOLD) {\n      if (Math.random() < DEFAULT_BRANCH_PROBABILITY) {\n        const leftBranch = templateBranch(previousSegment.direction() - 90 + util.randomAngle(B_ANGLE));\n        newBranches.push(leftBranch);\n      } else if (Math.random() < DEFAULT_BRANCH_PROBABILITY) {\n        const rightBranch = templateBranch(previousSegment.direction() + 90 + util.randomAngle(B_ANGLE));\n        newBranches.push(rightBranch);\n      }\n    }\n  }\n\n  for (const branch of newBranches) {\n    branch.setUpBranchLinks = () => {\n      // set up links between each current branch and each existing branch stemming from the previous segment\n      previousSegment.links.forwards.forEach(link => {\n        branch.links.backwards.push(link);\n        link.linksForEndContaining(previousSegment).push(branch);\n      });\n\n      previousSegment.links.forwards.push(branch);\n      branch.links.backwards.push(previousSegment);\n    }\n  }\n\n  return newBranches;\n}\n\nexport function generate(seed, color) {\n  noise.seed(Math.random());\n\n  const queue = [];\n  const rootSegment = new Segment(seed, new Point(seed.x + HIGHWAY_SEGMENT_LENGTH, seed.y), 0, { highway: true });\n  const oppositeDirection = SegmentFactory.fromExisting(rootSegment);\n  const newEnd = new Point(rootSegment.road.start.x - HIGHWAY_SEGMENT_LENGTH, oppositeDirection.road.end.y);\n  oppositeDirection.road.setEnd(newEnd);\n  oppositeDirection.links.backwards.push(rootSegment);\n  rootSegment.links.backwards.push(oppositeDirection);\n  queue.push(rootSegment);\n  queue.push(oppositeDirection);\n\n  const segments = [];\n  // TODO: bounds should be the bounding box of the polygon\n  const treeParams = { x: seed.x, y: seed.y, width: HIGHWAY_SEGMENT_LENGTH, height: HIGHWAY_SEGMENT_LENGTH };\n  // TODO: maxObjects should vary based on the type of city area\n  const tree = new QuadTree(treeParams, QUADTREE_MAX_OBJECTS, QUADTREE_MAX_LEVELS);\n\n  while (queue.length && segments.length < SEGMENT_COUNT_LIMIT) {\n    // pop smallest road from the priority queue (i.e. smallest time)\n    let minT = queue[0].time;\n    let minT_i = 0;\n    queue.forEach((segment, i) => {\n      if (segment.time < minT) {\n        minT = segment.time;\n        minT_i = i;\n      }\n    });\n\n    const minSegment = queue.splice(minT_i, 1)[0];\n    const accepted = localConstraints(minSegment, segments, tree);\n    if (accepted) {\n      if (minSegment.setUpBranchLinks) {\n        minSegment.setUpBranchLinks();\n      }\n      minSegment.addSegment(segments, tree);\n      globalGoals(minSegment, color).forEach(segment => {\n        segment.time += minSegment.time + 1;\n        queue.push(segment);\n      });\n    }\n  }\n\n  let id = 0;\n  for (const segment of segments) {\n    segment.id = id++;\n  }\n\n  return segments;\n}\n","export function drawSegment(context, segment) {\n  context.strokeStyle = segment.params.highway ? '#FF0000' : '#000000';\n  context.lineWidth = segment.width;\n\n  context.beginPath();\n  context.moveTo(segment.road.start.x, segment.road.start.y);\n  context.lineTo(segment.road.end.x, segment.road.end.y);\n  context.closePath();\n  context.stroke();\n}\n","import Point from './classes/Point.js';\nimport Circle from './classes/Circle.js';\nimport Polygon from './classes/Polygon.js';\nimport * as generator from './generation.js';\nimport * as draw from './draw.js';\n\nconst SUPPORTS_POINTER = 'PointerEvent' in window;\nconst SUPPORTS_TOUCH = 'ontouchstart' in window;\nconst options = {\n  drawing: false,\n  // create arrays to keep track of painting\n  xClicks: [],\n  yClicks: [],\n  dragClicks: [],\n  // brush parameters\n  currentBrush: document.querySelector('.active').classList[1],\n  lastBrush: document.querySelector('.active').classList[1],\n  currentSize: parseInt(document.getElementById('brush-size').value),\n  brushes: Array.prototype.slice.call(document.getElementsByClassName('brush')),\n  brushColors: {\n    skyscrapers: 'rgb(203,203,203)',\n    residential: 'rgb(252,139,148)',\n    commercial: 'rgb(191,140,190)',\n    water: 'rgb(180,207,226)',\n    parks: 'rgb(140,191,142)'\n  },\n  // data for storing canvas colors\n  clickData: { skyscrapers: [], residential: [], commercial: [], water: [], parks: [] },\n  innerPoints: { skyscrapers: [], residential: [], commercial: [], water: [], parks: [] },\n  polygons: [],\n  polygonIndex: 0,\n  // other parameters\n  debugMode: false,\n  scale: 20 // TODO: make this chooseable?\n}\n\n/* FUNCTIONS */\n\nfunction render() {\n  for (let i = 0; i < options.xClicks.length; i++) {\n    options.context.strokeStyle = options.brushColors[options.currentBrush];\n    options.context.lineWidth = options.currentSize;\n\n    options.context.beginPath();\n    if (options.dragClicks[i] && i > 0) {\n      options.context.moveTo(options.xClicks[i - 1], options.yClicks[i - 1]);\n    } else {\n      options.context.moveTo(options.xClicks[i] - 1, options.yClicks[i] - 1);\n    }\n\n    options.context.lineTo(options.xClicks[i], options.yClicks[i]);\n    options.context.closePath();\n    options.context.stroke();\n  }\n}\n\nfunction addClick(x, y, dragging) {\n  options.xClicks.push(x);\n  options.yClicks.push(y);\n  options.dragClicks.push(dragging);\n\n  // add to data for generation\n  options.clickData[options.currentBrush].push(new Circle(x, y, options.currentSize));\n}\n\nfunction clearActiveBrushes() {\n  options.brushes.forEach(brush => {\n    brush.classList.remove('active');\n  });\n}\n\nfunction onEventDown(event) {\n  const i = options.clickData[options.lastBrush].length - 1;\n  if (i > -1) options.polygons.push(detectEdges(options.clickData[options.lastBrush][i], options.lastBrush));\n\n  const mouseX = event.pageX - canvas.offsetLeft;\n  const mouseY = event.pageY - canvas.offsetTop;\n  options.drawing = true;\n  addClick(mouseX, mouseY);\n  render();\n}\n\nfunction onEventMove(event) {\n  if (options.drawing) {\n    addClick(event.pageX - canvas.offsetLeft, event.pageY - canvas.offsetTop, true);\n    render();\n  }\n}\n\nfunction onEventUp(event) {\n  options.drawing = false;\n  // clear clicks on up so we don't redraw anything\n  options.xClicks = [];\n  options.yClicks = [];\n  options.dragClicks = [];\n}\n\nfunction detectEdges(circle, color) {\n  const edges = [];\n  const rgb = options.brushColors[color].slice(4, -1).split(',');\n\n  // start at the rightmost pixel of the circle\n  let x = circle.x + circle.r - 1;\n  let y = circle.y;\n\n  // find the rightmost pixel of this color\n  // TODO: do this better\n  let currX = circle.x + circle.r - 1;\n  let n = options.context.getImageData(currX++, y, 1, 1).data;\n  while (n[0] == rgb[0] && n[1] == rgb[1] && n[2] == rgb[2]) {\n    x = currX;\n    n = options.context.getImageData(currX++, y, 1, 1).data;\n  }\n\n  const start = new Point(x - 1, y);\n\n  // recursive function to determine a polygon's edges\n  const addEdge = (point, prev) => {\n    const neighbors = [\n      new Point(point.x + 1, point.y    ),\n      new Point(point.x + 1, point.y + 1),\n      new Point(point.x,     point.y + 1),\n      new Point(point.x - 1, point.y + 1),\n      new Point(point.x - 1, point.y    ),\n      new Point(point.x - 1, point.y - 1),\n      new Point(point.x,     point.y - 1),\n      new Point(point.x + 1, point.y - 1)\n    ];\n\n    // order neighbors so that it starts right after prev\n    const prevIndex = neighbors.findIndex(p => p.x === prev.x && p.y === prev.y);\n    if (prevIndex < 7) {\n      for (let i = 0; i < prevIndex + 1; i++) {\n        neighbors.splice(7, 0, neighbors.shift());\n      }\n    }\n\n    // check if any of the eight surrounding pixels are a different color\n    const firstNot = neighbors.findIndex(p => {\n      const pixel = options.context.getImageData(p.x, p.y, 1, 1).data;\n      return Math.abs(pixel[0] - rgb[0]) > 5 ||\n             Math.abs(pixel[1] - rgb[1]) > 5 ||\n             Math.abs(pixel[2] - rgb[2]) > 5;\n    });\n\n    // find the first neighbor that is the same color and not the previous point\n    const firstSame = neighbors.findIndex(p => {\n      const pixel = options.context.getImageData(p.x, p.y, 1, 1).data;\n      return (p.x !== prev.x || p.y !== prev.y) &&\n        Math.abs(pixel[0] - rgb[0]) < 6 &&\n        Math.abs(pixel[1] - rgb[1]) < 6 &&\n        Math.abs(pixel[2] - rgb[2]) < 6;\n    });\n\n    if (firstNot !== -1) {\n      edges.push(new Point(point.x, point.y));\n      const next = neighbors[firstSame];\n      // continue until we reach the original starting point\n      if (next.x === start.x && next.y === start.y) return;\n      return addEdge(next, point);\n    }\n  }\n\n  addEdge(start, start);\n  return new Polygon(edges, color);\n}\n\nfunction interpretInput() {\n  // detect edges for the last click\n  const i = options.clickData[options.currentBrush].length - 1;\n  if (i > -1) options.polygons.push(detectEdges(options.clickData[options.currentBrush][i], options.currentBrush));\n\n  for (const polygon of options.polygons) {\n    polygon.boundingBox(options);\n    polygon.scatterPoints(options);\n  }\n}\n\nexport function init(canvas, context) {\n  /* SETUP */\n  context.lineJoin = 'round';\n  options.canvas = canvas;\n  options.context = context;\n\n  // brush logic\n  const brushSize = document.getElementById('brush-size');\n  const currentBrushSize = document.getElementById('current-brush-size');\n\n  /* EVENT LISTENERS */\n\n  // update the canvas size on window resize\n  window.addEventListener('resize', () => {\n    canvas.width = window.innerWidth * 0.85;\n    canvas.height = window.innerHeight;\n    render();\n  });\n\n  if (SUPPORTS_POINTER) {\n    canvas.addEventListener('pointerdown', event => { onEventDown(event) });\n    canvas.addEventListener('pointermove', event => { onEventMove(event) });\n    canvas.addEventListener('pointerup', event => { onEventUp(event) });\n    canvas.addEventListener('pointercancel', event => { onEventUp(event) });\n  } else if (SUPPORTS_TOUCH) {\n    canvas.addEventListener('touchstart', event => { onEventDown(event) });\n    canvas.addEventListener('touchmove', event => { onEventMove(event) });\n    canvas.addEventListener('touchend', event => { onEventUp(event) });\n    canvas.addEventListener('touchcancel', event => { onEventUp(event) });\n  } else {\n    canvas.addEventListener('mousedown', event => { onEventDown(event) });\n    canvas.addEventListener('mousemove', event => { onEventMove(event) });\n    canvas.addEventListener('mouseup', event => { onEventUp(event) });\n    canvas.addEventListener('mouseleave', event => { onEventUp(event) });\n  }\n\n  options.brushes.forEach(brush => {\n    brush.addEventListener('click', () => {\n      clearActiveBrushes();\n      options.lastBrush = options.currentBrush;\n      options.currentBrush = brush.classList[1];\n      brush.classList.add('active');\n    });\n  });\n\n  brushSize.addEventListener('input', event => {\n    options.currentSize = parseInt(brushSize.value);\n    currentBrushSize.innerText = brushSize.value;\n  });\n\n  document.getElementById('debug').addEventListener('change', event => {\n    options.debugMode = event.target.checked;\n    document.getElementById('debug-controls').style.display = options.debugMode ? 'block' : 'none';\n  });\n\n  document.getElementById('edges').addEventListener('click', event => {\n    // DEBUG MODE: draw edge outlines\n    for (const polygon of options.polygons) {\n      for (const point of polygon.edges) {\n        context.fillStyle = '#000';\n        context.fillRect(point.x, point.y, 1, 1);\n      }\n    }\n  });\n\n  document.getElementById('analyze').addEventListener('click', event => {\n    // DEBUG MODE: draw bounding boxes and scatter points\n    interpretInput();\n    event.target.disabled = true;\n    event.target.classList.add('disabled');\n  });\n\n  document.getElementById('generate').addEventListener('click', event => {\n    // detect edges for the last click\n    const i = options.clickData[options.currentBrush].length - 1;\n    if (i > -1) options.polygons.push(detectEdges(options.clickData[options.currentBrush][i], options.currentBrush));\n\n    // create road networks seeded from each polygon\n    options.polygons.forEach(polygon => {\n      console.log(polygon);\n      if (polygon.color !== 'parks' && polygon.color !== 'water') {\n        // only generate roads for skyscrapers, commercial, and residential\n        console.log(polygon.getCenter(options));\n        const segments = generator.generate(polygon.getCenter(options), polygon.color);\n        segments.forEach(segment => draw.drawSegment(options.context, segment));\n      }\n    });\n  });\n}\n","import Point from './classes/Point.js';\nimport * as interaction from './interaction.js';\nimport * as generator from './generation.js';\nimport * as draw from './draw.js';\n\n// set up canvas and interaction\nconst canvas = document.getElementById('canvas');\nconst context = canvas.getContext('2d');\ncanvas.width = window.innerWidth * 0.85; // canvas is 85vw\ncanvas.height = window.innerHeight;\ninteraction.init(canvas, context);\n"]}