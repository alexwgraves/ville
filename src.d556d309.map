{"version":3,"sources":["src/classes/Point.js","src/config.js","src/util.js","src/perlin.js","src/classes/Heatmap.js","src/classes/Collision.js","src/classes/Road.js","src/classes/SegmentFactory.js","src/classes/Segment.js","src/classes/QuadTree.js","src/generation.js","src/draw.js","src/index.js"],"names":["EPSILON","Point","x","y","Math","sqrt","length2","other","v","minus","length","diff","s","radians","acos","dot","PI","scalarMultiply","start","end","toStart","line","projected","project","result","add","sign","distance2","pointOnLine","lineProj2","DEFAULT_SEGMENT_WIDTH","HIGHWAY_SEGMENT_WIDTH","DEFAULT_SEGMENT_LENGTH","HIGHWAY_SEGMENT_LENGTH","SEGMENT_COUNT_LIMIT","BRANCH_ANGLE","FORWARD_ANGLE","HIGHWAY_BRANCH_PROBABILITY","DEFAULT_BRANCH_PROBABILITY","HIGHWAY_BRANCH_POPULATION_THRESHOLD","NORMAL_BRANCH_POPULATION_THRESHOLD","ROAD_SNAP_DISTANCE","MINIMUM_INTERSECTION_DEVIATION","MIN_SPEED_PROPORTION","NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY","QUADTREE_MAX_OBJECTS","QUADTREE_MAX_LEVELS","randomRange","min","max","random","minDegreeDifference","a","b","abs","randomAngle","limit","value","nonUniformNorm","pow","minAndIndex","array","min_i","forEach","entry","i","maxAndIndex","max_i","Grad","z","grad3","p","perm","Array","gradP","seed","floor","F2","G2","F3","G3","simplex2","xin","yin","n0","j","t","x0","y0","i1","j1","x1","y1","x2","y2","gi0","gi1","gi2","t0","t1","t2","dot2","Heatmap","one","noise","two","three","road","populationAt","Collision","object","type","properties","collisionRevision","limitsRevision","undefined","cachedLimits","RECT","LINE","CIRCLE","prop","axis","minCorner","corners","corner","maxCorner","Type","minX","minY","width","height","center","radius","limits","otherLimits","rectCircleCollision","rectRectIntersection","circle","rectPropsFromLine","distanceToLine","axes","center0","center2","projections","dots","direction","perpendicular","halfWidth","rect","cornersA","cornersB","overlaps","projectionsA","map","projectionsB","positionsA","vector","positionsB","util","maxA","maxA_i","minA","minA_i","maxB","maxB_i","minB","minB_i","maxAminB","maxBminA","push","minVector","Road","segment","collider","updateCollisionProperties","roadRevision","r","starts","numerator","cross","denominator","u","intersect","SegmentFactory","time","params","Segment","sin","cos","highway","links","backwards","forwards","users","maxSpeed","capacity","START","END","directionRevision","vertical","cachedDirection","angle","lengthRevision","cachedLength","distance","equals","currentSpeed","fromFraction","segmentEnd","endContaining","fraction","End","cost","concat","startIsBackwards","includes","point","segments","tree","splitPart","fromExisting","addSegment","setEnd","setStart","slice","firstSplit","secondSplit","link","index","indexOf","insert","QuadTree","bounds","maxObjects","maxLevels","level","objects","nodes","round","midpointX","midpointY","top","bottom","getIndex","subdivide","splice","retrieve","node","clear","localConstraints","debugData","action","priority","matches","match","intersection","intersects","actions","split","severed","intersections","duplicates","some","linksForEndContaining","snaps","intersectionsRadius","globalGoals","previousSegment","newBranches","template","usingDirection","templateContinue","templateBranch","continueStraight","straightPop","popOnRoad","randomStraight","randomPop","roadPop","leftHighwayBranch","rightHighwayBranch","leftBranch","rightBranch","branch","setUpBranchLinks","generate","queue","rootSegment","oppositeDirection","newEnd","treeParams","minT","minT_i","minSegment","id","drawSegment","context","strokeStyle","lineWidth","beginPath","moveTo","lineTo","closePath","stroke","canvas","document","getElementById","getContext","window","innerWidth","innerHeight","addEventListener","event","clearRect","generator","draw"],"mappings":"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","file":"src.d556d309.map","sourceRoot":"..","sourcesContent":["const EPSILON = 0.00000001;\n\nexport default class Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  length() {\n    return Math.sqrt(this.length2());\n  }\n\n  length2() {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  distance(other) {\n    const v = other.minus(this);\n    return v.length();\n  }\n\n  distance2(other) {\n    const v = other.minus(this);\n    return v.length2();\n  }\n\n  equals(other) {\n    const diff = this.minus(other);\n    return diff.length2() < EPSILON;\n  }\n\n  scalarMultiply(s) {\n    return new Point(this.x * s, this.y * s);\n  }\n\n  add(other) {\n    return new Point(this.x + other.x, this.y + other.y);\n  }\n\n  minus(other) {\n    return new Point(this.x - other.x, this.y - other.y);\n  }\n\n  dot(other) {\n    return this.x * other.x + this.y * other.y;\n  }\n\n  cross(other) {\n    return this.x * other.y - this.y * other.x;\n  }\n\n  angle(other) {\n    const radians = Math.acos(this.dot(other) / (this.length() * other.length()));\n    return radians * 180 / Math.PI;\n  }\n\n  project(other) {\n    return other.scalarMultiply(this.dot(other) / other.length2());\n  }\n\n  distanceToLine(start, end) {\n    const toStart = this.minus(start);\n    const line = end.minus(start);\n    const projected = toStart.project(line);\n    const result = start.add(projected);\n    const dot = toStart.dot(line);\n    const sign = dot < 0 ? -1 : dot > 0 ? 1 : 0;\n\n    return {\n      distance2: result.distance2(this),\n      pointOnLine: result,\n      // distance along line of projected point\n      lineProj2:  sign * projected.length2(),\n      length2: line.length2()\n    }\n  }\n}\n","export const DEFAULT_SEGMENT_WIDTH = 1;\nexport const HIGHWAY_SEGMENT_WIDTH = 2;\nexport const DEFAULT_SEGMENT_LENGTH = 25;\nexport const HIGHWAY_SEGMENT_LENGTH = 30;\nexport const SEGMENT_COUNT_LIMIT = 500;\n\nexport const BRANCH_ANGLE = 3; // in degrees\nexport const FORWARD_ANGLE = 10; // in degrees\n\nexport const HIGHWAY_BRANCH_PROBABILITY = 0.05;\nexport const DEFAULT_BRANCH_PROBABILITY = 0.4;\n\nexport const HIGHWAY_BRANCH_POPULATION_THRESHOLD = 0.1;\nexport const NORMAL_BRANCH_POPULATION_THRESHOLD = 0.1;\n\nexport const ROAD_SNAP_DISTANCE = 5;\nexport const MINIMUM_INTERSECTION_DEVIATION = 30; // in degrees\n\nexport const MIN_SPEED_PROPORTION = 0.1;\nexport const NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY = 5;\n\nexport const QUADTREE_MAX_OBJECTS = 10;\nexport const QUADTREE_MAX_LEVELS = 10;\n","function randomRange(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nexport function minDegreeDifference(a, b) {\n  const diff = Math.abs(a - b) % 180;\n  return Math.min(diff, Math.abs(diff - 180));\n}\n\nexport function randomAngle(limit) {\n  const nonUniformNorm = Math.pow(Math.abs(limit), 3);\n  let value = 0;\n  while (value === 0 || Math.random() < Math.pow(Math.abs(value), 3) / nonUniformNorm) {\n    value = randomRange(-limit, limit);\n  }\n  return value;\n}\n\nexport function minAndIndex(array) {\n  let min = array[0];\n  let min_i = 0;\n  array.forEach((entry, i) => {\n    if (entry < min) {\n      min = entry;\n      min_i = i;\n    }\n  });\n  return [min, min_i];\n}\n\nexport function maxAndIndex(array) {\n  let max = array[0];\n  let max_i = 0;\n  array.forEach((entry, i) => {\n    if (entry > max) {\n      max = entry;\n      max_i = i;\n    }\n  });\n  return [max, max_i];\n}\n","/*\n * Adapted from https://github.com/josephg/noisejs\n */\n\nclass Grad {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  dot2(x, y) {\n    return this.x * x + this.y * y;\n  }\n}\n\nconst grad3 = [\n  new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),\n  new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),\n  new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)\n];\n\nconst p = [151,160,137,91,90,15,\n131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\nconst perm = new Array(512);\nconst gradP = new Array(512);\n\nexport function seed(seed) {\n  if (seed > 0 && seed < 1) {\n    // Scale the seed out\n    seed *= 65536;\n  }\n\n  seed = Math.floor(seed);\n  if (seed < 256) {\n    seed |= seed << 8;\n  }\n\n  for (let i = 0; i < 256; i++) {\n    const v = i & 1 ? p[i] ^ (seed & 255) : p[i] ^ ((seed>>8) & 255);\n    perm[i] = perm[i + 256] = v;\n    gradP[i] = gradP[i + 256] = grad3[v % 12];\n  }\n}\n\nseed(0);\n\n// Skewing and unskewing factors for 2, 3, and 4 dimensions\nconst F2 = 0.5 * (Math.sqrt(3) - 1);\nconst G2 = (3 - Math.sqrt(3)) / 6;\n\nconst F3 = 1 / 3;\nconst G3 = 1 / 6;\n\n// 2D simplex noise\nexport function simplex2(xin, yin) {\n  let n0, n1, n2; // Noise contributions from the three corners\n  // Skew the input space to determine which simplex cell we're in\n  const s = (xin + yin) * F2; // Hairy factor for 2D\n  let i = Math.floor(xin + s);\n  let j = Math.floor(yin + s);\n  const t = (i + j) * G2;\n  const x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n  const y0 = yin - j + t;\n  // For the 2D case, the simplex shape is an equilateral triangle.\n  // Determine which simplex we are in.\n  // Offsets for second (middle) corner of simplex in (i,j) coords\n  const i1 = x0 > y0 ? 1 : 0;\n  const j1 = x0 > y0 ? 0 : 1;\n  // x0 > y0 is lower triangle, XY order: (0,0)->(1,0)->(1,1)\n  // otherwise is upper triangle, YX order: (0,0)->(0,1)->(1,1)\n  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n  // c = (3-sqrt(3))/6\n  const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n  const y1 = y0 - j1 + G2;\n  const x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n  const y2 = y0 - 1 + 2 * G2;\n  // Work out the hashed gradient indices of the three simplex corners\n  i &= 255;\n  j &= 255;\n  const gi0 = gradP[i + perm[j]];\n  const gi1 = gradP[i + i1 + perm[j + j1]];\n  const gi2 = gradP[i + 1 + perm[j + 1]];\n  // Calculate the contribution from the three corners\n  let t0 = 0.5 - x0 * x0 - y0 * y0;\n  if (t0 < 0) {\n    n0 = 0;\n  } else {\n    t0 *= t0;\n    n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\n  }\n  let t1 = 0.5 - x1 * x1 - y1 * y1;\n  if(t1 < 0) {\n    n1 = 0;\n  } else {\n    t1 *= t1;\n    n1 = t1 * t1 * gi1.dot2(x1, y1);\n  }\n  let t2 = 0.5 - x2 * x2 - y2 * y2;\n  if (t2 < 0) {\n    n2 = 0;\n  } else {\n    t2 *= t2;\n    n2 = t2 * t2 * gi2.dot2(x2, y2);\n  }\n  // Add contributions from each corner to get the final noise value.\n  // The result is scaled to return values in the interval [-1,1].\n  return 70 * (n0 + n1 + n2);\n}\n","import * as noise from './../perlin.js';\n\nexport default class Heatmap {\n  static populationAt(x, y) {\n    const one = (noise.simplex2(x / 500, y / 500) + 1) / 2;\n    const two = (noise.simplex2(x / 1000 + 50, y / 1000 + 50) + 1) / 2;\n    const three = (noise.simplex2(x / 1000 + 100, y / 1000 + 100) + 1) / 2;\n    return Math.pow((one * two + three) / 2, 2);\n  }\n\n  static popOnRoad(road) {\n    return (Heatmap.populationAt(road.start.x, road.start.y) + Heatmap.populationAt(road.end.x, road.end.y)) / 2;\n  }\n}\n","import Point from './Point.js';\n\nexport default class Collision {\n  static get Type() {\n    return { RECT: 'rect', LINE: 'line', CIRCLE: 'circle' };\n  }\n\n  constructor(object, type, properties) {\n    this.object = object;\n    this.type = type;\n    this.properties = properties;\n    this.collisionRevision = 0;\n    this.limitsRevision = undefined;\n    this.cachedLimits = undefined;\n  }\n\n  updateCollisionProperties(properties) {\n    this.collisionRevision++;\n    for (const prop in properties) {\n      this.properties[prop] = properties[prop];\n    }\n  }\n\n  minCorner(axis) {\n    let minCorner = this.properties.corners[0];\n    this.properties.corners.forEach(corner => {\n      if (corner[axis] < minCorner[axis]) minCorner = corner;\n    });\n    return minCorner;\n  }\n\n  maxCorner(axis) {\n    let maxCorner = this.properties.corners[0];\n    this.properties.corners.forEach(corner => {\n      if (corner[axis] > maxCorner[axis]) maxCorner = corner;\n    });\n    return maxCorner;\n  }\n\n  limits() {\n    if (this.collisionRevision !== this.limitsRevision) {\n      this.limitsRevision = this.collisionRevision;\n      if (this.type === Collision.Type.RECT) {\n        minX = this.minCorner('x').x;\n        minY = this.minCorner('y').y;\n        this.cachedLimits = {\n          x: minX,\n          y: minY,\n          width: this.maxCorner('x').x - minX,\n          height: this.maxCorner('y').y - minY,\n          object: this.object\n        }\n      } else if (this.type === Collision.Type.LINE) {\n        this.cachedLimits = {\n          x: Math.min(this.properties.start.x, this.properties.end.x),\n          y: Math.min(this.properties.start.y, this.properties.end.y),\n          width: Math.abs(this.properties.start.x - this.properties.end.x),\n          height: Math.abs(this.properties.start.y - this.properties.end.y),\n          object: this.object\n        }\n      } else if (this.type === Collision.Type.CIRCLE) {\n        this.cachedLimits = {\n          x: this.properties.center.x - this.properties.radius,\n          y: this.properties.center.y - this.properties.radius,\n          width: this.properties.radius * 2,\n          height: this.properties.radius * 2,\n          object: this.object\n        }\n      }\n    }\n    return this.cachedLimits;\n  }\n\n  collide(other) {\n    // avoid expensive collision check if possible\n    const limits = this.limits();\n    const otherLimits = other.limits();\n    if (limits && otherLimits &&\n        (limits.x + limits.width < otherLimits.x || otherLimits.x + otherLimits.width < limits.x) &&\n        (limits.y + limits.height < otherLimits.y || otherLimits.y + otherLimits.height < limits.y)) {\n      return false;\n    }\n\n    if (this.type === Collision.Type.CIRCLE) {\n      if (other.type === Collision.Type.RECT) {\n        other.rectCircleCollision(this);\n      }\n    } else if (this.type === Collision.Type.RECT) {\n      if (other.type !== Collision.Type.CIRCLE) {\n        this.rectRectIntersection(other);\n      } else {\n        this.rectCircleCollision(other);\n      }\n    } else if (this.type === Collision.Type.LINE) {\n      if (other.type !== Collision.Type.CIRCLE) {\n        this.rectRectIntersection(other);\n      }\n    }\n  }\n\n  rectCircleCollision(circle) {\n    // this must be a rectangle or line to call this function\n    if (this.type === Collision.Type.CIRCLE) return;\n    // other must be a circle to call this function\n    if (circle.type !== Collision.Type.CIRCLE) return;\n\n    // get the correct properties\n    const properties = this.type === Collision.Type.LINE ? this.rectPropsFromLine() : this.properties;\n    const corners = properties.corners;\n    const radius = circle.properties.radius;\n\n    // check for corner intersections with circle\n    for (const corner of corners) {\n      if (corner.distance2(circle.properties.center) <= radius * radius) {\n        return true;\n      }\n\n      // check for edge intersections with circle\n      for (let i = 0; i < corners.length; i++) {\n        const start = corners[i];\n        const end = corners[(i + 1) % corners.length];\n        const {distance2, pointOnLine, lineProj2, length2} = circle.properties.center.distanceToLine(start, end);\n        if (lineProj2 > 0 && lineProj2 < length2 && distance2 <= radius * radius) {\n          return true;\n        }\n      }\n\n      // check that the circle is not enclosed by the rectangle\n      const axes = [corners[3].minus(corners[0]), corners[3].minus(corners[2])];\n      const center0 = circle.properties.center.minus(corners[0]);\n      const center2 = circle.properties.center.minus(corners[2]);\n      const projections = [center0.project(axes[0]), center2.project(axes[1])];\n      const dots = [center0.dot(axes[0]), center2.dot(axes[1])];\n      if (dots[0] < 0 || projections[0].length2() > axes[0].length2() ||\n          dots[1] < 0 || projections[1].length2() > axes[1].length2()) {\n        return false;\n      }\n      return true;\n    }\n  }\n\n  rectPropsFromLine() {\n    // this must be a line to call this function\n    if (this.type !== Collision.Type.LINE) return;\n\n    const direction = this.properties.end.minus(this.properties.start);\n    const perpendicular = new Point(-direction.y, direction.x);\n    const halfWidth = perpendicular.scalarMultiply(0.5 * this.properties.width / perpendicular.length());\n    return {\n      corners: [\n        this.properties.start.add(halfWidth),\n        this.properties.start.minus(halfWidth),\n        this.properties.end.minus(halfWidth),\n        this.properties.end.add(halfWidth)\n      ]\n    }\n  }\n\n  rectRectIntersection(rect) {\n    // this must be a rectangle or line to call this function\n    if (this.type === Collision.Type.CIRCLE) return;\n    // other must be a rectangle or line to call this function\n    if (rect.type === Collision.Type.CIRCLE) return;\n\n    const cornersA = this.type === Collision.Type.LINE ? this.rectPropsFromLine().corners : this.properties.corners;\n    const cornersB = rect.type === Collision.Type.LINE ? rect.rectPropsFromLine().corners : rect.properties.corners;\n    const axes = [\n      cornersA[3].minus(cornersA[0]),\n      cornersA[3].minus(cornersA[2]),\n      cornersB[0].minus(cornersB[1]),\n      cornersB[0].minus(cornersB[3])\n    ]\n\n    // find axes with overlaps\n    const overlaps = [];\n    for (const axis of axes) {\n      const projectionsA = cornersA.map(corner => corner.project(axis));\n      const projectionsB = cornersB.map(corner => corner.project(axis));\n\n      const positionsA = projectionsA.map(vector => vector.dot(axis));\n      const positionsB = projectionsB.map(vector => vector.dot(axis));\n\n      const [maxA, maxA_i] = util.maxAndIndex(positionsA);\n      const [minA, minA_i] = util.minAndIndex(positionsA);\n      const [maxB, maxB_i] = util.maxAndIndex(positionsB);\n      const [minB, minB_i] = util.minAndIndex(positionsB);\n\n      // if the rectangles don't overlaps on at least one axis, they don't collide\n      if (maxA < minB || maxB < minA) {\n        return false;\n      } else {\n        // calculate the overlap between the rectangles on this axis\n        const maxAminB = projectionsA[maxA_i].minus(projectionsB[minB_i]);\n        const maxBminA = projectionsB[maxB_i].minus(projectionsA[minA_i]);\n        if (maxAminB.length2() < maxBminA.length2()) overlaps.push(maxAminB);\n        // the rectangles overlap on the other side, so invert the vector\n        else overlaps.push(maxBminA.scalarMultiply(-1));\n      }\n    }\n\n    // find axis with the least overlap\n    let minVector = overlaps[0];\n    overlaps.forEach(vector => {\n      if (vector.length2() < minVector.length2()) minVector = vector;\n    });\n\n    // return displacement required to remove the rectangle from the collision\n    return minVector.scalarMultiply(-1);\n  }\n}\n","import Point from './Point.js';\n\nexport default class Road {\n  constructor(start, end, segment) {\n    this.start = start;\n    this.end = end;\n    this.segment = segment;\n  }\n\n  setStart(start) {\n    this.start = start;\n    this.segment.collider.updateCollisionProperties({ start: start });\n    this.segment.roadRevision++;\n  }\n\n  setEnd(end) {\n    this.end = end;\n    this.segment.collider.updateCollisionProperties({ end: end });\n    this.segment.roadRevision++;\n  }\n\n  intersects(other) {\n    const r = this.end.minus(this.start);\n    const s = other.end.minus(other.start);\n    const starts = other.start.minus(this.start);\n\n    const numerator = starts.cross(r);\n    const denominator = r.cross(s);\n\n    if (denominator === 0 || numerator === 0) return false;\n\n    const u = numerator / denominator;\n    const t = starts.cross(s) / denominator;\n    const epsilon = 0.001;\n    const intersect = t > epsilon && t < 1 - epsilon && u > epsilon && u < 1 - epsilon;\n    return intersect ? new Point(this.start.x + t * r.x, this.start.y + t * r.y) : intersect;\n  }\n}\n","import Segment from './Segment.js';\nimport Point from './Point.js';\n\nexport default class SegmentFactory {\n  static fromExisting(segment, time, road, params) {\n    time = time || segment.time;\n    road = road || segment.road;\n    params = params || segment.params;\n    return new Segment(road.start, road.end, time, params);\n  }\n\n  static usingDirection(start, direction = 90, length = DEFAULT_SEGMENT_LENGTH, time = 0, params = {}) {\n    // convert direction to radians\n    direction *= Math.PI / 180;\n    const x = start.x + length * Math.sin(direction);\n    const y = start.y + length * Math.cos(direction);\n    return new Segment(start, new Point(x, y), time, params);\n  }\n}\n","import { DEFAULT_SEGMENT_WIDTH,\n         HIGHWAY_SEGMENT_WIDTH,\n         MIN_SPEED_PROPORTION } from './../config.js';\n\nimport Collision from './Collision.js';\nimport Road from './Road.js';\nimport Point from './Point.js';\nimport SegmentFactory from './SegmentFactory.js';\n\nexport default class Segment {\n  static get End() {\n    return { START: 'start', END: 'end' };\n  }\n\n  constructor(start, end, time = 0, params = {}) {\n    this.start = start;\n    this.end = end;\n    this.time = time;\n    this.params = params;\n\n    this.width = params.highway ? HIGHWAY_SEGMENT_WIDTH : DEFAULT_SEGMENT_WIDTH;\n    this.collider = new Collision(this, Collision.Type.LINE, {start: start, end: end, width: this.width});\n\n    this.roadRevision = 0;\n    this.road = new Road(start, end, this);\n\n    // time-step delay before this road is evaluated\n    this.time = time;\n    // meta-information relevant to global goals\n    this.params = params;\n\n    this.links = { backwards: [], forwards: [] };\n\n    this.users = [];\n    this.maxSpeed = params.highway ? 1200 : 800;\n    this.capacity = params.highway ? 12 : 6;\n  }\n\n  currentSpeed() {\n    return Math.min(MIN_SPEED_PROPORTION, 1 - Math.max(0, this.users.length - 1) / this.capacity) * this.maxSpeed;\n  }\n\n  direction() {\n    if (this.directionRevision !== this.roadRevision) {\n      this.directionRevision = this.roadRevision;\n      const vertical = new Point(0, 1);\n      const vector = this.road.end.minus(this.road.start);\n      const cross = vertical.cross(vector);\n      // we want the opposite of the cross sign\n      const sign = cross > 0 ? -1 : cross < 0 ? 1 : 0;\n      this.cachedDirection = sign * vertical.angle(vector);\n    }\n    return this.cachedDirection;\n  }\n\n  length() {\n    if (this.lengthRevision !== this.roadRevision) {\n      this.lengthRevision = this.roadRevision;\n      this.cachedLength = this.road.start.distance(this.road.end);\n    }\n    return this.cachedLength;\n  }\n\n  startIsBackwards() {\n    if (this.links.backwards.length) {\n      return this.links.backwards[0].road.start.equals(this.road.start) ||\n             this.links.backwards[0].road.end.equals(this.road.start);\n    } else {\n      return this.links.forwards[0].road.start.equals(this.road.end) ||\n             this.links.forwards[0].road.end.equals(this.road.end);\n    }\n  }\n\n  cost() {\n    return this.length() / this.currentSpeed();\n  }\n\n  costTo(other, fromFraction) {\n    const segmentEnd = this.endContaining(other);\n    const fraction = fromFraction ? (segmentEnd === Segment.End.START ? fromFraction : 1 - fromFraction) : 0.5;\n    return this.cost() * fraction;\n  }\n\n  neighbors() {\n    return this.links.forwards.concat(this.links.backwards);\n  }\n\n  endContaining(segment) {\n    const backwards = this.startIsBackwards();\n    if (this.links.backwards.includes(segment)) {\n      return backwards ? Segment.End.START : Segment.End.END;\n    } else if (this.links.forwards.includes(segment)) {\n      return backwards ? Segment.End.END : Segment.End.START;\n    }\n  }\n\n  linksForEndContaining(segment) {\n    if (this.links.backwards.includes(segment)) return this.links.backwards;\n    else if (this.links.forwards.includes(segment)) return this.links.forwards;\n  }\n\n  split(point, segment, segments, tree) {\n    const backwards = this.startIsBackwards();\n\n    const splitPart = SegmentFactory.fromExisting(this);\n    splitPart.addSegment(segments, tree);\n    splitPart.road.setEnd(point);\n    this.road.setStart(point);\n\n    splitPart.links.backwards = this.links.backwards.slice(0);\n    splitPart.links.forwards = this.links.forwards.slice(0);\n\n    // determine which links correspond to which end of the split segment\n    const firstSplit = backwards ? splitPart : this;\n    const secondSplit = backwards ? this : splitPart;\n    const fixLinks = backwards ? splitPart.links.backwards : splitPart.links.forwards;\n\n    fixLinks.forEach(link => {\n      let index = link.links.backwards.indexOf(this);\n      if (index !== -1) {\n        link.links.backwards[index] = splitPart;\n      } else {\n        index = link.links.forwards.indexOf(this);\n        link.links.forwards[index] = splitPart;\n      }\n    });\n\n    firstSplit.links.forwards = [segment, secondSplit];\n    secondSplit.links.backwards = [segment, firstSplit];\n\n    segment.links.forwards.push(firstSplit);\n    segment.links.forwards.push(secondSplit);\n  }\n\n  addSegment(segments, tree) {\n    segments.push(this);\n    tree.insert(this.collider.limits());\n  }\n}\n","export default class QuadTree {\n  constructor(bounds, maxObjects = 10, maxLevels = 4, level = 0) {\n    this.bounds = bounds;\n    this.maxObjects = maxObjects;\n    this.maxLevels = maxLevels;\n    this.level = level;\n\n    this.objects = [];\n    this.nodes = [];\n  }\n\n  subdivide() {\n    const width = Math.round(this.bounds.width / 2);\n    const height = Math.round(this.bounds.height / 2);\n    const x = Math.round(this.bounds.x);\n    const y = Math.round(this.bounds.y);\n\n    // top right node\n    this.nodes[0] = new QuadTree({\n      x: x + width,\n      y: y,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n\n    // top left node\n    this.nodes[1] = new QuadTree({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n\n    // bottom left node\n    this.nodes[2] = new QuadTree({\n      x: x,\n      y: y + height,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n\n    // bottom right node\n    this.nodes[3] = new QuadTree({\n      x: x + width,\n      y: y + height,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n  }\n\n  // determines which node the given rectangle is in\n  getIndex(rect) {\n    let index = -1;\n    const midpointX = this.bounds.x + this.bounds.width / 2;\n    const midpointY = this.bounds.y + this.bounds.height / 2;\n\n    const top = rect.y < midpointY && rect.y + rect.height < midpointY;\n    const bottom = rect.y > midpointY;\n\n    if (rect.x < midpointX && rect.x + rect.width < midpointX) {\n      index = top ? 1 : bottom ? 2 : index;\n    } else if (rect.x > midpointX) {\n      index = top ? 0 : bottom ? 3 : index;\n    }\n    return index;\n  }\n\n  insert(rect) {\n    if (this.nodes.length) {\n      const i = this.getIndex(rect);\n      if (i !== -1) return this.nodes[i].insert(rect);\n    }\n\n    this.objects.push(rect);\n\n    if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {\n      if (this.nodes.length === 0) this.subdivide();\n\n      let i = 0;\n      while (i < this.objects.length) {\n        const index = this.getIndex(this.objects[i]);\n        if (index !== -1) this.nodes[index].insert(this.objects.splice(i, 1)[0]);\n        else i++;\n      }\n    }\n  }\n\n  // returns all objects that collide with the given object\n  retrieve(rect) {\n    const index = this.getIndex(rect);\n    let objects = this.objects;\n\n    if (this.nodes.length) {\n      if (index !== -1) {\n        objects = objects.concat(this.nodes[index].retrieve(rect));\n      } else {\n        // check against all subnodes\n        for (const node of this.nodes) {\n          objects = objects.concat(node.retrieve(rect));\n        }\n      }\n    }\n    return objects;\n  }\n\n  clear() {\n    this.objects = [];\n    for (const node of this.nodes) {\n      node.clear();\n    }\n  }\n}\n","import { ROAD_SNAP_DISTANCE,\n         MINIMUM_INTERSECTION_DEVIATION,\n         DEFAULT_SEGMENT_LENGTH,\n         HIGHWAY_SEGMENT_LENGTH,\n         NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY,\n         BRANCH_ANGLE, FORWARD_ANGLE,\n         HIGHWAY_BRANCH_POPULATION_THRESHOLD,\n         NORMAL_BRANCH_POPULATION_THRESHOLD,\n         HIGHWAY_BRANCH_PROBABILITY,\n         DEFAULT_BRANCH_PROBABILITY,\n         QUADTREE_PARAMS, QUADTREE_MAX_OBJECTS, QUADTREE_MAX_LEVELS,\n         SEGMENT_COUNT_LIMIT } from './config.js';\nimport * as util from './util.js';\nimport * as noise from './perlin.js';\n\nimport Point from './classes/Point.js';\nimport Heatmap from './classes/Heatmap.js';\nimport Segment from './classes/Segment.js';\nimport QuadTree from './classes/QuadTree.js';\nimport SegmentFactory from './classes/SegmentFactory.js';\n\nfunction localConstraints(segment, segments, tree, debugData) {\n  const action = { priority: 0, params: {} };\n\n  const matches = tree.retrieve(segment.collider.limits());\n  for (const match of matches) {\n    const other = match.object;\n\n    // intersection check\n    if (action.priority < 5) {\n      const intersection = segment.road.intersects(other.road);\n      if (intersection) {\n        if (!action.params.time || intersection.time < actions.params.time) {\n          action.params.time = intersection.time;\n          action.priority = 4;\n          // if intersecting lines are too similar don't continue\n          if (util.minDegreeDifference(other.direction(), segment.direction()) < MINIMUM_INTERSECTION_DEVIATION) {\n            return false;\n          }\n\n          other.split(intersection, segment, segments, tree);\n          segment.road.end = intersection;\n          segment.params.severed = true;\n\n          if (debugData) {\n            debugData.intersections = debugData.intersections || [];\n            debugData.intersections.push(new Point(intersection.x, intersection.y));\n          }\n\n          return true;\n        }\n      }\n    }\n\n    // snap to crossing within radius check\n    if (action.priority < 4) {\n      // current segment's start must have been checked to have been created\n      // other segment's start must have a corresponding end\n      if (segment.road.end.distance(other.road.end) <= ROAD_SNAP_DISTANCE) {\n        const point = other.road.end;\n        action.priority = 3;\n        segment.road.end = point;\n        segment.params.severed = true;\n\n        // update other's links corresponding to other.road.end\n        const links = other.startIsBackwards() ? other.links.forwards : other.links.backwards;\n\n        // check for duplicate lines, don't add if it exists\n        const duplicates = links.some(link => {\n          return (link.road.start.equals(segment.road.end) && link.road.end.equals(segment.road.start)) ||\n            (link.road.start.equals(segment.road.start) && link.road.end.equals(segment.road.end));\n        });\n        if (duplicates) return false;\n\n        links.forEach(link => {\n          // pick links of remaining segments at junction corresponding to other.road.end\n          link.linksForEndContaining(other).push(segment);\n\n          // add junction segments to snapped segment\n          segment.links.forwards.push(link);\n        });\n\n        links.push(segment);\n        segment.links.forwards.push(other);\n\n        if (debugData) {\n          debugData.snaps = debugData.snaps || [];\n          debugData.snaps.push(new Point(point.x, point.y));\n        }\n\n        return true;\n      }\n    }\n\n    // intersection with radius check\n    if (action.priority < 3) {\n      const { distance2, pointOnLine, lineProj2, length2 } =\n        segment.road.end.distanceToLine(other.road.start, other.road.end);\n      if (distance2 < ROAD_SNAP_DISTANCE * ROAD_SNAP_DISTANCE && lineProj2 >= 0 && lineProj2 <= length2) {\n        const point = pointOnLine;\n        action.priority = 2;\n        segment.road.end = point;\n        segment.params.severed = true;\n\n        // if intersecting lines are too similar don't continue\n        if (util.minDegreeDifference(other.direction(), segment.direction()) < MINIMUM_INTERSECTION_DEVIATION) {\n          return false;\n        }\n\n        other.split(point, segment, segments, tree);\n\n        if (debugData) {\n          debugData.intersectionsRadius = debugData.intersectionsRadius || [];\n          debugData.intersectionsRadius.push(new Point(point.x, point.y));\n        }\n\n        return true;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction globalGoals(previousSegment) {\n  const newBranches = [];\n  if (!previousSegment.params.severed) {\n    const template = (direction, length, time, params) => SegmentFactory.usingDirection(previousSegment.road.end, direction, length, time, params);\n\n    // used for highways or going straight on a normal branch\n    const templateContinue = (direction) => template(direction, previousSegment.length(), 0, previousSegment.params);\n    // not using params, i.e. not highways\n    const templateBranch = (direction) => template(direction, DEFAULT_SEGMENT_LENGTH, previousSegment.params.highway ? NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY : 0);\n\n    const continueStraight = templateContinue(previousSegment.direction());\n    const straightPop = Heatmap.popOnRoad(continueStraight.road);\n\n    if (previousSegment.params.highway) {\n      const randomStraight = templateContinue(previousSegment.direction() + util.randomAngle(FORWARD_ANGLE));\n      const randomPop = Heatmap.popOnRoad(randomStraight.road);\n      const roadPop = randomPop > straightPop ? randomPop : straightPop;\n      newBranches.push(randomPop > straightPop ? randomStraight : continueStraight);\n\n      if (roadPop > HIGHWAY_BRANCH_POPULATION_THRESHOLD) {\n        if (Math.random() < HIGHWAY_BRANCH_PROBABILITY) {\n          const leftHighwayBranch = templateContinue(previousSegment.direction() - 90 + util.randomAngle(BRANCH_ANGLE));\n          newBranches.push(leftHighwayBranch);\n        } else if (Math.random() < HIGHWAY_BRANCH_PROBABILITY) {\n          const rightHighwayBranch = templateContinue(previousSegment.direction() + 90 + util.randomAngle(BRANCH_ANGLE));\n          newBranches.push(rightHighwayBranch);\n        }\n      }\n    } else if (straightPop > NORMAL_BRANCH_POPULATION_THRESHOLD) {\n      newBranches.push(continueStraight);\n    }\n\n    if (straightPop > NORMAL_BRANCH_POPULATION_THRESHOLD) {\n      if (Math.random() < DEFAULT_BRANCH_PROBABILITY) {\n        const leftBranch = templateBranch(previousSegment.direction() - 90 + util.randomAngle(BRANCH_ANGLE));\n        newBranches.push(leftBranch);\n      } else if (Math.random() < DEFAULT_BRANCH_PROBABILITY) {\n        const rightBranch = templateBranch(previousSegment.direction() + 90 + util.randomAngle(BRANCH_ANGLE));\n        newBranches.push(rightBranch);\n      }\n    }\n  }\n\n  for (const branch of newBranches) {\n    branch.setUpBranchLinks = () => {\n      // set up links between each current branch and each existing branch stemming from the previous segment\n      previousSegment.links.forwards.forEach(link => {\n        branch.links.backwards.push(link);\n        link.linksForEndContaining(previousSegment).push(branch);\n      });\n\n      previousSegment.links.forwards.push(branch);\n      branch.links.backwards.push(previousSegment);\n    }\n  }\n\n  return newBranches;\n}\n\nexport function generate(seed) {\n  const debugData = {};\n  // TODO: change this to use seed data from user input\n  noise.seed(Math.random());\n\n  const queue = [];\n  const rootSegment = new Segment(seed, new Point(seed.x + HIGHWAY_SEGMENT_LENGTH, seed.y), 0, { highway: true });\n  const oppositeDirection = SegmentFactory.fromExisting(rootSegment);\n  const newEnd = new Point(rootSegment.road.start.x - HIGHWAY_SEGMENT_LENGTH, oppositeDirection.road.end.y);\n  oppositeDirection.road.setEnd(newEnd);\n  oppositeDirection.links.backwards.push(rootSegment);\n  rootSegment.links.backwards.push(oppositeDirection);\n  queue.push(rootSegment);\n  queue.push(oppositeDirection);\n\n  const segments = [];\n  // TODO: bounds should be the bounding box of the polygon\n  // TODO: maxObjects should vary based on the type of city area\n  const treeParams = { x: seed.x, y: seed.y, width: HIGHWAY_SEGMENT_LENGTH, height: HIGHWAY_SEGMENT_LENGTH };\n  const tree = new QuadTree(treeParams, QUADTREE_MAX_OBJECTS, QUADTREE_MAX_LEVELS);\n\n  while (queue.length && segments.length < SEGMENT_COUNT_LIMIT) {\n    // pop smallest road from the priority queue (i.e. smallest time)\n    let minT = queue[0].time;\n    let minT_i = 0;\n    queue.forEach((segment, i) => {\n      if (segment.time < minT) {\n        minT = segment.time;\n        minT_i = i;\n      }\n    });\n\n    const minSegment = queue.splice(minT_i, 1)[0];\n    const accepted = localConstraints(minSegment, segments, tree, debugData);\n    if (accepted) {\n      if (minSegment.setUpBranchLinks) {\n        minSegment.setUpBranchLinks();\n      }\n      minSegment.addSegment(segments, tree);\n      globalGoals(minSegment).forEach(segment => {\n        segment.time += minSegment.time + 1;\n        queue.push(segment);\n      });\n    }\n  }\n\n  let id = 0;\n  for (const segment of segments) {\n    segment.id = id++;\n  }\n\n  return segments;\n}\n","export function drawSegment(context, segment) {\n  context.strokeStyle = segment.params.highway ? '#FF0000' : '#000000';\n  context.lineWidth = segment.width;\n\n  context.beginPath();\n  context.moveTo(segment.road.start.x, segment.road.start.y);\n  context.lineTo(segment.road.end.x, segment.road.end.y);\n  context.closePath();\n  context.stroke();\n}\n","import Point from './classes/Point.js';\nimport * as generator from './generation.js';\nimport * as draw from './draw.js';\n\nconst canvas = document.getElementById('canvas');\nconst context = canvas.getContext('2d');\ncanvas.width = window.innerWidth * 0.85; // canvas is 85vw\ncanvas.height = window.innerHeight;\n\ndocument.getElementById('generate').addEventListener('click', event => {\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  // seed is the point at which the highway starts\n  const seed = new Point(canvas.width / 2, canvas.height / 2);\n  const segments = generator.generate(seed);\n  segments.forEach(segment => draw.drawSegment(context, segment));\n});\n"]}