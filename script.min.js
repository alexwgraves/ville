const SUPPORTS_POINTER="PointerEvent"in window,SUPPORTS_TOUCH="ontouchstart"in window,canvas=document.getElementById("canvas"),context=canvas.getContext("2d");canvas.width=window.innerWidth,canvas.height=window.innerHeight,context.lineJoin="round",this.drawing=!1,this.xClicks=[],this.yClicks=[],this.dragClicks=[],this.currentBrush=document.querySelector(".active").classList[1],this.lastBrush=this.currentBrush;const brushes=Array.prototype.slice.call(document.getElementsByClassName("brush")),brushColors={skyscrapers:"rgb(203,203,203)",residential:"rgb(252,139,148)",commercial:"rgb(191,140,190)",water:"rgb(180,207,226)",parks:"rgb(140,191,142)"},brushSize=document.getElementById("brush-size"),currentBrushSize=document.getElementById("current-brush-size");this.currentSize=parseInt(brushSize.value);var debugMode=!1,scale=20;this.clickData={skyscrapers:[],residential:[],commercial:[],water:[],parks:[]},this.innerPoints={skyscrapers:[],residential:[],commercial:[],water:[],parks:[]},this.polygons=[],this.polygonIndex=0;class Point{constructor(a,b){this.x=a,this.y=b}}class Circle{constructor(a,b,c){this.x=a,this.y=b,this.r=c/2}}class Polygon{constructor(a,b){this.edges=a,this.color=b}boundingBox(){let a=canvas.width,b=0,c=canvas.height,d=0;for(const e of this.edges)a=e.x<a?e.x:a,b=e.x>b?e.x:b,c=e.y<c?e.y:c,d=e.y>d?e.y:d;this.boundaries=[new Point(a,c),new Point(b,c),new Point(b,d),new Point(a,d)],debugMode&&(context.lineWidth=1,context.strokeStyle="#FF0000",context.strokeRect(a,c,b-a,d-c),context.lineWidth=this.currentSize)}scatterPoints(){var a=Math.round,b=Math.min;if("parks"===this.color||"water"===this.color)return;const c=[],d=this.boundaries[0].x,e=this.boundaries[0].y,f=this.boundaries[1].x,g=this.boundaries[3].y;for(let h=d;h<f;h+=scale)for(let d=e;d<g;d+=scale){const e=b(h+Math.random()*scale,f),i=b(d+Math.random()*scale,g);c.push(new Point(a(e),a(i)))}if(debugMode)for(const a of c)context.fillStyle="#000",context.fillRect(a.x,a.y,1,1);const h={};if(this.edges.forEach(a=>{h[a.y]?h[a.y].push(a.x):h[a.y]=[a.x]}),this.points=[],c.forEach(a=>{let b=0,c=0;for(let d=a.x;d<f+1;d++)h[a.y].includes(d)&&(1<d-b&&c++,b=d);0!=c%2&&this.points.push(a)}),debugMode)for(const a of this.points)context.fillStyle="#FF0000",context.fillRect(a.x,a.y,1,1)}}function render(){for(let a=0;a<this.xClicks.length;a++)context.strokeStyle=brushColors[this.currentBrush],context.lineWidth=this.currentSize,context.beginPath(),this.dragClicks[a]&&0<a?context.moveTo(this.xClicks[a-1],this.yClicks[a-1]):context.moveTo(this.xClicks[a]-1,this.yClicks[a]-1),context.lineTo(this.xClicks[a],this.yClicks[a]),context.closePath(),context.stroke()}function addClick(a,b,c){this.xClicks.push(a),this.yClicks.push(b),this.dragClicks.push(c),this.clickData[this.currentBrush].push(new Circle(a,b,this.currentSize))}function clearActiveBrushes(){brushes.forEach(a=>{a.classList.remove("active")})}function onEventDown(a){const b=this.clickData[this.lastBrush].length-1;-1<b&&this.polygons.push(detectEdges(this.clickData[this.lastBrush][b],this.lastBrush));const c=a.pageX-canvas.offsetLeft,d=a.pageY-canvas.offsetTop;this.drawing=!0,addClick(c,d),render()}function onEventMove(a){this.drawing&&(addClick(a.pageX-canvas.offsetLeft,a.pageY-canvas.offsetTop,!0),render())}function onEventUp(){this.drawing=!1,this.xClicks=[],this.yClicks=[],this.dragClicks=[]}function detectEdges(a,b){const c=[],d=brushColors[b].slice(4,-1).split(",");let e=a.x+a.r-1,f=a.y,g=a.x+a.r-1,h=context.getImageData(g++,f,1,1).data;for(;h[0]==d[0]&&h[1]==d[1]&&h[2]==d[2];)e=g,h=context.getImageData(g++,f,1,1).data;const i=new Point(e-1,f),j=(a,b)=>{var e=Math.abs;const f=[new Point(a.x+1,a.y),new Point(a.x+1,a.y+1),new Point(a.x,a.y+1),new Point(a.x-1,a.y+1),new Point(a.x-1,a.y),new Point(a.x-1,a.y-1),new Point(a.x,a.y-1),new Point(a.x+1,a.y-1)],g=f.findIndex(a=>a.x===b.x&&a.y===b.y);if(7>g)for(let a=0;a<g+1;a++)f.splice(7,0,f.shift());const h=f.findIndex(a=>{const b=context.getImageData(a.x,a.y,1,1).data;return 5<e(b[0]-d[0])||5<e(b[1]-d[1])||5<e(b[2]-d[2])}),k=f.findIndex(a=>{const c=context.getImageData(a.x,a.y,1,1).data;return(a.x!==b.x||a.y!==b.y)&&6>e(c[0]-d[0])&&6>e(c[1]-d[1])&&6>e(c[2]-d[2])});if(-1!==h){c.push(new Point(a.x,a.y));const b=f[k];return b.x===i.x&&b.y===i.y?void 0:j(b,a)}};return j(i,i),new Polygon(c,b)}function generateCity(){const a=this.clickData[this.currentBrush].length-1;-1<a&&this.polygons.push(detectEdges(this.clickData[this.currentBrush][a],this.currentBrush));for(const a of this.polygons)a.boundingBox(),a.scatterPoints()}window.addEventListener("resize",()=>{canvas.width=window.innerWidth,canvas.height=window.innerHeight,render()}),SUPPORTS_POINTER?(canvas.addEventListener("pointerdown",a=>{onEventDown(a)}),canvas.addEventListener("pointermove",a=>{onEventMove(a)}),canvas.addEventListener("pointerup",a=>{onEventUp(a)}),canvas.addEventListener("pointercancel",a=>{onEventUp(a)})):SUPPORTS_TOUCH?(canvas.addEventListener("touchstart",a=>{onEventDown(a)}),canvas.addEventListener("touchmove",a=>{onEventMove(a)}),canvas.addEventListener("touchend",a=>{onEventUp(a)}),canvas.addEventListener("touchcancel",a=>{onEventUp(a)})):(canvas.addEventListener("mousedown",a=>{onEventDown(a)}),canvas.addEventListener("mousemove",a=>{onEventMove(a)}),canvas.addEventListener("mouseup",a=>{onEventUp(a)}),canvas.addEventListener("mouseleave",a=>{onEventUp(a)})),brushes.forEach(a=>{a.addEventListener("click",()=>{clearActiveBrushes(),this.lastBrush=this.currentBrush,this.currentBrush=a.classList[1],a.classList.add("active")})}),brushSize.addEventListener("input",()=>{this.currentSize=parseInt(brushSize.value),currentBrushSize.innerText=brushSize.value}),document.getElementById("debug").addEventListener("change",a=>{debugMode=a.target.checked,document.getElementById("debug-controls").style.display=debugMode?"block":"none"}),document.getElementById("generate").addEventListener("click",a=>{generateCity(),a.target.disabled=!0,a.target.classList.add("disabled")}),document.getElementById("edges").addEventListener("click",()=>{if(debugMode)for(const a of this.polygons)for(const b of a.edges)context.fillStyle="#000",context.fillRect(b.x,b.y,1,1)});