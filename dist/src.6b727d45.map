{"version":3,"sources":["src/classes/Point.js","src/config.js","src/util.js","third_party/perlin.js","src/classes/Heatmap.js","src/classes/Collision.js","src/classes/Road.js","src/classes/SegmentFactory.js","src/classes/Segment.js","src/classes/QuadTree.js","src/generation.js","src/draw.js","src/index.js"],"names":["Point","x","y","Math","sqrt","length2","other","v","minus","length","s","radians","acos","dot","PI","scalarMultiply","start","end","toStart","line","projected","project","result","add","sign","distance2","pointOnLine","lineProj2","DEFAULT_SEGMENT_WIDTH","HIGHWAY_SEGMENT_WIDTH","DEFAULT_SEGMENT_LENGTH","HIGHWAY_SEGMENT_LENGTH","SEGMENT_COUNT_LIMIT","BRANCH_ANGLE","FORWARD_ANGLE","HIGHWAY_BRANCH_PROBABILITY","DEFAULT_BRANCH_PROBABILITY","HIGHWAY_BRANCH_POPULATION_THRESHOLD","NORMAL_BRANCH_POPULATION_THRESHOLD","ROAD_SNAP_DISTANCE","MINIMUM_INTERSECTION_DEVIATION","MIN_SPEED_PROPORTION","NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY","QUADTREE_MAX_OBJECTS","QUADTREE_MAX_LEVELS","randomRange","min","max","random","minDegreeDifference","a","b","diff","abs","randomAngle","limit","value","nonUniformNorm","pow","minAndIndex","array","min_i","forEach","entry","i","maxAndIndex","max_i","Grad","z","grad3","p","perm","Array","gradP","seed","floor","F2","G2","F3","G3","simplex2","xin","yin","n0","j","t","x0","y0","i1","j1","x1","y1","x2","y2","gi0","gi1","gi2","t0","t1","t2","dot2","Heatmap","one","noise","two","three","road","populationAt","Collision","object","type","properties","collisionRevision","limitsRevision","undefined","cachedLimits","RECT","LINE","CIRCLE","prop","axis","minCorner","corners","corner","maxCorner","Type","minX","minY","width","height","center","radius","limits","otherLimits","rectCircleCollision","rectRectIntersection","circle","rectPropsFromLine","distanceToLine","axes","center0","center2","projections","dots","direction","perpendicular","halfWidth","rect","cornersA","cornersB","overlaps","projectionsA","map","projectionsB","positionsA","vector","positionsB","util","maxA","maxA_i","minA","minA_i","maxB","maxB_i","minB","minB_i","maxAminB","maxBminA","push","minVector","Road","segment","collider","updateCollisionProperties","roadRevision","SegmentFactory","time","params","Segment","sin","cos","highway","directionRevision","lengthRevision","cachedDirection","cachedLength","links","backwards","forwards","users","maxSpeed","capacity","START","END","vertical","cross","angle","distance","equals","currentSpeed","fromFraction","endContaining","segmentEnd","fraction","End","cost","concat","startIsBackwards","includes","point","segments","tree","splitPart","fromExisting","addSegment","setEnd","setStart","slice","firstSplit","secondSplit","link","index","indexOf","insert","QuadTree","bounds","maxObjects","maxLevels","level","objects","nodes","round","midpointX","midpointY","top","bottom","getIndex","subdivide","splice","retrieve","node","clear","doRoadSegmentsIntersect","intersectX","intersectY","localConstraints","debugData","action","priority","matches","match","intersection","actions","function","split","severed","intersections","duplicates","some","linksForEndContaining","snaps","intersectionsRadius","globalGoals","previousSegment","newBranches","template","usingDirection","templateContinue","templateBranch","continueStraight","straightPop","popOnRoad","randomStraight","randomPop","roadPop","leftHighwayBranch","rightHighwayBranch","leftBranch","rightBranch","branch","setUpBranchLinks","generate","queue","rootSegment","oppositeDirection","newEnd","treeParams","minT","minT_i","minSegment","id","drawSegment","context","strokeStyle","lineWidth","beginPath","moveTo","lineTo","closePath","stroke","canvas","document","getElementById","getContext","window","innerWidth","innerHeight","addEventListener","event","clearRect","generator","draw"],"mappings":"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","file":"src.6b727d45.map","sourceRoot":"..","sourcesContent":["export default class Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  length() {\n    return Math.sqrt(this.length2());\n  }\n\n  length2() {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  distance(other) {\n    const v = other.minus(this);\n    return v.length();\n  }\n\n  distance2(other) {\n    const v = other.minus(this);\n    return v.length2();\n  }\n\n  equals(other) {\n    return this.x === other.x && this.y === other.y;\n  }\n\n  scalarMultiply(s) {\n    return new Point(this.x * s, this.y * s);\n  }\n\n  add(other) {\n    return new Point(this.x + other.x, this.y + other.y);\n  }\n\n  minus(other) {\n    return new Point(this.x - other.x, this.y - other.y);\n  }\n\n  dot(other) {\n    return this.x * other.x + this.y * other.y;\n  }\n\n  cross(other) {\n    return this.x * other.y - this.y * other.x;\n  }\n\n  angle(other) {\n    const radians = Math.acos(this.dot(other) / (this.length() * other.length()));\n    return radians * 180 / Math.PI;\n  }\n\n  project(other) {\n    return other.scalarMultiply(this.dot(other) / other.length());\n  }\n\n  distanceToLine(start, end) {\n    const toStart = this.minus(start);\n    const line = end.minus(start);\n    const projected = toStart.project(line);\n    const result = start.add(projected);\n    const dot = toStart.dot(line);\n    const sign = dot < 0 ? -1 : dot > 0 ? 1 : 0;\n\n    return {\n      distance2: result.distance2(this),\n      pointOnLine: result,\n      // distance along line of projected point\n      lineProj2:  sign * projected.length2(),\n      length2: line.length2()\n    }\n  }\n}\n","export const DEFAULT_SEGMENT_WIDTH = 1;\nexport const HIGHWAY_SEGMENT_WIDTH = 2;\nexport const DEFAULT_SEGMENT_LENGTH = 30;\nexport const HIGHWAY_SEGMENT_LENGTH = 40;\nexport const SEGMENT_COUNT_LIMIT = 500;\n\nexport const BRANCH_ANGLE = 3; // in degrees\nexport const FORWARD_ANGLE = 15; // in degrees\n\nexport const HIGHWAY_BRANCH_PROBABILITY = 0.05;\nexport const DEFAULT_BRANCH_PROBABILITY = 0.4;\n\nexport const HIGHWAY_BRANCH_POPULATION_THRESHOLD = 0.1;\nexport const NORMAL_BRANCH_POPULATION_THRESHOLD = 0.1;\n\nexport const ROAD_SNAP_DISTANCE = 500;\nexport const MINIMUM_INTERSECTION_DEVIATION = 30; // in degrees\n\nexport const MIN_SPEED_PROPORTION = 0.1;\nexport const NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY = 5;\n\nexport const QUADTREE_MAX_OBJECTS = 10;\nexport const QUADTREE_MAX_LEVELS = 10;\n","function randomRange(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nexport function minDegreeDifference(a, b) {\n  const diff = Math.abs(a - b) % 180;\n  return Math.min(diff, Math.abs(diff - 180));\n}\n\nexport function randomAngle(limit) {\n  const nonUniformNorm = Math.pow(Math.abs(limit), 3);\n  let value = 0;\n  while (value === 0 || Math.random() < Math.pow(Math.abs(value), 3) / nonUniformNorm) {\n    value = randomRange(-limit, +limit);\n  }\n  return value;\n}\n\nexport function minAndIndex(array) {\n  let min = array[0];\n  let min_i = 0;\n  array.forEach((entry, i) => {\n    if (entry < min) {\n      min = entry;\n      min_i = i;\n    }\n  });\n  return [min, min_i];\n}\n\nexport function maxAndIndex(array) {\n  let max = array[0];\n  let max_i = 0;\n  array.forEach((entry, i) => {\n    if (entry > max) {\n      max = entry;\n      max_i = i;\n    }\n  });\n  return [max, max_i];\n}\n","/*\n * Adapted from https://github.com/josephg/noisejs\n */\n\nclass Grad {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  dot2(x, y) {\n    return this.x * x + this.y * y;\n  }\n}\n\nconst grad3 = [\n  new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),\n  new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),\n  new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)\n];\n\nconst p = [151,160,137,91,90,15,\n131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\nconst perm = new Array(512);\nconst gradP = new Array(512);\n\nexport function seed(seed) {\n  if (seed > 0 && seed < 1) {\n    // Scale the seed out\n    seed *= 65536;\n  }\n\n  seed = Math.floor(seed);\n  if (seed < 256) {\n    seed |= seed << 8;\n  }\n\n  for (let i = 0; i < 256; i++) {\n    const v = i & 1 ? p[i] ^ (seed & 255) : p[i] ^ ((seed>>8) & 255);\n    perm[i] = perm[i + 256] = v;\n    gradP[i] = gradP[i + 256] = grad3[v % 12];\n  }\n}\n\nseed(0);\n\n// Skewing and unskewing factors for 2, 3, and 4 dimensions\nconst F2 = 0.5 * (Math.sqrt(3) - 1);\nconst G2 = (3 - Math.sqrt(3)) / 6;\n\nconst F3 = 1 / 3;\nconst G3 = 1 / 6;\n\n// 2D simplex noise\nexport function simplex2(xin, yin) {\n  let n0, n1, n2; // Noise contributions from the three corners\n  // Skew the input space to determine which simplex cell we're in\n  const s = (xin + yin) * F2; // Hairy factor for 2D\n  let i = Math.floor(xin + s);\n  let j = Math.floor(yin + s);\n  const t = (i + j) * G2;\n  const x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n  const y0 = yin - j + t;\n  // For the 2D case, the simplex shape is an equilateral triangle.\n  // Determine which simplex we are in.\n  // Offsets for second (middle) corner of simplex in (i,j) coords\n  const i1 = x0 > y0 ? 1 : 0;\n  const j1 = x0 > y0 ? 0 : 1;\n  // x0 > y0 is lower triangle, XY order: (0,0)->(1,0)->(1,1)\n  // otherwise is upper triangle, YX order: (0,0)->(0,1)->(1,1)\n  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n  // c = (3-sqrt(3))/6\n  const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n  const y1 = y0 - j1 + G2;\n  const x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n  const y2 = y0 - 1 + 2 * G2;\n  // Work out the hashed gradient indices of the three simplex corners\n  i &= 255;\n  j &= 255;\n  const gi0 = gradP[i + perm[j]];\n  const gi1 = gradP[i + i1 + perm[j + j1]];\n  const gi2 = gradP[i + 1 + perm[j + 1]];\n  // Calculate the contribution from the three corners\n  let t0 = 0.5 - x0 * x0 - y0 * y0;\n  if (t0 < 0) {\n    n0 = 0;\n  } else {\n    t0 *= t0;\n    n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\n  }\n  let t1 = 0.5 - x1 * x1 - y1 * y1;\n  if(t1 < 0) {\n    n1 = 0;\n  } else {\n    t1 *= t1;\n    n1 = t1 * t1 * gi1.dot2(x1, y1);\n  }\n  let t2 = 0.5 - x2 * x2 - y2 * y2;\n  if (t2 < 0) {\n    n2 = 0;\n  } else {\n    t2 *= t2;\n    n2 = t2 * t2 * gi2.dot2(x2, y2);\n  }\n  // Add contributions from each corner to get the final noise value.\n  // The result is scaled to return values in the interval [-1,1].\n  return 70 * (n0 + n1 + n2);\n}\n","import * as noise from './../../third_party/perlin.js';\n\nexport default class Heatmap {\n  static populationAt(x, y) {\n    const one = (noise.simplex2(x / 20000, y / 10000) + 1) / 2;\n    const two = (noise.simplex2(x / 20000 + 500, y / 20000 + 500) + 1) / 2;\n    const three = (noise.simplex2(x / 10000 + 1000, y / 20000 + 1000) + 1) / 2;\n    return Math.pow((one * two + three) / 2, 2);\n  }\n\n  static popOnRoad(road) {\n    return (this.populationAt(road.start.x, road.start.y) + this.populationAt(road.end.x, road.end.y)) / 2;\n  }\n}\n","import Point from './Point.js';\n\nexport default class Collision {\n  static get Type() {\n    return { RECT: 'rect', LINE: 'line', CIRCLE: 'circle' };\n  }\n\n  constructor(object, type, properties) {\n    this.object = object;\n    this.type = type;\n    this.properties = properties;\n    this.collisionRevision = 0;\n    this.limitsRevision = undefined;\n    this.cachedLimits = undefined;\n  }\n\n  updateCollisionProperties(properties) {\n    this.collisionRevision++;\n    for (const prop in properties) {\n      this.properties[prop] = properties[prop];\n    }\n  }\n\n  minCorner(axis) {\n    let minCorner = this.properties.corners[0];\n    this.properties.corners.forEach(corner => {\n      if (corner[axis] < minCorner[axis]) minCorner = corner;\n    });\n    return minCorner;\n  }\n\n  maxCorner(axis) {\n    let maxCorner = this.properties.corners[0];\n    this.properties.corners.forEach(corner => {\n      if (corner[axis] > maxCorner[axis]) maxCorner = corner;\n    });\n    return maxCorner;\n  }\n\n  limits() {\n    if (this.collisionRevision !== this.limitsRevision) {\n      this.limitsRevision = this.collisionRevision;\n      if (this.type === Collision.Type.RECT) {\n        minX = this.minCorner('x').x;\n        minY = this.minCorner('y').y;\n        this.cachedLimits = {\n          x: minX,\n          y: minY,\n          width: this.maxCorner('x').x - minX,\n          height: this.maxCorner('y').y - minY,\n          object: this.object\n        }\n      } else if (this.type === Collision.Type.LINE) {\n        this.cachedLimits = {\n          x: Math.min(this.properties.start.x, this.properties.end.x),\n          y: Math.min(this.properties.start.y, this.properties.end.y),\n          width: Math.abs(this.properties.start.x - this.properties.end.x),\n          height: Math.abs(this.properties.start.y - this.properties.end.y),\n          object: this.object\n        }\n      } else if (this.type === Collision.Type.CIRCLE) {\n        this.cachedLimits = {\n          x: this.properties.center.x - this.properties.radius,\n          y: this.properties.center.y - this.properties.radius,\n          width: this.properties.radius * 2,\n          height: this.properties.radius * 2,\n          object: this.object\n        }\n      }\n    }\n    return this.cachedLimits;\n  }\n\n  collide(other) {\n    // avoid expensive collision check if possible\n    const limits = this.limits();\n    const otherLimits = other.limits();\n    if (limits && otherLimits &&\n        (limits.x + limits.width < otherLimits.x || otherLimits.x + otherLimits.width < limits.x) &&\n        (limits.y + limits.height < otherLimits.y || otherLimits.y + otherLimits.height < limits.y)) {\n      return false;\n    }\n\n    if (this.type === Collision.Type.CIRCLE) {\n      if (other.type === Collision.Type.RECT) {\n        other.rectCircleCollision(this);\n      }\n    } else if (this.type === Collision.Type.RECT) {\n      if (other.type !== Collision.Type.CIRCLE) {\n        this.rectRectIntersection(other);\n      } else {\n        this.rectCircleCollision(other);\n      }\n    } else if (this.type === Collision.Type.LINE) {\n      if (other.type !== Collision.Type.CIRCLE) {\n        this.rectRectIntersection(other);\n      }\n    }\n  }\n\n  rectCircleCollision(circle) {\n    // this must be a rectangle or line to call this function\n    if (this.type === Collision.Type.CIRCLE) return;\n    // other must be a circle to call this function\n    if (circle.type !== Collision.Type.CIRCLE) return;\n\n    // get the correct properties\n    const properties = this.type === Collision.Type.LINE ? this.rectPropsFromLine() : this.properties;\n    const corners = properties.corners;\n    const radius = circle.properties.radius;\n\n    // check for corner intersections with circle\n    for (const corner of corners) {\n      if (corner.distance2(circle.properties.center) <= radius * radius) {\n        return true;\n      }\n\n      // check for edge intersections with circle\n      for (let i = 0; i < corners.length; i++) {\n        const start = corners[i];\n        const end = corners[(i + 1) % corners.length];\n        const {distance2, pointOnLine, lineProj2, length2} = circle.properties.center.distanceToLine(start, end);\n        if (lineProj2 > 0 && lineProj2 < length2 && distance2 <= radius * radius) {\n          return true;\n        }\n      }\n\n      // check that the circle is not enclosed by the rectangle\n      const axes = [corners[3].minus(corners[0]), corners[3].minus(corners[2])];\n      const center0 = circle.properties.center.minus(corners[0]);\n      const center2 = circle.properties.center.minus(corners[2]);\n      const projections = [center0.project(axes[0]), center2.project(axes[1])];\n      const dots = [center0.dot(axes[0]), center2.dot(axes[1])];\n      if (dots[0] < 0 || projections[0].length2() > axes[0].length2() ||\n          dots[1] < 0 || projections[1].length2() > axes[1].length2()) {\n        return false;\n      }\n      return true;\n    }\n  }\n\n  rectPropsFromLine() {\n    // this must be a line to call this function\n    if (this.type !== Collision.Type.LINE) return;\n\n    const direction = this.properties.end.minus(this.properties.start);\n    const perpendicular = new Point(-direction.y, direction.x);\n    const halfWidth = perpendicular.scalarMultiply(0.5 * this.properties.width / perpendicular.length());\n    return {\n      corners: [\n        this.properties.start.add(halfWidth),\n        this.properties.start.minus(halfWidth),\n        this.properties.end.minus(halfWidth),\n        this.properties.end.add(halfWidth)\n      ]\n    }\n  }\n\n  rectRectIntersection(rect) {\n    // this must be a rectangle or line to call this function\n    if (this.type === Collision.Type.CIRCLE) return;\n    // other must be a rectangle or line to call this function\n    if (rect.type === Collision.Type.CIRCLE) return;\n\n    const cornersA = this.type === Collision.Type.LINE ? this.rectPropsFromLine().corners : this.properties.corners;\n    const cornersB = rect.type === Collision.Type.LINE ? rect.rectPropsFromLine().corners : rect.properties.corners;\n    const axes = [\n      cornersA[3].minus(cornersA[0]),\n      cornersA[3].minus(cornersA[2]),\n      cornersB[0].minus(cornersB[1]),\n      cornersB[0].minus(cornersB[3])\n    ]\n\n    // find axes with overlaps\n    const overlaps = [];\n    for (const axis of axes) {\n      const projectionsA = cornersA.map(corner => corner.project(axis));\n      const projectionsB = cornersB.map(corner => corner.project(axis));\n\n      const positionsA = projectionsA.map(vector => vector.dot(axis));\n      const positionsB = projectionsB.map(vector => vector.dot(axis));\n\n      const [maxA, maxA_i] = util.maxAndIndex(positionsA);\n      const [minA, minA_i] = util.minAndIndex(positionsA);\n      const [maxB, maxB_i] = util.maxAndIndex(positionsB);\n      const [minB, minB_i] = util.minAndIndex(positionsB);\n\n      // if the rectangles don't overlaps on at least one axis, they don't collide\n      if (maxA < minB || maxB < minA) {\n        return false;\n      } else {\n        // calculate the overlap between the rectangles on this axis\n        const maxAminB = projectionsA[maxA_i].minus(projectionsB[minB_i]);\n        const maxBminA = projectionsB[maxB_i].minus(projectionsA[minA_i]);\n        if (maxAminB.length2() < maxBminA.length2()) overlaps.push(maxAminB);\n        // the rectangles overlap on the other side, so invert the vector\n        else overlaps.push(maxBminA.scalarMultiply(-1));\n      }\n    }\n\n    // find axis with the least overlap\n    let minVector = overlaps[0];\n    overlaps.forEach(vector => {\n      if (vector.length2() < minVector.length2()) minVector = vector;\n    });\n\n    // return displacement required to remove the rectangle from the collision\n    return minVector.scalarMultiply(-1);\n  }\n}\n","export default class Road {\n  constructor(start, end, segment) {\n    this.start = start;\n    this.end = end;\n    this.segment = segment;\n  }\n\n  setStart(start) {\n    this.start = start;\n    this.segment.collider.updateCollisionProperties({ start: start });\n    this.segment.roadRevision++;\n  }\n\n  setEnd(end) {\n    this.end = end;\n    this.segment.collider.updateCollisionProperties({ end: end });\n    this.segment.roadRevision++;\n  }\n}\n","import Segment from './Segment.js';\nimport Point from './Point.js';\n\nexport default class SegmentFactory {\n  static fromExisting(segment, time, road, params) {\n    time = time || segment.time;\n    road = road || segment.road;\n    params = params || segment.params;\n    return new Segment(road.start, road.end, time, params);\n  }\n\n  static usingDirection(start, direction = 90, length = DEFAULT_SEGMENT_LENGTH, time = 0, params = {}) {\n    // convert direction to radians\n    direction *= Math.PI / 180;\n    const x = start.x + length * Math.sin(direction);\n    const y = start.y + length * Math.cos(direction);\n    return new Segment(start, new Point(x, y), time, params);\n  }\n}\n","import { DEFAULT_SEGMENT_WIDTH,\n         HIGHWAY_SEGMENT_WIDTH,\n         MIN_SPEED_PROPORTION } from './../config.js';\n\nimport Collision from './Collision.js';\nimport Road from './Road.js';\nimport Point from './Point.js';\nimport SegmentFactory from './SegmentFactory.js';\n\nexport default class Segment {\n  static get End() {\n    return { START: 'start', END: 'end' };\n  }\n\n  constructor(start, end, time = 0, params = {}) {\n    this.start = start;\n    this.end = end;\n    this.time = time;\n    this.params = params;\n\n    this.width = params.highway ? HIGHWAY_SEGMENT_WIDTH : DEFAULT_SEGMENT_WIDTH;\n    this.collider = new Collision(this, Collision.Type.LINE, {start: start, end: end, width: this.width});\n\n    this.roadRevision = 0;\n    this.directionRevision = undefined;\n    this.lengthRevision = undefined;\n\n    this.cachedDirection = undefined;\n    this.cachedLength = undefined;\n\n    this.road = new Road(start, end, this);\n\n    // time-step delay before this road is evaluated\n    this.time = time;\n    // meta-information relevant to global goals\n    this.params = params;\n\n    this.links = { backwards: [], forwards: [] };\n\n    this.users = [];\n    this.maxSpeed = params.highway ? 1200 : 800;\n    this.capacity = params.highway ? 12 : 6;\n  }\n\n  currentSpeed() {\n    return Math.min(MIN_SPEED_PROPORTION, 1 - Math.max(0, this.users.length - 1) / this.capacity) * this.maxSpeed;\n  }\n\n  direction() {\n    if (this.directionRevision !== this.roadRevision) {\n      this.directionRevision = this.roadRevision;\n      const vertical = new Point(0, 1);\n      const vector = this.road.end.minus(this.road.start);\n      const cross = vertical.cross(vector);\n      // we want the opposite of the cross sign\n      const sign = cross > 0 ? -1 : cross < 0 ? 1 : 0;\n      this.cachedDirection = sign * vertical.angle(vector);\n    }\n    return this.cachedDirection;\n  }\n\n  length() {\n    if (this.lengthRevision !== this.roadRevision) {\n      this.lengthRevision = this.roadRevision;\n      this.cachedLength = this.road.start.distance(this.road.end);\n    }\n    return this.cachedLength;\n  }\n\n  startIsBackwards() {\n    if (this.links.backwards.length) {\n      return this.links.backwards[0].road.start.equals(this.road.start) ||\n             this.links.backwards[0].road.end.equals(this.road.start);\n    } else {\n      return this.links.forwards[0].road.start.equals(this.road.end) ||\n             this.links.forwards[0].road.end.equals(this.road.end);\n    }\n  }\n\n  cost() {\n    return this.length() / this.currentSpeed();\n  }\n\n  costTo(other, fromFraction) {\n    const segmentEnd = this.endContaining(other);\n    const fraction = fromFraction ? (segmentEnd === Segment.End.START ? fromFraction : fromFraction) : 0.5;\n    return this.cost() * fraction;\n  }\n\n  neighbors() {\n    return this.links.forwards.concat(this.links.backwards);\n  }\n\n  endContaining(segment) {\n    const backwards = this.startIsBackwards();\n    if (this.links.backwards.includes(segment)) {\n      return backwards ? Segment.End.START : Segment.End.END;\n    } else if (this.links.forwards.includes(segment)) {\n      return backwards ? Segment.End.END : Segment.End.START;\n    } else {\n      return undefined;\n    }\n  }\n\n  linksForEndContaining(segment) {\n    if (this.links.backwards.includes(segment)) {\n      return this.links.backwards;\n    } else if (this.links.forwards.includes(segment)) {\n      return this.links.forwards;\n    } else {\n      return undefined;\n    }\n  }\n\n  split(point, segment, segments, tree) {\n    const backwards = this.startIsBackwards();\n\n    const splitPart = SegmentFactory.fromExisting(this);\n    splitPart.addSegment(segments, tree);\n    splitPart.road.setEnd(point);\n    this.road.setStart(point);\n\n    splitPart.links.backwards = this.links.backwards.slice(0);\n    splitPart.links.forwards = this.links.forwards.slice(0);\n\n    // determine which links correspond to which end of the split segment\n    const firstSplit = backwards ? splitPart : this;\n    const secondSplit = backwards ? this : splitPart;\n    const fixLinks = backwards ? splitPart.links.backwards : splitPart.links.forwards;\n\n    fixLinks.forEach(link => {\n      let index = link.links.backwards.indexOf(this);\n      if (index !== -1) {\n        link.links.backwards[index] = splitPart;\n      } else {\n        index = link.links.forwards.indexOf(this);\n        link.links.forwards[index] = splitPart;\n      }\n    });\n\n    firstSplit.links.forwards = [segment, secondSplit];\n    secondSplit.links.backwards = [segment, firstSplit];\n\n    segment.links.forwards.push(firstSplit);\n    segment.links.forwards.push(secondSplit);\n  }\n\n  addSegment(segments, tree) {\n    segments.push(this);\n    tree.insert(this.collider.limits());\n  }\n}\n","export default class QuadTree {\n  constructor(bounds, maxObjects = 10, maxLevels = 4, level = 0) {\n    this.bounds = bounds;\n    this.maxObjects = maxObjects;\n    this.maxLevels = maxLevels;\n    this.level = level;\n\n    this.objects = [];\n    this.nodes = [];\n  }\n\n  subdivide() {\n    const width = Math.round(this.bounds.width / 2);\n    const height = Math.round(this.bounds.height / 2);\n    const x = Math.round(this.bounds.x);\n    const y = Math.round(this.bounds.y);\n\n    // top right node\n    this.nodes[0] = new QuadTree({\n      x: x + width,\n      y: y,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n\n    // top left node\n    this.nodes[1] = new QuadTree({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n\n    // bottom left node\n    this.nodes[2] = new QuadTree({\n      x: x,\n      y: y + height,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n\n    // bottom right node\n    this.nodes[3] = new QuadTree({\n      x: x + width,\n      y: y + height,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n  }\n\n  // determines which node the given rectangle is in\n  getIndex(rect) {\n    let index = -1;\n    const midpointX = this.bounds.x + this.bounds.width / 2;\n    const midpointY = this.bounds.y + this.bounds.height / 2;\n\n    const top = rect.y < midpointY && rect.y + rect.height < midpointY;\n    const bottom = rect.y > midpointY;\n\n    if (rect.x < midpointX && rect.x + rect.width < midpointX) {\n      index = top ? 1 : bottom ? 2 : index;\n    } else if (rect.x > midpointX) {\n      index = top ? 0 : bottom ? 3 : index;\n    }\n    return index;\n  }\n\n  insert(rect) {\n    if (this.nodes.length) {\n      const i = this.getIndex(rect);\n      if (i !== -1) return this.nodes[i].insert(rect);\n    }\n\n    this.objects.push(rect);\n\n    if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {\n      if (this.nodes.length === 0) this.subdivide();\n\n      let i = 0;\n      while (i < this.objects.length) {\n        const index = this.getIndex(this.objects[i]);\n        if (index !== -1) this.nodes[index].insert(this.objects.splice(i, 1)[0]);\n        else i++;\n      }\n    }\n  }\n\n  // returns all objects that collide with the given object\n  retrieve(rect) {\n    const index = this.getIndex(rect);\n    let objects = this.objects;\n\n    if (this.nodes.length) {\n      if (index !== -1) {\n        objects = objects.concat(this.nodes[index].retrieve(rect));\n      } else {\n        // check against all subnodes\n        for (const node of this.nodes) {\n          objects = objects.concat(node.retrieve(rect));\n        }\n      }\n    }\n    return objects;\n  }\n\n  clear() {\n    this.objects = [];\n    for (const node of this.nodes) {\n      node.clear();\n    }\n  }\n}\n","import { ROAD_SNAP_DISTANCE,\n         MINIMUM_INTERSECTION_DEVIATION,\n         DEFAULT_SEGMENT_LENGTH,\n         HIGHWAY_SEGMENT_LENGTH,\n         NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY,\n         BRANCH_ANGLE, FORWARD_ANGLE,\n         HIGHWAY_BRANCH_POPULATION_THRESHOLD,\n         NORMAL_BRANCH_POPULATION_THRESHOLD,\n         HIGHWAY_BRANCH_PROBABILITY,\n         DEFAULT_BRANCH_PROBABILITY,\n         QUADTREE_PARAMS, QUADTREE_MAX_OBJECTS, QUADTREE_MAX_LEVELS,\n         SEGMENT_COUNT_LIMIT } from './config.js';\nimport * as util from './util.js';\nimport * as noise from './../third_party/perlin.js';\n\nimport Point from './classes/Point.js';\nimport Heatmap from './classes/Heatmap.js';\nimport Segment from './classes/Segment.js';\nimport QuadTree from './classes/QuadTree.js';\nimport SegmentFactory from './classes/SegmentFactory.js';\n\nfunction doRoadSegmentsIntersect(a, b) {\n  let intersectX = false;\n  for (let i = a.start.x; i < a.end.x; i++) {\n    if (i > b.start.x && i < b.end.x) {\n      intersectX = true;\n      break;\n    }\n  }\n  let intersectY = false;\n  for (let i = a.start.y; i < a.end.y; i++) {\n    if (i > b.start.y && i < b.end.y) {\n      intersectY = true;\n      break;\n    }\n  }\n  return intersectX && intersectY;\n}\n\nfunction localConstraints(segment, segments, tree, debugData) {\n  const action = { priority: 0, params: {} };\n\n  const matches = tree.retrieve(segment.collider.limits());\n  for (const match of matches) {\n    const other = match.object;\n\n    // intersection check\n    if (action.priority < 5) {\n      const intersection = doRoadSegmentsIntersect(segment.road, other.road);\n      if (intersection) {\n        if (!action.params.time || intersection.time < actions.params.time) {\n          action.params.time = intersection.time;\n\n          action.priority = 4;\n          return action.function = () => {\n            // if intersecting lines are too similar don't continue\n            if (util.minDegreeDifference(other.direction(), segment.direction()) < MINIMUM_INTERSECTION_DEVIATION) {\n              return false;\n            }\n\n            other.split(intersection, segment, segments, tree);\n            segment.road.end = intersection;\n            segmentEnd.params.severed = true;\n\n            if (debugData) {\n              debugData.intersections = debugData.intersections || [];\n              debugData.intersections.push(new Point(intersection.x, intersection.y));\n            }\n\n            return true;\n          }\n        }\n      }\n    }\n\n    // snap to crossing within radius check\n    if (action.priority < 4) {\n      // current segment's start must have been checked to have been created\n      // other segment's start must have a corresponding end\n      if (segment.road.end.distance(other.road.end) <= ROAD_SNAP_DISTANCE) {\n        const point = other.road.end;\n        action.priority = 3;\n        return action.function = () => {\n          segment.road.end = point;\n          segment.params.severed = true;\n\n          // update other's links corresponding to other.road.end\n          const links = other.startIsBackwards() ? other.links.forwards : other.links.backwards;\n\n          // check for duplicate lines, don't add if it exists\n          const duplicates = links.some(link => {\n            return (link.road.start.equals(segment.road.end) && link.road.end.equals(segment.road.start)) ||\n              (link.road.start.equals(segment.road.start) && link.road.end.equals(segment.road.end));\n          });\n          if (duplicates) return false;\n\n          links.forEach(link => {\n            // pick links of remaining segments at junction corresponding to other.road.end\n            link.linksForEndContaining(other).push(segment);\n\n            // add junction segments to snapped segment\n            segment.links.forwards.push(link);\n          });\n\n          links.push(segment);\n          segment.links.forwards.push(other);\n\n          if (debugData) {\n            debugData.snaps = debugData.snaps || [];\n            debugData.snaps.push(new Point(point.x, point.y));\n          }\n\n          return true;\n        }\n      }\n    }\n\n    // intersection with radius check\n    if (action.priority < 3) {\n      const { distance2, pointOnLine, lineProj2, length2 } =\n        segment.road.end.distanceToLine(other.road.start, other.road.end);\n      if (distance2 < ROAD_SNAP_DISTANCE * ROAD_SNAP_DISTANCE && lineProj2 >= 0 && lineProj2 <= length2) {\n        const point = pointOnLine;\n        action.priority = 2;\n        return action.function = () => {\n          segment.road.end = point;\n          segment.params.severed = true;\n\n          // if intersecting lines are too similar don't continue\n          if (util.minDegreeDifference(other.direction(), segment.direction() < MINIMUM_INTERSECTION_DEVIATION)) {\n            return false;\n          }\n\n          other.split(point, segment, segments, tree);\n\n          if (debugData) {\n            debugData.intersectionsRadius = debugData.intersectionsRadius || [];\n            debugData.intersectionsRadius.push(new Point(point.x, point.y));\n          }\n\n          return true;\n        }\n      }\n    }\n  }\n\n  if (action.function) return action.function();\n  return true;\n}\n\nfunction globalGoals(previousSegment) {\n  const newBranches = [];\n  if (!previousSegment.params.severed) {\n    const template = (direction, length, time, params) => SegmentFactory.usingDirection(previousSegment.road.end, direction, length, time, params);\n\n    // used for highways or going straight on a normal branch\n    const templateContinue = (direction) => template(direction, previousSegment.length(), 0, previousSegment.params);\n\n    // not using params, i.e. not highways\n    const templateBranch = (direction) => template(direction, DEFAULT_SEGMENT_LENGTH, previousSegment.params.highway ? NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY : 0);\n\n    const continueStraight = templateContinue(previousSegment.direction());\n    const straightPop = Heatmap.popOnRoad(continueStraight.road);\n\n    if (previousSegment.params.highway) {\n      const randomStraight = templateContinue(previousSegment.direction() + util.randomAngle(FORWARD_ANGLE));\n      const randomPop = Heatmap.popOnRoad(randomStraight.road);\n      const roadPop = randomPop > straightPop ? randomPop : straightPop;\n      newBranches.push(randomPop > straightPop ? randomStraight : continueStraight);\n\n      if (roadPop > HIGHWAY_BRANCH_POPULATION_THRESHOLD) {\n        if (Math.random() < HIGHWAY_BRANCH_PROBABILITY) {\n          const leftHighwayBranch = templateContinue(previousSegment.direction() - 90 + util.randomAngle(BRANCH_ANGLE));\n          newBranches.push(leftHighwayBranch);\n        } else if (Math.random() < HIGHWAY_BRANCH_PROBABILITY) {\n          const rightHighwayBranch = templateContinue(previousSegment.direction() + 90 + util.randomAngle(BRANCH_ANGLE));\n          newBranches.push(rightHighwayBranch);\n        }\n      }\n    } else if (straightPop > NORMAL_BRANCH_POPULATION_THRESHOLD) {\n      newBranches.push(continueStraight);\n    }\n\n    if (straightPop > NORMAL_BRANCH_POPULATION_THRESHOLD) {\n      if (Math.random() < DEFAULT_BRANCH_PROBABILITY) {\n        const leftBranch = templateBranch(previousSegment.direction() - 90 + util.randomAngle(BRANCH_ANGLE));\n        newBranches.push(leftBranch);\n      } else if (Math.random() < DEFAULT_BRANCH_PROBABILITY) {\n        const rightBranch = templateBranch(previousSegment.direction() + 90 + util.randomAngle(BRANCH_ANGLE));\n        newBranches.push(rightBranch);\n      }\n    }\n  }\n\n  for (const branch of newBranches) {\n    branch.setUpBranchLinks = () => {\n      // set up links between each current branch and each existing branch stemming from the previous segment\n      previousSegment.links.forwards.forEach(link => {\n        branch.links.backwards.push(link);\n        link.linksForEndContaining(previousSegment).push(branch);\n      });\n\n      previousSegment.links.forwards.push(branch);\n      branch.links.backwards.push(previousSegment);\n    }\n  }\n\n  return newBranches;\n}\n\nexport function generate(seed) {\n  const debugData = {};\n  // TODO: change this to use seed data from user input\n  noise.seed(Math.random());\n\n  const queue = [];\n  const rootSegment = new Segment(seed, new Point(seed.x + HIGHWAY_SEGMENT_LENGTH, seed.y), 0, { highway: true });\n  const oppositeDirection = SegmentFactory.fromExisting(rootSegment);\n  const newEnd = new Point(rootSegment.road.start.x - HIGHWAY_SEGMENT_LENGTH, oppositeDirection.road.end.y);\n  oppositeDirection.road.end = newEnd;\n  oppositeDirection.links.backwards.push(rootSegment);\n  rootSegment.links.backwards.push(oppositeDirection);\n  queue.push(rootSegment);\n  queue.push(oppositeDirection);\n\n  const segments = [];\n  // TODO: bounds should be the bounding box of the polygon\n  // maxObjects should vary based on the type of city area\n  const treeParams = { x: seed.x, y: seed.y, width: HIGHWAY_SEGMENT_LENGTH, height: HIGHWAY_SEGMENT_LENGTH };\n  const tree = new QuadTree(treeParams, QUADTREE_MAX_OBJECTS, QUADTREE_MAX_LEVELS);\n\n  while (queue.length && segments.length < SEGMENT_COUNT_LIMIT) {\n    // pop smallest r(ti, ri, qi) from Q (i.e. smallest time)\n    let minT = undefined;\n    let minT_i = 0;\n    queue.forEach((segment, i) => {\n      if (!minT || segment.time < minT) {\n        minT = segment.time;\n        minT_i = i;\n      }\n    });\n\n    const minSegment = queue.splice(minT_i, 1)[0];\n    const accepted = localConstraints(minSegment, segments, tree, debugData);\n    if (accepted) {\n      if (minSegment.setUpBranchLinks) {\n        minSegment.setUpBranchLinks();\n      }\n      minSegment.addSegment(segments, tree);\n      globalGoals(minSegment).forEach(segment => {\n        segment.time += minSegment.time + 1;\n        queue.push(segment);\n      });\n    }\n  }\n\n  let id = 0;\n  for (const segment of segments) {\n    segment.id = id++;\n  }\n\n  return segments;\n}\n","export function drawSegment(context, segment) {\n  context.strokeStyle = segment.params.highway ? '#FF0000' : '#000000';\n  context.lineWidth = segment.width;\n\n  context.beginPath();\n  context.moveTo(segment.road.start.x, segment.road.start.y);\n  context.lineTo(segment.road.end.x, segment.road.end.y);\n  context.closePath();\n  context.stroke();\n}\n","import Point from './classes/Point.js';\nimport * as generator from './generation.js';\nimport * as draw from './draw.js';\n\nconst canvas = document.getElementById('canvas');\nconst context = canvas.getContext('2d');\ncanvas.width = window.innerWidth * 0.85; // canvas is 85vw\ncanvas.height = window.innerHeight;\n\ndocument.getElementById('generate').addEventListener('click', event => {\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  // seed is the point at which the highway starts\n  const seed = new Point(canvas.width / 2, canvas.height / 2);\n  const segments = generator.generate(seed);\n  segments.forEach(segment => draw.drawSegment(context, segment));\n});\n"]}