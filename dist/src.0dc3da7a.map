{"version":3,"sources":["src/classes/Point.js","src/classes/Circle.js","src/classes/Polygon.js","src/interaction.js","src/config.js","src/util.js","src/perlin.js","src/classes/Heatmap.js","src/classes/Collision.js","src/classes/Road.js","src/classes/SegmentFactory.js","src/classes/Segment.js","src/classes/QuadTree.js","src/generation.js","src/draw.js","src/index.js"],"names":["EPSILON","Point","x","y","Math","sqrt","length2","other","v","minus","length","diff","s","radians","acos","dot","PI","scalarMultiply","start","end","toStart","line","projected","project","result","add","sign","distance2","pointOnLine","lineProj2","Circle","d","r","Polygon","edges","color","options","minX","canvas","width","maxX","minY","height","maxY","point","boundaries","debugMode","context","lineWidth","strokeStyle","strokeRect","currentSize","points","scale","offsetX","min","random","offsetY","push","round","fillStyle","fillRect","edgesMap","forEach","lastCrossing","intersections","i","includes","SUPPORTS_POINTER","window","SUPPORTS_TOUCH","drawing","xClicks","yClicks","dragClicks","currentBrush","document","querySelector","classList","lastBrush","parseInt","getElementById","value","brushes","Array","prototype","slice","call","getElementsByClassName","brushColors","skyscrapers","residential","commercial","water","parks","clickData","innerPoints","polygons","polygonIndex","render","beginPath","moveTo","lineTo","closePath","stroke","addClick","dragging","clearActiveBrushes","brush","remove","onEventDown","event","detectEdges","mouseX","pageX","offsetLeft","mouseY","pageY","offsetTop","onEventMove","onEventUp","circle","n","rgb","split","currX","getImageData","data","addEdge","prev","neighbors","prevIndex","findIndex","p","splice","shift","firstNot","pixel","abs","firstSame","next","interpretInput","polygon","boundingBox","scatterPoints","init","lineJoin","brushSize","currentBrushSize","addEventListener","innerWidth","innerHeight","innerText","target","checked","style","display","disabled","DEFAULT_SEGMENT_WIDTH","HIGHWAY_SEGMENT_WIDTH","DEFAULT_SEGMENT_LENGTH","HIGHWAY_SEGMENT_LENGTH","SEGMENT_COUNT_LIMIT","BRANCH_ANGLE","FORWARD_ANGLE","HIGHWAY_BRANCH_PROBABILITY","DEFAULT_BRANCH_PROBABILITY","HIGHWAY_BRANCH_POPULATION_THRESHOLD","NORMAL_BRANCH_POPULATION_THRESHOLD","ROAD_SNAP_DISTANCE","MINIMUM_INTERSECTION_DEVIATION","MIN_SPEED_PROPORTION","NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY","QUADTREE_MAX_OBJECTS","QUADTREE_MAX_LEVELS","randomRange","max","minDegreeDifference","a","b","randomAngle","limit","nonUniformNorm","pow","minAndIndex","array","min_i","entry","maxAndIndex","max_i","Grad","z","grad3","perm","gradP","seed","floor","F2","G2","F3","G3","simplex2","xin","yin","n0","j","t","x0","y0","i1","j1","x1","y1","x2","y2","gi0","gi1","gi2","t0","t1","t2","dot2","Heatmap","one","noise","two","three","road","populationAt","Collision","object","type","properties","collisionRevision","limitsRevision","undefined","cachedLimits","RECT","LINE","CIRCLE","prop","axis","minCorner","corners","corner","maxCorner","Type","center","radius","limits","otherLimits","rectCircleCollision","rectRectIntersection","rectPropsFromLine","distanceToLine","axes","center0","center2","projections","dots","direction","perpendicular","halfWidth","rect","cornersA","cornersB","overlaps","projectionsA","map","projectionsB","positionsA","vector","positionsB","util","maxA","maxA_i","minA","minA_i","maxB","maxB_i","minB","minB_i","maxAminB","maxBminA","minVector","Road","segment","collider","updateCollisionProperties","roadRevision","starts","numerator","cross","denominator","u","intersect","SegmentFactory","time","params","Segment","sin","cos","highway","links","backwards","forwards","users","maxSpeed","capacity","START","END","directionRevision","vertical","cachedDirection","angle","lengthRevision","cachedLength","distance","equals","currentSpeed","fromFraction","segmentEnd","endContaining","fraction","End","cost","concat","startIsBackwards","segments","tree","splitPart","fromExisting","addSegment","setEnd","setStart","firstSplit","secondSplit","link","index","indexOf","insert","QuadTree","bounds","maxObjects","maxLevels","level","objects","nodes","midpointX","midpointY","top","bottom","getIndex","subdivide","retrieve","node","clear","localConstraints","debugData","action","priority","matches","match","intersection","intersects","actions","severed","duplicates","some","linksForEndContaining","snaps","intersectionsRadius","globalGoals","previousSegment","newBranches","template","usingDirection","templateContinue","templateBranch","continueStraight","straightPop","popOnRoad","randomStraight","randomPop","roadPop","leftHighwayBranch","rightHighwayBranch","leftBranch","rightBranch","branch","setUpBranchLinks","generate","queue","rootSegment","oppositeDirection","newEnd","treeParams","minT","minT_i","minSegment","id","drawSegment","getContext","interaction","clearRect","generator","draw"],"mappings":";AA2EG,aAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,SAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,WAAA,EAAA,aAAA,EAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,EAAA,EAAA,IAAA,IAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,GAAA,EAAA,EAAA,UAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EA3EH,IAAMA,EAAU,KAEKC,EAyElB,WAxEWC,SAAAA,EAAAA,EAAGC,GAAG,EAAA,KAAA,GACXD,KAAAA,EAAIA,EACJC,KAAAA,EAAIA,EAsEV,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,SAnEQ,MAAA,WACAC,OAAAA,KAAKC,KAAK,KAAKC,aAkEvB,CAAA,IAAA,UA/DS,MAAA,WACD,OAAA,KAAKJ,EAAI,KAAKA,EAAI,KAAKC,EAAI,KAAKA,IA8DxC,CAAA,IAAA,WA3DQI,MAAAA,SAAAA,GAEAC,OADGD,EAAME,MAAM,MACbC,WAyDV,CAAA,IAAA,YAtDSH,MAAAA,SAAAA,GAEDC,OADGD,EAAME,MAAM,MACbH,YAoDV,CAAA,IAAA,SAjDMC,MAAAA,SAAAA,GAEEI,OADM,KAAKF,MAAMF,GACZD,UAAYN,IA+CzB,CAAA,IAAA,iBA5CcY,MAAAA,SAAAA,GACN,OAAA,IAAIX,EAAM,KAAKC,EAAIU,EAAG,KAAKT,EAAIS,KA2CvC,CAAA,IAAA,MAxCGL,MAAAA,SAAAA,GACK,OAAA,IAAIN,EAAM,KAAKC,EAAIK,EAAML,EAAG,KAAKC,EAAII,EAAMJ,KAuCnD,CAAA,IAAA,QApCKI,MAAAA,SAAAA,GACG,OAAA,IAAIN,EAAM,KAAKC,EAAIK,EAAML,EAAG,KAAKC,EAAII,EAAMJ,KAmCnD,CAAA,IAAA,MAhCGI,MAAAA,SAAAA,GACK,OAAA,KAAKL,EAAIK,EAAML,EAAI,KAAKC,EAAII,EAAMJ,IA+B1C,CAAA,IAAA,QA5BKI,MAAAA,SAAAA,GACG,OAAA,KAAKL,EAAIK,EAAMJ,EAAI,KAAKA,EAAII,EAAML,IA2B1C,CAAA,IAAA,QAxBKK,MAAAA,SAAAA,GAEGM,OAAU,IADDT,KAAKU,KAAK,KAAKC,IAAIR,IAAU,KAAKG,SAAWH,EAAMG,WAC5CN,KAAKY,KAsB7B,CAAA,IAAA,UAnBOT,MAAAA,SAAAA,GACCA,OAAAA,EAAMU,eAAe,KAAKF,IAAIR,GAASA,EAAMD,aAkBrD,CAAA,IAAA,iBAfcY,MAAAA,SAAAA,EAAOC,GACdC,IAAAA,EAAU,KAAKX,MAAMS,GACrBG,EAAOF,EAAIV,MAAMS,GACjBI,EAAYF,EAAQG,QAAQF,GAC5BG,EAASN,EAAMO,IAAIH,GACnBP,EAAMK,EAAQL,IAAIM,GAClBK,EAAOX,EAAM,GAAK,EAAIA,EAAM,EAAI,EAAI,EAEnC,MAAA,CACLY,UAAWH,EAAOG,UAAU,MAC5BC,YAAaJ,EAEbK,UAAYH,EAAOJ,EAAUhB,UAC7BA,QAASe,EAAKf,eAEjB,EAAA,GAAA,QAAA,QAAA;;ACtEA,aAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EALkBwB,IAAAA,EACnB,SAAY5B,EAAAA,EAAGC,EAAG4B,GAAG,EAAA,KAAA,GACd7B,KAAAA,EAAIA,EACJC,KAAAA,EAAIA,EACJ6B,KAAAA,EAAID,EAAI,GACd,QAAA,QAAA;;AC0FA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EA/FH,IAAA,EAAA,EAAA,QAAA,eA+FG,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,SAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,WAAA,EAAA,aAAA,EAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,EAAA,EAAA,IAAA,IAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,GAAA,EAAA,EAAA,UAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EA7FkBE,IAAAA,EA6FlB,WA5FWC,SAAAA,EAAAA,EAAOC,GAAO,EAAA,KAAA,GACnBD,KAAAA,MAAQA,EACRC,KAAAA,MAAQA,EA0Fd,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,cAtFWC,MAAAA,SAAAA,GACNC,IAAAA,EAAOD,EAAQE,OAAOC,MAAOC,EAAO,EACpCC,EAAOL,EAAQE,OAAOI,OAAQC,EAAO,EAFtB,GAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IAGC,IAAA,IAAY,EAAZ,EAAA,KAAKT,MAAO,OAAA,cAAA,GAAA,EAAA,EAAA,QAAA,MAAA,GAAA,EAAA,CAArBU,IAAAA,EAAqB,EAAA,MAC9BP,EAAOO,EAAM1C,EAAImC,EAAOO,EAAM1C,EAAImC,EAClCG,EAAOI,EAAM1C,EAAIsC,EAAOI,EAAM1C,EAAIsC,EAClCC,EAAOG,EAAMzC,EAAIsC,EAAOG,EAAMzC,EAAIsC,EAClCE,EAAOC,EAAMzC,EAAIwC,EAAOC,EAAMzC,EAAIwC,GAPjB,MAAA,GAAA,GAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,MAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,MAAA,GASdE,KAAAA,WAAa,CAChB,IAAI5C,EAAJ,QAAUoC,EAAMI,GACZxC,IAAAA,EAAJ,QAAUuC,EAAMC,GACZxC,IAAAA,EAAJ,QAAUuC,EAAMG,GACZ1C,IAAAA,EAAJ,QAAUoC,EAAMM,IAIdP,EAAQU,YACVV,EAAQW,QAAQC,UAAY,EAC5BZ,EAAQW,QAAQE,YAAc,UAC9Bb,EAAQW,QAAQG,WAAWb,EAAMI,EAAMD,EAAOH,EAAMM,EAAOF,GAC3DL,EAAQW,QAAQC,UAAYZ,EAAQe,eAiEvC,CAAA,IAAA,gBA5Daf,MAAAA,SAAAA,GAAS,IAAA,EAAA,KAEjB,GAAe,UAAf,KAAKD,OAAoC,UAAf,KAAKA,MAA/B,CAMC,IAJCiB,IAAAA,EAAS,GAETf,EAAO,KAAKQ,WAAW,GAAG3C,EAAGuC,EAAO,KAAKI,WAAW,GAAG1C,EACvDqC,EAAO,KAAKK,WAAW,GAAG3C,EAAGyC,EAAO,KAAKE,WAAW,GAAG1C,EACpDD,EAAImC,EAAMnC,EAAIsC,EAAMtC,GAAGkC,EAAQiB,MACjC,IAAA,IAAIlD,EAAIsC,EAAMtC,EAAIwC,EAAMxC,GAAGiC,EAAQiB,MAAO,CAEvCC,IAAAA,EAAUlD,KAAKmD,IAAIrD,EAAIE,KAAKoD,SAAWpB,EAAQiB,MAAOb,GACtDiB,EAAUrD,KAAKmD,IAAIpD,EAAIC,KAAKoD,SAAWpB,EAAQiB,MAAOV,GAC5DS,EAAOM,KAAK,IAAIzD,EAAJ,QAAUG,KAAKuD,MAAML,GAAUlD,KAAKuD,MAAMF,KAKtDrB,GAAAA,EAAQU,UACUM,IAAAA,IAAAA,EAAAA,EAAAA,EAAAA,EAAQ,OAAA,IAAA,CAAjBR,IAAAA,EAASQ,EAAf,GACHhB,EAAQW,QAAQa,UAAY,OAC5BxB,EAAQW,QAAQc,SAASjB,EAAM1C,EAAG0C,EAAMzC,EAAG,EAAG,GAK5C2D,IAAAA,EAAW,GA4Bb1B,GA3BCF,KAAAA,MAAM6B,QAAQ,SAAAnB,GACbkB,EAASlB,EAAMzC,GACjB2D,EAASlB,EAAMzC,GAAGuD,KAAKd,EAAM1C,GAE7B4D,EAASlB,EAAMzC,GAAK,CAACyC,EAAM1C,KAM1BkD,KAAAA,OAAS,GACdA,EAAOW,QAAQ,SAAAnB,GAIR,IAFDoB,IAAAA,EAAe,EACfC,EAAgB,EACXC,EAAItB,EAAM1C,EAAGgE,EAAI1B,EAAO,EAAG0B,IAC9BJ,EAASlB,EAAMzC,GAAGgE,SAASD,KAEzBA,EAAIF,EAAe,GAAGC,IAC1BD,EAAeE,GAIfD,EAAgB,GAAM,GAAG,EAAKb,OAAOM,KAAKd,KAI5CR,EAAQU,UAAW,CAAA,IAAA,GAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IACD,IAAA,IAAa,EAAb,EAAA,KAAKM,OAAQ,OAAA,cAAA,GAAA,EAAA,EAAA,QAAA,MAAA,GAAA,EAAA,CAAtBR,IAAAA,EAAsB,EAAA,MAC/BR,EAAQW,QAAQa,UAAY,UAC5BxB,EAAQW,QAAQc,SAASjB,EAAM1C,EAAG0C,EAAMzC,EAAG,EAAG,IAH3B,MAAA,GAAA,GAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,MAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,MAAA,UAMxB,EAAA,GAAA,QAAA,QAAA;;ACwJF,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,KAAA,EAvPD,IAAA,EAAA,EAAA,QAAA,uBACA,EAAA,EAAA,QAAA,wBACA,EAAA,EAAA,QAAA,yBAqPC,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAnPD,IAAMiE,EAAmB,iBAAkBC,OACrCC,EAAiB,iBAAkBD,OACnCjC,EAAU,CACdmC,SAAS,EAETC,QAAS,GACTC,QAAS,GACTC,WAAY,GAEZC,aAAcC,SAASC,cAAc,WAAWC,UAAU,GAC1DC,UAAWH,SAASC,cAAc,WAAWC,UAAU,GACvD3B,YAAa6B,SAASJ,SAASK,eAAe,cAAcC,OAC5DC,QAASC,MAAMC,UAAUC,MAAMC,KAAKX,SAASY,uBAAuB,UACpEC,YAAa,CACXC,YAAa,mBACbC,YAAa,mBACbC,WAAY,mBACZC,MAAO,mBACPC,MAAO,oBAGTC,UAAW,CAAEL,YAAa,GAAIC,YAAa,GAAIC,WAAY,GAAIC,MAAO,GAAIC,MAAO,IACjFE,YAAa,CAAEN,YAAa,GAAIC,YAAa,GAAIC,WAAY,GAAIC,MAAO,GAAIC,MAAO,IACnFG,SAAU,GACVC,aAAc,EAEdpD,WAAW,EACXO,MAAO,IAKT,SAAS8C,IACF,IAAA,IAAIjC,EAAI,EAAGA,EAAI9B,EAAQoC,QAAQ9D,OAAQwD,IAC1C9B,EAAQW,QAAQE,YAAcb,EAAQqD,YAAYrD,EAAQuC,cAC1DvC,EAAQW,QAAQC,UAAYZ,EAAQe,YAEpCf,EAAQW,QAAQqD,YACZhE,EAAQsC,WAAWR,IAAMA,EAAI,EAC/B9B,EAAQW,QAAQsD,OAAOjE,EAAQoC,QAAQN,EAAI,GAAI9B,EAAQqC,QAAQP,EAAI,IAEnE9B,EAAQW,QAAQsD,OAAOjE,EAAQoC,QAAQN,GAAK,EAAG9B,EAAQqC,QAAQP,GAAK,GAGtE9B,EAAQW,QAAQuD,OAAOlE,EAAQoC,QAAQN,GAAI9B,EAAQqC,QAAQP,IAC3D9B,EAAQW,QAAQwD,YAChBnE,EAAQW,QAAQyD,SAIpB,SAASC,EAASvG,EAAGC,EAAGuG,GACtBtE,EAAQoC,QAAQd,KAAKxD,GACrBkC,EAAQqC,QAAQf,KAAKvD,GACrBiC,EAAQsC,WAAWhB,KAAKgD,GAGxBtE,EAAQ2D,UAAU3D,EAAQuC,cAAcjB,KAAK,IAAI5B,EAAJ,QAAW5B,EAAGC,EAAGiC,EAAQe,cAGxE,SAASwD,IACPvE,EAAQ+C,QAAQpB,QAAQ,SAAA6C,GACtBA,EAAM9B,UAAU+B,OAAO,YAI3B,SAASC,EAAYC,GACb7C,IAAAA,EAAI9B,EAAQ2D,UAAU3D,EAAQ2C,WAAWrE,OAAS,EACpDwD,GAAK,GAAG9B,EAAQ6D,SAASvC,KAAKsD,EAAY5E,EAAQ2D,UAAU3D,EAAQ2C,WAAWb,GAAI9B,EAAQ2C,YAEzFkC,IAAAA,EAASF,EAAMG,MAAQ5E,OAAO6E,WAC9BC,EAASL,EAAMM,MAAQ/E,OAAOgF,UACpClF,EAAQmC,SAAU,EAClBkC,EAASQ,EAAQG,GACjBjB,IAGF,SAASoB,EAAYR,GACf3E,EAAQmC,UACVkC,EAASM,EAAMG,MAAQ5E,OAAO6E,WAAYJ,EAAMM,MAAQ/E,OAAOgF,WAAW,GAC1EnB,KAIJ,SAASqB,EAAUT,GACjB3E,EAAQmC,SAAU,EAElBnC,EAAQoC,QAAU,GAClBpC,EAAQqC,QAAU,GAClBrC,EAAQsC,WAAa,GAGvB,SAASsC,EAAYS,EAAQtF,GAYpBuF,IAXDxF,IAAAA,EAAQ,GACRyF,EAAMvF,EAAQqD,YAAYtD,GAAOmD,MAAM,GAAI,GAAGsC,MAAM,KAGtD1H,EAAIuH,EAAOvH,EAAIuH,EAAOzF,EAAI,EAC1B7B,EAAIsH,EAAOtH,EAIX0H,EAAQJ,EAAOvH,EAAIuH,EAAOzF,EAAI,EAC9B0F,EAAItF,EAAQW,QAAQ+E,aAAaD,IAAS1H,EAAG,EAAG,GAAG4H,KAChDL,EAAE,IAAMC,EAAI,IAAMD,EAAE,IAAMC,EAAI,IAAMD,EAAE,IAAMC,EAAI,IACrDzH,EAAI2H,EACJH,EAAItF,EAAQW,QAAQ+E,aAAaD,IAAS1H,EAAG,EAAG,GAAG4H,KAG/C7G,IAAAA,EAAQ,IAAIjB,EAAJ,QAAUC,EAAI,EAAGC,GAkDxB,OA/CS,SAAV6H,EAAWpF,EAAOqF,GAChBC,IAAAA,EAAY,CAChB,IAAIjI,EAAJ,QAAU2C,EAAM1C,EAAI,EAAG0C,EAAMzC,GAC7B,IAAIF,EAAJ,QAAU2C,EAAM1C,EAAI,EAAG0C,EAAMzC,EAAI,GACjC,IAAIF,EAAJ,QAAU2C,EAAM1C,EAAO0C,EAAMzC,EAAI,GACjC,IAAIF,EAAJ,QAAU2C,EAAM1C,EAAI,EAAG0C,EAAMzC,EAAI,GACjC,IAAIF,EAAJ,QAAU2C,EAAM1C,EAAI,EAAG0C,EAAMzC,GAC7B,IAAIF,EAAJ,QAAU2C,EAAM1C,EAAI,EAAG0C,EAAMzC,EAAI,GACjC,IAAIF,EAAJ,QAAU2C,EAAM1C,EAAO0C,EAAMzC,EAAI,GACjC,IAAIF,EAAJ,QAAU2C,EAAM1C,EAAI,EAAG0C,EAAMzC,EAAI,IAI7BgI,EAAYD,EAAUE,UAAU,SAAAC,GAAKA,OAAAA,EAAEnI,IAAM+H,EAAK/H,GAAKmI,EAAElI,IAAM8H,EAAK9H,IACtEgI,GAAAA,EAAY,EACT,IAAA,IAAIjE,EAAI,EAAGA,EAAIiE,EAAY,EAAGjE,IACjCgE,EAAUI,OAAO,EAAG,EAAGJ,EAAUK,SAK/BC,IAAAA,EAAWN,EAAUE,UAAU,SAAAC,GAC7BI,IAAAA,EAAQrG,EAAQW,QAAQ+E,aAAaO,EAAEnI,EAAGmI,EAAElI,EAAG,EAAG,GAAG4H,KACpD3H,OAAAA,KAAKsI,IAAID,EAAM,GAAKd,EAAI,IAAM,GAC9BvH,KAAKsI,IAAID,EAAM,GAAKd,EAAI,IAAM,GAC9BvH,KAAKsI,IAAID,EAAM,GAAKd,EAAI,IAAM,IAIjCgB,EAAYT,EAAUE,UAAU,SAAAC,GAC9BI,IAAAA,EAAQrG,EAAQW,QAAQ+E,aAAaO,EAAEnI,EAAGmI,EAAElI,EAAG,EAAG,GAAG4H,KACpD,OAACM,EAAEnI,IAAM+H,EAAK/H,GAAKmI,EAAElI,IAAM8H,EAAK9H,IACrCC,KAAKsI,IAAID,EAAM,GAAKd,EAAI,IAAM,GAC9BvH,KAAKsI,IAAID,EAAM,GAAKd,EAAI,IAAM,GAC9BvH,KAAKsI,IAAID,EAAM,GAAKd,EAAI,IAAM,IAG9Ba,IAAc,IAAdA,EAAiB,CACnBtG,EAAMwB,KAAK,IAAIzD,EAAJ,QAAU2C,EAAM1C,EAAG0C,EAAMzC,IAC9ByI,IAAAA,EAAOV,EAAUS,GAEnBC,GAAAA,EAAK1I,IAAMgB,EAAMhB,GAAK0I,EAAKzI,IAAMe,EAAMf,EAAG,OACvC6H,OAAAA,EAAQY,EAAMhG,IAIzBoF,CAAQ9G,EAAOA,GACR,IAAIe,EAAJ,QAAYC,EAAOC,GAG5B,SAAS0G,IAED3E,IAAAA,EAAI9B,EAAQ2D,UAAU3D,EAAQuC,cAAcjE,OAAS,EACvDwD,GAAK,GAAG9B,EAAQ6D,SAASvC,KAAKsD,EAAY5E,EAAQ2D,UAAU3D,EAAQuC,cAAcT,GAAI9B,EAAQuC,eAH1E,IAAA,GAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IAKFvC,IAAAA,IAAkB,EAAlBA,EAAAA,EAAQ6D,SAAU,OAAA,cAAA,GAAA,EAAA,EAAA,QAAA,MAAA,GAAA,EAAA,CAA7B6C,IAAAA,EAA6B,EAAA,MACtCA,EAAQC,YAAY3G,GACpB0G,EAAQE,cAAc5G,IAPA,MAAA,GAAA,GAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,MAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,MAAA,IAWnB,SAAS6G,EAAK3G,EAAQS,GAE3BA,EAAQmG,SAAW,QACnB9G,EAAQE,OAASA,EACjBF,EAAQW,QAAUA,EAGZoG,IAAAA,EAAYvE,SAASK,eAAe,cACpCmE,EAAmBxE,SAASK,eAAe,sBAKjDZ,OAAOgF,iBAAiB,SAAU,WAChC/G,EAAOC,MAA4B,IAApB8B,OAAOiF,WACtBhH,EAAOI,OAAS2B,OAAOkF,YACvBpD,MAGE/B,GACF9B,EAAO+G,iBAAiB,cAAe,SAAAtC,GAAWD,EAAYC,KAC9DzE,EAAO+G,iBAAiB,cAAe,SAAAtC,GAAWQ,EAAYR,KAC9DzE,EAAO+G,iBAAiB,YAAa,SAAAtC,GAAWS,EAAUT,KAC1DzE,EAAO+G,iBAAiB,gBAAiB,SAAAtC,GAAWS,EAAUT,MACrDzC,GACThC,EAAO+G,iBAAiB,aAAc,SAAAtC,GAAWD,EAAYC,KAC7DzE,EAAO+G,iBAAiB,YAAa,SAAAtC,GAAWQ,EAAYR,KAC5DzE,EAAO+G,iBAAiB,WAAY,SAAAtC,GAAWS,EAAUT,KACzDzE,EAAO+G,iBAAiB,cAAe,SAAAtC,GAAWS,EAAUT,OAE5DzE,EAAO+G,iBAAiB,YAAa,SAAAtC,GAAWD,EAAYC,KAC5DzE,EAAO+G,iBAAiB,YAAa,SAAAtC,GAAWQ,EAAYR,KAC5DzE,EAAO+G,iBAAiB,UAAW,SAAAtC,GAAWS,EAAUT,KACxDzE,EAAO+G,iBAAiB,aAAc,SAAAtC,GAAWS,EAAUT,MAG7D3E,EAAQ+C,QAAQpB,QAAQ,SAAA6C,GACtBA,EAAMyC,iBAAiB,QAAS,WAC9B1C,IACAvE,EAAQ2C,UAAY3C,EAAQuC,aAC5BvC,EAAQuC,aAAeiC,EAAM9B,UAAU,GACvC8B,EAAM9B,UAAUrD,IAAI,cAIxB0H,EAAUE,iBAAiB,QAAS,SAAAtC,GAClC3E,EAAQe,YAAc6B,SAASmE,EAAUjE,OACzCkE,EAAiBI,UAAYL,EAAUjE,QAGzCN,SAASK,eAAe,SAASoE,iBAAiB,SAAU,SAAAtC,GAC1D3E,EAAQU,UAAYiE,EAAM0C,OAAOC,QACjC9E,SAASK,eAAe,kBAAkB0E,MAAMC,QAAUxH,EAAQU,UAAY,QAAU,SAG1F8B,SAASK,eAAe,SAASoE,iBAAiB,QAAS,SAAAtC,GAAS,IAAA,GAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IAE5C3E,IAAAA,IAAkB,EAAlBA,EAAAA,EAAQ6D,SAAU,OAAA,cAAA,GAAA,EAAA,EAAA,QAAA,MAAA,GAAA,EAAA,CAA7B6C,IAAAA,EAA6B,EAAA,MAAA,GAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IAClBA,IAAAA,IAAe,EAAfA,EAAAA,EAAQ5G,MAAO,OAAA,cAAA,GAAA,EAAA,EAAA,QAAA,MAAA,GAAA,EAAA,CAAxBU,IAAAA,EAAwB,EAAA,MACjCG,EAAQa,UAAY,OACpBb,EAAQc,SAASjB,EAAM1C,EAAG0C,EAAMzC,EAAG,EAAG,IAHF,MAAA,GAAA,GAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,MAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,MAAA,KAF0B,MAAA,GAAA,GAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,MAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,MAAA,MAUpEyE,SAASK,eAAe,WAAWoE,iBAAiB,QAAS,SAAAtC,GAE3D8B,IACA9B,EAAM0C,OAAOI,UAAW,EACxB9C,EAAM0C,OAAO3E,UAAUrD,IAAI;;AC/NxB,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,oBAAA,QAAA,qBAAA,QAAA,sCAAA,QAAA,qBAAA,QAAA,+BAAA,QAAA,mBAAA,QAAA,mCAAA,QAAA,oCAAA,QAAA,2BAAA,QAAA,2BAAA,QAAA,cAAA,QAAA,aAAA,QAAA,oBAAA,QAAA,uBAAA,QAAA,uBAAA,QAAA,sBAAA,QAAA,2BAAA,EAtBA,IAAMqI,EAAwB,EAsB9B,QAAA,sBAAA,EArBA,IAAMC,EAAwB,EAqB9B,QAAA,sBAAA,EApBA,IAAMC,EAAyB,GAoB/B,QAAA,uBAAA,EAnBA,IAAMC,EAAyB,GAmB/B,QAAA,uBAAA,EAlBA,IAAMC,EAAsB,IAkB5B,QAAA,oBAAA,EAhBA,IAAMC,EAAe,EAgBrB,QAAA,aAAA,EAfA,IAAMC,EAAgB,GAetB,QAAA,cAAA,EAbA,IAAMC,EAA6B,IAanC,QAAA,2BAAA,EAZA,IAAMC,EAA6B,GAYnC,QAAA,2BAAA,EAVA,IAAMC,EAAsC,GAU5C,QAAA,oCAAA,EATA,IAAMC,EAAqC,GAS3C,QAAA,mCAAA,EAPA,IAAMC,EAAqB,EAO3B,QAAA,mBAAA,EANA,IAAMC,EAAiC,GAMvC,QAAA,+BAAA,EAJA,IAAMC,EAAuB,GAI7B,QAAA,qBAAA,EAHA,IAAMC,EAAwC,EAG9C,QAAA,sCAAA,EADA,IAAMC,EAAuB,GAC7B,QAAA,qBAAA,EAAA,IAAMC,EAAsB,GAA5B,QAAA,oBAAA;;ACkBN,aAxCD,SAASC,EAAYxH,EAAKyH,GACjB5K,OAAAA,KAAKoD,UAAYwH,EAAMzH,GAAOA,EAGhC,SAAS0H,EAAoBC,EAAGC,GAC/BxK,IAAAA,EAAOP,KAAKsI,IAAIwC,EAAIC,GAAK,IACxB/K,OAAAA,KAAKmD,IAAI5C,EAAMP,KAAKsI,IAAI/H,EAAO,MAGjC,SAASyK,EAAYC,GAGnBnG,IAFDoG,IAAAA,EAAiBlL,KAAKmL,IAAInL,KAAKsI,IAAI2C,GAAQ,GAC7CnG,EAAQ,EACK,IAAVA,GAAe9E,KAAKoD,SAAWpD,KAAKmL,IAAInL,KAAKsI,IAAIxD,GAAQ,GAAKoG,GACnEpG,EAAQ6F,GAAaM,EAAOA,GAEvBnG,OAAAA,EAGF,SAASsG,EAAYC,GACtBlI,IAAAA,EAAMkI,EAAM,GACZC,EAAQ,EAOL,OANPD,EAAM1H,QAAQ,SAAC4H,EAAOzH,GAChByH,EAAQpI,IACVA,EAAMoI,EACND,EAAQxH,KAGL,CAACX,EAAKmI,GAGR,SAASE,EAAYH,GACtBT,IAAAA,EAAMS,EAAM,GACZI,EAAQ,EAOL,OANPJ,EAAM1H,QAAQ,SAAC4H,EAAOzH,GAChByH,EAAQX,IACVA,EAAMW,EACNE,EAAQ3H,KAGL,CAAC8G,EAAKa,GACd,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,oBAAA,EAAA,QAAA,YAAA,EAAA,QAAA,YAAA,EAAA,QAAA,YAAA;;ACgFA,aAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,SAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,WAAA,EAAA,aAAA,EAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,EAAA,EAAA,IAAA,IAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,GAAA,EAAA,EAAA,UAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,KAAA,EAAA,QAAA,SAAA,EApHKC,IAAAA,EAoHL,WAnHa5L,SAAAA,EAAAA,EAAGC,EAAG4L,GAAG,EAAA,KAAA,GACd7L,KAAAA,EAAIA,EACJC,KAAAA,EAAIA,EACJ4L,KAAAA,EAAIA,EAgHZ,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,OA7GM7L,MAAAA,SAAAA,EAAGC,GACC,OAAA,KAAKD,EAAIA,EAAI,KAAKC,EAAIA,MA4GhC,EAAA,GAxGK6L,EAAQ,CACZ,IAAIF,EAAK,EAAE,EAAE,GAAG,IAAIA,GAAM,EAAE,EAAE,GAAG,IAAIA,EAAK,GAAG,EAAE,GAAG,IAAIA,GAAM,GAAG,EAAE,GACjE,IAAIA,EAAK,EAAE,EAAE,GAAG,IAAIA,GAAM,EAAE,EAAE,GAAG,IAAIA,EAAK,EAAE,GAAG,GAAG,IAAIA,GAAM,EAAE,GAAG,GACjE,IAAIA,EAAK,EAAE,EAAE,GAAG,IAAIA,EAAK,GAAG,EAAE,GAAG,IAAIA,EAAK,EAAE,GAAG,GAAG,IAAIA,EAAK,GAAG,GAAG,IAG7DzD,EAAI,CAAC,IAAI,IAAI,IAAI,GAAG,GAAG,GAC7B,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,EAAE,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,EAAE,GAAG,GAAG,IAAI,GAAG,GAAG,GACzE,IAAK,EAAE,IAAI,IAAI,IAAI,IAAI,GAAG,EAAE,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GACzE,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAK,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,IACxE,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IACxE,IAAI,IAAI,GAAI,GAAG,GAAG,GAAG,IAAK,EAAE,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAK,GAAG,GAAG,IAAI,IAAI,IACxE,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAK,EAAE,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IACxE,EAAE,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GACzE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAK,EAAE,GAAG,IAAI,IAAK,GAAG,IAAI,IAAI,IAAI,IAAI,IAAK,GAAG,IAAI,EAC1E,IAAI,GAAG,GAAG,IAAK,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAK,IAAI,IAAI,IAAI,IAAI,GAAG,IACxE,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAK,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IACxE,GAAG,IAAI,IAAK,GAAG,IAAI,IAAI,IAAI,IAAI,IAAK,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAK,EAAE,IAAI,IACxE,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,KAC9D4D,EAAO,IAAI7G,MAAM,KACjB8G,EAAQ,IAAI9G,MAAM,KAEjB,SAAS+G,EAAKA,GACfA,EAAO,GAAKA,EAAO,IAErBA,GAAQ,QAGVA,EAAO/L,KAAKgM,MAAMD,IACP,MACTA,GAAQA,GAAQ,GAGb,IAAA,IAAIjI,EAAI,EAAGA,EAAI,IAAKA,IAAK,CACtB1D,IAAAA,EAAQ,EAAJ0D,EAAQmE,EAAEnE,GAAa,IAAPiI,EAAc9D,EAAEnE,GAAOiI,GAAM,EAAK,IAC5DF,EAAK/H,GAAK+H,EAAK/H,EAAI,KAAO1D,EAC1B0L,EAAMhI,GAAKgI,EAAMhI,EAAI,KAAO8H,EAAMxL,EAAI,KAI1C2L,EAAK,GAGL,IAAME,EAAK,IAAOjM,KAAKC,KAAK,GAAK,GAC3BiM,GAAM,EAAIlM,KAAKC,KAAK,IAAM,EAE1BkM,EAAK,EAAI,EACTC,EAAK,EAAI,EAGR,SAASC,EAASC,EAAKC,GACxBC,IAEEhM,GAAK8L,EAAMC,GAAON,EACpBnI,EAAI9D,KAAKgM,MAAMM,EAAM9L,GACrBiM,EAAIzM,KAAKgM,MAAMO,EAAM/L,GACnBkM,GAAK5I,EAAI2I,GAAKP,EACdS,EAAKL,EAAMxI,EAAI4I,EACfE,EAAKL,EAAME,EAAIC,EAIfG,EAAKF,EAAKC,EAAK,EAAI,EACnBE,EAAKH,EAAKC,EAAK,EAAI,EAMnBG,EAAKJ,EAAKE,EAAKX,EACfc,EAAKJ,EAAKE,EAAKZ,EACfe,EAAKN,EAAK,EAAI,EAAIT,EAClBgB,EAAKN,EAAK,EAAI,EAAIV,EAIlBiB,EAAMrB,GAFZhI,GAAK,KAEiB+H,EADtBY,GAAK,MAECW,EAAMtB,EAAMhI,EAAI+I,EAAKhB,EAAKY,EAAIK,IAC9BO,EAAMvB,EAAMhI,EAAI,EAAI+H,EAAKY,EAAI,IAE/Ba,EAAK,GAAMX,EAAKA,EAAKC,EAAKA,EAO1BW,EAAK,GAAMR,EAAKA,EAAKC,EAAKA,EAO1BQ,EAAK,GAAMP,EAAKA,EAAKC,EAAKA,EASvB,OAAA,KAtBHI,EAAK,EACF,GAELA,GAAMA,GACIA,EAAKH,EAAIM,KAAKd,EAAIC,KAG3BW,EAAK,EACD,GAELA,GAAMA,GACIA,EAAKH,EAAIK,KAAKV,EAAIC,KAG1BQ,EAAK,EACF,GAELA,GAAMA,GACIA,EAAKH,EAAII,KAAKR,EAAIC;;ACvG7B,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAZH,IAAA,EAAA,EAAA,QAAA,mBAYG,SAAA,EAAA,GAAA,GAAA,GAAA,EAAA,WAAA,OAAA,EAAA,IAAA,EAAA,GAAA,GAAA,MAAA,EAAA,IAAA,IAAA,KAAA,EAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,GAAA,CAAA,IAAA,EAAA,OAAA,gBAAA,OAAA,yBAAA,OAAA,yBAAA,EAAA,GAAA,GAAA,EAAA,KAAA,EAAA,IAAA,OAAA,eAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,OAAA,EAAA,QAAA,EAAA,EAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,SAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,WAAA,EAAA,aAAA,EAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,EAAA,EAAA,IAAA,IAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,GAAA,EAAA,EAAA,UAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAVkBQ,IAAAA,EAUlB,WAAA,SAAA,IAAA,EAAA,KAAA,GAAA,OAAA,EAAA,EAAA,KAAA,CAAA,CAAA,IAAA,eATmB5N,MAAAA,SAAAA,EAAGC,GACf4N,IAAAA,GAAOC,EAAMvB,SAASvM,EAAI,IAAKC,EAAI,KAAO,GAAK,EAC/C8N,GAAOD,EAAMvB,SAASvM,EAAI,IAAO,GAAIC,EAAI,IAAO,IAAM,GAAK,EAC3D+N,GAASF,EAAMvB,SAASvM,EAAI,IAAO,IAAKC,EAAI,IAAO,KAAO,GAAK,EAC9DC,OAAAA,KAAKmL,KAAKwC,EAAME,EAAMC,GAAS,EAAG,KAK1C,CAAA,IAAA,YAFgBC,MAAAA,SAAAA,GACR,OAACL,EAAQM,aAAaD,EAAKjN,MAAMhB,EAAGiO,EAAKjN,MAAMf,GAAK2N,EAAQM,aAAaD,EAAKhN,IAAIjB,EAAGiO,EAAKhN,IAAIhB,IAAM,MAC5G,EAAA,GAAA,QAAA,QAAA;;ACoMA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAhNH,IAAA,EAAA,EAAA,QAAA,eAgNG,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAA,SAAA,EAAA,EAAA,GAAA,OAAA,EAAA,IAAA,EAAA,EAAA,IAAA,IAAA,SAAA,IAAA,MAAA,IAAA,UAAA,wDAAA,SAAA,EAAA,EAAA,GAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IAAA,IAAA,IAAA,EAAA,EAAA,EAAA,OAAA,cAAA,GAAA,EAAA,EAAA,QAAA,QAAA,EAAA,KAAA,EAAA,QAAA,GAAA,EAAA,SAAA,GAAA,GAAA,IAAA,MAAA,GAAA,GAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,MAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,MAAA,GAAA,OAAA,EAAA,SAAA,EAAA,GAAA,GAAA,MAAA,QAAA,GAAA,OAAA,EAAA,SAAA,EAAA,GAAA,OAAA,EAAA,mBAAA,QAAA,iBAAA,OAAA,SAAA,SAAA,GAAA,cAAA,GAAA,SAAA,GAAA,OAAA,GAAA,mBAAA,QAAA,EAAA,cAAA,QAAA,IAAA,OAAA,UAAA,gBAAA,IAAA,GAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,SAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,WAAA,EAAA,aAAA,EAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,EAAA,EAAA,IAAA,IAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,GAAA,EAAA,EAAA,UAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EA9MkBkO,IAAAA,EA8MlB,WAzMWC,SAAAA,EAAAA,EAAQC,EAAMC,GAAY,EAAA,KAAA,GAC/BF,KAAAA,OAASA,EACTC,KAAAA,KAAOA,EACPC,KAAAA,WAAaA,EACbC,KAAAA,kBAAoB,EACpBC,KAAAA,oBAAiBC,EACjBC,KAAAA,kBAAeD,EAmMrB,OAAA,EAAA,EAAA,KAAA,CAAA,CAAA,IAAA,OA7MiB,IAAA,WACT,MAAA,CAAEE,KAAM,OAAQC,KAAM,OAAQC,OAAQ,cA4M9C,EAAA,EAAA,CAAA,CAAA,IAAA,4BAhMyBP,MAAAA,SAAAA,GAEnB,IAAA,IAAMQ,KADNP,KAAAA,oBACcD,EACZA,KAAAA,WAAWQ,GAAQR,EAAWQ,KA6LtC,CAAA,IAAA,YAzLSC,MAAAA,SAAAA,GACJC,IAAAA,EAAY,KAAKV,WAAWW,QAAQ,GAIjCD,OAHFV,KAAAA,WAAWW,QAAQpL,QAAQ,SAAAqL,GAC1BA,EAAOH,GAAQC,EAAUD,KAAOC,EAAYE,KAE3CF,IAoLR,CAAA,IAAA,YAjLSD,MAAAA,SAAAA,GACJI,IAAAA,EAAY,KAAKb,WAAWW,QAAQ,GAIjCE,OAHFb,KAAAA,WAAWW,QAAQpL,QAAQ,SAAAqL,GAC1BA,EAAOH,GAAQI,EAAUJ,KAAOI,EAAYD,KAE3CC,IA4KR,CAAA,IAAA,SAzKQ,MAAA,WA+BA,OA9BH,KAAKZ,oBAAsB,KAAKC,iBAC7BA,KAAAA,eAAiB,KAAKD,kBACvB,KAAKF,OAASF,EAAUiB,KAAKT,MAC/BxM,KAAO,KAAK6M,UAAU,KAAKhP,EAC3BuC,KAAO,KAAKyM,UAAU,KAAK/O,EACtByO,KAAAA,aAAe,CAClB1O,EAAGmC,KACHlC,EAAGsC,KACHF,MAAO,KAAK8M,UAAU,KAAKnP,EAAImC,KAC/BK,OAAQ,KAAK2M,UAAU,KAAKlP,EAAIsC,KAChC6L,OAAQ,KAAKA,SAEN,KAAKC,OAASF,EAAUiB,KAAKR,KACjCF,KAAAA,aAAe,CAClB1O,EAAGE,KAAKmD,IAAI,KAAKiL,WAAWtN,MAAMhB,EAAG,KAAKsO,WAAWrN,IAAIjB,GACzDC,EAAGC,KAAKmD,IAAI,KAAKiL,WAAWtN,MAAMf,EAAG,KAAKqO,WAAWrN,IAAIhB,GACzDoC,MAAOnC,KAAKsI,IAAI,KAAK8F,WAAWtN,MAAMhB,EAAI,KAAKsO,WAAWrN,IAAIjB,GAC9DwC,OAAQtC,KAAKsI,IAAI,KAAK8F,WAAWtN,MAAMf,EAAI,KAAKqO,WAAWrN,IAAIhB,GAC/DmO,OAAQ,KAAKA,QAEN,KAAKC,OAASF,EAAUiB,KAAKP,SACjCH,KAAAA,aAAe,CAClB1O,EAAG,KAAKsO,WAAWe,OAAOrP,EAAI,KAAKsO,WAAWgB,OAC9CrP,EAAG,KAAKqO,WAAWe,OAAOpP,EAAI,KAAKqO,WAAWgB,OAC9CjN,MAAgC,EAAzB,KAAKiM,WAAWgB,OACvB9M,OAAiC,EAAzB,KAAK8L,WAAWgB,OACxBlB,OAAQ,KAAKA,UAIZ,KAAKM,eA0Ib,CAAA,IAAA,UAvIOrO,MAAAA,SAAAA,GAEAkP,IAAAA,EAAS,KAAKA,SACdC,EAAcnP,EAAMkP,SACtBA,GAAAA,GAAUC,IACTD,EAAOvP,EAAIuP,EAAOlN,MAAQmN,EAAYxP,GAAKwP,EAAYxP,EAAIwP,EAAYnN,MAAQkN,EAAOvP,KACtFuP,EAAOtP,EAAIsP,EAAO/M,OAASgN,EAAYvP,GAAKuP,EAAYvP,EAAIuP,EAAYhN,OAAS+M,EAAOtP,GACpF,OAAA,EAGL,KAAKoO,OAASF,EAAUiB,KAAKP,OAC3BxO,EAAMgO,OAASF,EAAUiB,KAAKT,MAChCtO,EAAMoP,oBAAoB,MAEnB,KAAKpB,OAASF,EAAUiB,KAAKT,KAClCtO,EAAMgO,OAASF,EAAUiB,KAAKP,OAC3Ba,KAAAA,qBAAqBrP,GAErBoP,KAAAA,oBAAoBpP,GAElB,KAAKgO,OAASF,EAAUiB,KAAKR,MAClCvO,EAAMgO,OAASF,EAAUiB,KAAKP,QAC3Ba,KAAAA,qBAAqBrP,KAiH/B,CAAA,IAAA,sBA5GmBkH,MAAAA,SAAAA,GAEd,GAAA,KAAK8G,OAASF,EAAUiB,KAAKP,QAE7BtH,EAAO8G,OAASF,EAAUiB,KAAKP,OAA/BtH,CAGE+G,IACAW,GADa,KAAKZ,OAASF,EAAUiB,KAAKR,KAAO,KAAKe,oBAAsB,KAAKrB,YAC5DW,QACrBK,EAAS/H,EAAO+G,WAAWgB,OATP,GAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IAYLL,IAAAA,IAAS,EAATA,EAAAA,EAAS,OAAA,cAAA,GAAA,EAAA,EAAA,QAAA,MAAA,GAAA,EAAA,CACxBC,GADwB,EAAA,MACjBzN,UAAU8F,EAAO+G,WAAWe,SAAWC,EAASA,EAClD,OAAA,EAIJ,IAAA,IAAItL,EAAI,EAAGA,EAAIiL,EAAQzO,OAAQwD,IAAK,CACjChD,IAAAA,EAAQiO,EAAQjL,GAChB/C,EAAMgO,GAASjL,EAAI,GAAKiL,EAAQzO,QACe+G,EAAAA,EAAO+G,WAAWe,OAAOO,eAAe5O,EAAOC,GAA7FQ,EAAAA,EAAAA,UAAwBE,GAAbD,EAAAA,YAAaC,EAAAA,WAAWvB,EAAAA,EAAAA,QACtCuB,GAAAA,EAAY,GAAKA,EAAYvB,GAAWqB,GAAa6N,EAASA,EACzD,OAAA,EAKLO,IAAAA,EAAO,CAACZ,EAAQ,GAAG1O,MAAM0O,EAAQ,IAAKA,EAAQ,GAAG1O,MAAM0O,EAAQ,KAC/Da,EAAUvI,EAAO+G,WAAWe,OAAO9O,MAAM0O,EAAQ,IACjDc,EAAUxI,EAAO+G,WAAWe,OAAO9O,MAAM0O,EAAQ,IACjDe,EAAc,CAACF,EAAQzO,QAAQwO,EAAK,IAAKE,EAAQ1O,QAAQwO,EAAK,KAC9DI,EAAO,CAACH,EAAQjP,IAAIgP,EAAK,IAAKE,EAAQlP,IAAIgP,EAAK,KACjDI,QAAAA,EAAK,GAAK,GAAKD,EAAY,GAAG5P,UAAYyP,EAAK,GAAGzP,WAClD6P,EAAK,GAAK,GAAKD,EAAY,GAAG5P,UAAYyP,EAAK,GAAGzP,YAlC9B,MAAA,GAAA,GAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,MAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,MAAA,OA4G3B,CAAA,IAAA,oBAnEmB,MAAA,WAEd,GAAA,KAAKiO,OAASF,EAAUiB,KAAKR,KAA7B,CAEEsB,IAAAA,EAAY,KAAK5B,WAAWrN,IAAIV,MAAM,KAAK+N,WAAWtN,OACtDmP,EAAgB,IAAIpQ,EAAJ,SAAWmQ,EAAUjQ,EAAGiQ,EAAUlQ,GAClDoQ,EAAYD,EAAcpP,eAAe,GAAM,KAAKuN,WAAWjM,MAAQ8N,EAAc3P,UACpF,MAAA,CACLyO,QAAS,CACP,KAAKX,WAAWtN,MAAMO,IAAI6O,GAC1B,KAAK9B,WAAWtN,MAAMT,MAAM6P,GAC5B,KAAK9B,WAAWrN,IAAIV,MAAM6P,GAC1B,KAAK9B,WAAWrN,IAAIM,IAAI6O,QAuD7B,CAAA,IAAA,uBAlDoBC,MAAAA,SAAAA,GAEf,GAAA,KAAKhC,OAASF,EAAUiB,KAAKP,QAE7BwB,EAAKhC,OAASF,EAAUiB,KAAKP,OAA7BwB,CAaeR,IAXbS,IAAAA,EAAW,KAAKjC,OAASF,EAAUiB,KAAKR,KAAO,KAAKe,oBAAoBV,QAAU,KAAKX,WAAWW,QAClGsB,EAAWF,EAAKhC,OAASF,EAAUiB,KAAKR,KAAOyB,EAAKV,oBAAoBV,QAAUoB,EAAK/B,WAAWW,QAClGY,EAAO,CACXS,EAAS,GAAG/P,MAAM+P,EAAS,IAC3BA,EAAS,GAAG/P,MAAM+P,EAAS,IAC3BC,EAAS,GAAGhQ,MAAMgQ,EAAS,IAC3BA,EAAS,GAAGhQ,MAAMgQ,EAAS,KAIvBC,EAAW,GAhBQ,EAAA,WAiBdzB,IAAAA,EAAQc,EAAd,GACGY,EAAeH,EAASI,IAAI,SAAAxB,GAAUA,OAAAA,EAAO7N,QAAQ0N,KACrD4B,EAAeJ,EAASG,IAAI,SAAAxB,GAAUA,OAAAA,EAAO7N,QAAQ0N,KAErD6B,EAAaH,EAAaC,IAAI,SAAAG,GAAUA,OAAAA,EAAOhQ,IAAIkO,KACnD+B,EAAaH,EAAaD,IAAI,SAAAG,GAAUA,OAAAA,EAAOhQ,IAAIkO,KAtBlC,EAAA,EAwBAgC,KAAKrF,YAAYkF,GAxBjB,GAwBhBI,EAxBgB,EAAA,GAwBVC,EAxBU,EAAA,GAAA,EAAA,EAyBAF,KAAKzF,YAAYsF,GAzBjB,GAyBhBM,EAzBgB,EAAA,GAyBVC,EAzBU,EAAA,GAAA,EAAA,EA0BAJ,KAAKrF,YAAYoF,GA1BjB,GA0BhBM,EA1BgB,EAAA,GA0BVC,EA1BU,EAAA,GAAA,EAAA,EA2BAN,KAAKzF,YAAYwF,GA3BjB,GA2BhBQ,EA3BgB,EAAA,GA2BVC,EAEb,EAAA,GACIP,GAAAA,EAAOM,GAAQF,EAAOF,EACxB,MAAA,CAAO,GAAA,GAGDM,IAAAA,EAAWf,EAAaQ,GAAQ1Q,MAAMoQ,EAAaY,IACnDE,EAAWd,EAAaU,GAAQ9Q,MAAMkQ,EAAaU,IACrDK,EAASpR,UAAYqR,EAASrR,UAAWoQ,EAAShN,KAAKgO,GAEtDhB,EAAShN,KAAKiO,EAAS1Q,gBAAgB,KArB7B8O,EAAAA,EAAAA,EAAAA,EAAM,OAAA,IAAA,CAAA,IAAA,EAAA,IAAA,GAAA,WAAA,EAAA,GAAA,OAAA,EAAA,EA0BrB6B,IAAAA,EAAYlB,EAAS,GAMlBkB,OALPlB,EAAS3M,QAAQ,SAAAgN,GACXA,EAAOzQ,UAAYsR,EAAUtR,YAAWsR,EAAYb,KAInDa,EAAU3Q,gBAAgB,QAClC,EAAA,GAAA,QAAA,QAAA;;AC5KA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EApCH,IAAA,EAAA,EAAA,QAAA,eAoCG,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,SAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,WAAA,EAAA,aAAA,EAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,EAAA,EAAA,IAAA,IAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,GAAA,EAAA,EAAA,UAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAlCkB4Q,IAAAA,EAkClB,WAjCW3Q,SAAAA,EAAAA,EAAOC,EAAK2Q,GAAS,EAAA,KAAA,GAC1B5Q,KAAAA,MAAQA,EACRC,KAAAA,IAAMA,EACN2Q,KAAAA,QAAUA,EA8BhB,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,WA3BQ5Q,MAAAA,SAAAA,GACFA,KAAAA,MAAQA,EACR4Q,KAAAA,QAAQC,SAASC,0BAA0B,CAAE9Q,MAAOA,IACpD4Q,KAAAA,QAAQG,iBAwBd,CAAA,IAAA,SArBM9Q,MAAAA,SAAAA,GACAA,KAAAA,IAAMA,EACN2Q,KAAAA,QAAQC,SAASC,0BAA0B,CAAE7Q,IAAKA,IAClD2Q,KAAAA,QAAQG,iBAkBd,CAAA,IAAA,aAfU1R,MAAAA,SAAAA,GACHyB,IAAAA,EAAI,KAAKb,IAAIV,MAAM,KAAKS,OACxBN,EAAIL,EAAMY,IAAIV,MAAMF,EAAMW,OAC1BgR,EAAS3R,EAAMW,MAAMT,MAAM,KAAKS,OAEhCiR,EAAYD,EAAOE,MAAMpQ,GACzBqQ,EAAcrQ,EAAEoQ,MAAMxR,GAExByR,GAAgB,IAAhBA,GAAmC,IAAdF,EAAiB,OAAO,EAE3CG,IAAAA,EAAIH,EAAYE,EAChBvF,EAAIoF,EAAOE,MAAMxR,GAAKyR,EAEtBE,EAAYzF,EADF,MACiBA,EAAI,MAAewF,EADpC,MACmDA,EAAI,KAChEC,OAAAA,EAAY,IAAItS,EAAJ,QAAU,KAAKiB,MAAMhB,EAAI4M,EAAI9K,EAAE9B,EAAG,KAAKgB,MAAMf,EAAI2M,EAAI9K,EAAE7B,GAAKoS,MAChF,EAAA,GAAA,QAAA,QAAA;;ACnBA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAjBH,IAAA,EAAA,EAAA,QAAA,iBACA,EAAA,EAAA,QAAA,eAgBG,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,SAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,WAAA,EAAA,aAAA,EAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,EAAA,EAAA,IAAA,IAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,GAAA,EAAA,EAAA,UAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAdkBC,IAAAA,EAclB,WAAA,SAAA,IAAA,EAAA,KAAA,GAAA,OAAA,EAAA,EAAA,KAAA,CAAA,CAAA,IAAA,eAbmBV,MAAAA,SAAAA,EAASW,EAAMtE,EAAMuE,GAIhC,OAHPD,EAAOA,GAAQX,EAAQW,KACvBtE,EAAOA,GAAQ2D,EAAQ3D,KACvBuE,EAASA,GAAUZ,EAAQY,OACpB,IAAIC,EAAJ,QAAYxE,EAAKjN,MAAOiN,EAAKhN,IAAKsR,EAAMC,KAShD,CAAA,IAAA,iBANqBxR,MAAAA,SAAAA,GAAOkP,IAAAA,EAAY,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,GAAI1P,EAASsJ,UAAAA,OAAAA,QAAAA,IAAAA,UAAAA,GAAAA,UAAAA,GAAAA,uBAAwByI,EAAO,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,EAAGC,EAAS,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,GAE/FtC,GAAahQ,KAAKY,GAAK,IACjBd,IAAAA,EAAIgB,EAAMhB,EAAIQ,EAASN,KAAKwS,IAAIxC,GAChCjQ,EAAIe,EAAMf,EAAIO,EAASN,KAAKyS,IAAIzC,GAC/B,OAAA,IAAIuC,EAAJ,QAAYzR,EAAO,IAAIjB,EAAJ,QAAUC,EAAGC,GAAIsS,EAAMC,OAClD,EAAA,GAAA,QAAA,QAAA;;ACwHA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAzIH,IAAA,EAAA,QAAA,kBAIA,EAAA,EAAA,QAAA,mBACA,EAAA,EAAA,QAAA,cACA,EAAA,EAAA,QAAA,eACA,EAAA,EAAA,QAAA,wBAkIG,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,SAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,WAAA,EAAA,aAAA,EAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,EAAA,EAAA,IAAA,IAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,GAAA,EAAA,EAAA,UAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAhIkBC,IAAAA,EAgIlB,WA3HWzR,SAAAA,EAAAA,EAAOC,GAAKsR,IAAAA,EAAO,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,EAAGC,EAAS,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,GAAI,EAAA,KAAA,GACxCxR,KAAAA,MAAQA,EACRC,KAAAA,IAAMA,EACNsR,KAAAA,KAAOA,EACPC,KAAAA,OAASA,EAETnQ,KAAAA,MAAQmQ,EAAOI,QAAU/I,EAAjB,sBAAyCD,EAAtD,sBACKiI,KAAAA,SAAW,IAAI1D,EAAJ,QAAc,KAAMA,EAAUiB,QAAAA,KAAKR,KAAM,CAAC5N,MAAOA,EAAOC,IAAKA,EAAKoB,MAAO,KAAKA,QAEzF0P,KAAAA,aAAe,EACf9D,KAAAA,KAAO,IAAI0D,EAAJ,QAAS3Q,EAAOC,EAAK,MAG5BsR,KAAAA,KAAOA,EAEPC,KAAAA,OAASA,EAETK,KAAAA,MAAQ,CAAEC,UAAW,GAAIC,SAAU,IAEnCC,KAAAA,MAAQ,GACRC,KAAAA,SAAWT,EAAOI,QAAU,KAAO,IACnCM,KAAAA,SAAWV,EAAOI,QAAU,GAAK,EAsGvC,OAAA,EAAA,EAAA,KAAA,CAAA,CAAA,IAAA,MA/HgB,IAAA,WACR,MAAA,CAAEO,MAAO,QAASC,IAAK,WA8H/B,EAAA,EAAA,CAAA,CAAA,IAAA,eAnGc,MAAA,WACNlT,OAAAA,KAAKmD,IAAIoH,EAAT,qBAA+B,EAAIvK,KAAK4K,IAAI,EAAG,KAAKkI,MAAMxS,OAAS,GAAK,KAAK0S,UAAY,KAAKD,WAkGtG,CAAA,IAAA,YA/FW,MAAA,WACN,GAAA,KAAKI,oBAAsB,KAAKtB,aAAc,CAC3CsB,KAAAA,kBAAoB,KAAKtB,aACxBuB,IAAAA,EAAW,IAAIvT,EAAJ,QAAU,EAAG,GACxB8Q,EAAS,KAAK5C,KAAKhN,IAAIV,MAAM,KAAK0N,KAAKjN,OACvCkR,EAAQoB,EAASpB,MAAMrB,GAEvBrP,EAAO0Q,EAAQ,GAAK,EAAIA,EAAQ,EAAI,EAAI,EACzCqB,KAAAA,gBAAkB/R,EAAO8R,EAASE,MAAM3C,GAExC,OAAA,KAAK0C,kBAqFb,CAAA,IAAA,SAlFQ,MAAA,WAKA,OAJH,KAAKE,iBAAmB,KAAK1B,eAC1B0B,KAAAA,eAAiB,KAAK1B,aACtB2B,KAAAA,aAAe,KAAKzF,KAAKjN,MAAM2S,SAAS,KAAK1F,KAAKhN,MAElD,KAAKyS,eA6Eb,CAAA,IAAA,mBA1EkB,MAAA,WACb,OAAA,KAAKb,MAAMC,UAAUtS,OAChB,KAAKqS,MAAMC,UAAU,GAAG7E,KAAKjN,MAAM4S,OAAO,KAAK3F,KAAKjN,QACpD,KAAK6R,MAAMC,UAAU,GAAG7E,KAAKhN,IAAI2S,OAAO,KAAK3F,KAAKjN,OAElD,KAAK6R,MAAME,SAAS,GAAG9E,KAAKjN,MAAM4S,OAAO,KAAK3F,KAAKhN,MACnD,KAAK4R,MAAME,SAAS,GAAG9E,KAAKhN,IAAI2S,OAAO,KAAK3F,KAAKhN,OAoE3D,CAAA,IAAA,OAhEM,MAAA,WACE,OAAA,KAAKT,SAAW,KAAKqT,iBA+D7B,CAAA,IAAA,SA5DMxT,MAAAA,SAAAA,EAAOyT,GACNC,IAAAA,EAAa,KAAKC,cAAc3T,GAChC4T,EAAWH,EAAgBC,IAAetB,EAAQyB,IAAIf,MAAQW,EAAe,EAAIA,EAAgB,GAChG,OAAA,KAAKK,OAASF,IAyDtB,CAAA,IAAA,YAtDW,MAAA,WACH,OAAA,KAAKpB,MAAME,SAASqB,OAAO,KAAKvB,MAAMC,aAqD9C,CAAA,IAAA,gBAlDalB,MAAAA,SAAAA,GACNkB,IAAAA,EAAY,KAAKuB,mBACnB,OAAA,KAAKxB,MAAMC,UAAU7O,SAAS2N,GACzBkB,EAAYL,EAAQyB,IAAIf,MAAQV,EAAQyB,IAAId,IAC1C,KAAKP,MAAME,SAAS9O,SAAS2N,GAC/BkB,EAAYL,EAAQyB,IAAId,IAAMX,EAAQyB,IAAIf,WAD5C,IA8CR,CAAA,IAAA,wBAzCqBvB,MAAAA,SAAAA,GAChB,OAAA,KAAKiB,MAAMC,UAAU7O,SAAS2N,GAAiB,KAAKiB,MAAMC,UACrD,KAAKD,MAAME,SAAS9O,SAAS2N,GAAiB,KAAKiB,MAAME,cAA7D,IAuCN,CAAA,IAAA,QApCKrQ,MAAAA,SAAAA,EAAOkP,EAAS0C,EAAUC,GAAM,IAAA,EAAA,KAC9BzB,EAAY,KAAKuB,mBAEjBG,EAAYlC,EAAemC,QAAAA,aAAa,MAC9CD,EAAUE,WAAWJ,EAAUC,GAC/BC,EAAUvG,KAAK0G,OAAOjS,GACjBuL,KAAAA,KAAK2G,SAASlS,GAEnB8R,EAAU3B,MAAMC,UAAY,KAAKD,MAAMC,UAAU1N,MAAM,GACvDoP,EAAU3B,MAAME,SAAW,KAAKF,MAAME,SAAS3N,MAAM,GAG/CyP,IAAAA,EAAa/B,EAAY0B,EAAY,KACrCM,EAAchC,EAAY,KAAO0B,GACtB1B,EAAY0B,EAAU3B,MAAMC,UAAY0B,EAAU3B,MAAME,UAEhElP,QAAQ,SAAAkR,GACXC,IAAAA,EAAQD,EAAKlC,MAAMC,UAAUmC,QAAQ,IAC1B,IAAXD,EACFD,EAAKlC,MAAMC,UAAUkC,GAASR,GAE9BQ,EAAQD,EAAKlC,MAAME,SAASkC,QAAQ,GACpCF,EAAKlC,MAAME,SAASiC,GAASR,KAIjCK,EAAWhC,MAAME,SAAW,CAACnB,EAASkD,GACtCA,EAAYjC,MAAMC,UAAY,CAAClB,EAASiD,GAExCjD,EAAQiB,MAAME,SAASvP,KAAKqR,GAC5BjD,EAAQiB,MAAME,SAASvP,KAAKsR,KAM7B,CAAA,IAAA,aAHUR,MAAAA,SAAAA,EAAUC,GACnBD,EAAS9Q,KAAK,MACd+Q,EAAKW,OAAO,KAAKrD,SAAStC,cAC3B,EAAA,GAAA,QAAA,QAAA;;AC3BA,aAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,SAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,WAAA,EAAA,aAAA,EAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,EAAA,EAAA,IAAA,IAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,GAAA,EAAA,EAAA,UAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EA9GkB4F,IAAAA,EA8GlB,WA7GWC,SAAAA,EAAAA,GAAQC,IAAAA,EAAa,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,GAAIC,EAAY,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,EAAGC,EAAQ,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,EAAG,EAAA,KAAA,GACxDH,KAAAA,OAASA,EACTC,KAAAA,WAAaA,EACbC,KAAAA,UAAYA,EACZC,KAAAA,MAAQA,EAERC,KAAAA,QAAU,GACVC,KAAAA,MAAQ,GAsGd,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,YAnGW,MAAA,WACJpT,IAAAA,EAAQnC,KAAKuD,MAAM,KAAK2R,OAAO/S,MAAQ,GACvCG,EAAStC,KAAKuD,MAAM,KAAK2R,OAAO5S,OAAS,GACzCxC,EAAIE,KAAKuD,MAAM,KAAK2R,OAAOpV,GAC3BC,EAAIC,KAAKuD,MAAM,KAAK2R,OAAOnV,GAG5BwV,KAAAA,MAAM,GAAK,IAAIN,EAAS,CAC3BnV,EAAGA,EAAIqC,EACPpC,EAAGA,EACHoC,MAAOA,EACPG,OAAQA,GACP,KAAK6S,WAAY,KAAKC,UAAW,KAAKC,MAAQ,GAG5CE,KAAAA,MAAM,GAAK,IAAIN,EAAS,CAC3BnV,EAAGA,EACHC,EAAGA,EACHoC,MAAOA,EACPG,OAAQA,GACP,KAAK6S,WAAY,KAAKC,UAAW,KAAKC,MAAQ,GAG5CE,KAAAA,MAAM,GAAK,IAAIN,EAAS,CAC3BnV,EAAGA,EACHC,EAAGA,EAAIuC,EACPH,MAAOA,EACPG,OAAQA,GACP,KAAK6S,WAAY,KAAKC,UAAW,KAAKC,MAAQ,GAG5CE,KAAAA,MAAM,GAAK,IAAIN,EAAS,CAC3BnV,EAAGA,EAAIqC,EACPpC,EAAGA,EAAIuC,EACPH,MAAOA,EACPG,OAAQA,GACP,KAAK6S,WAAY,KAAKC,UAAW,KAAKC,MAAQ,KA+DlD,CAAA,IAAA,WA3DQlF,MAAAA,SAAAA,GACH2E,IAAAA,GAAS,EACPU,EAAY,KAAKN,OAAOpV,EAAI,KAAKoV,OAAO/S,MAAQ,EAChDsT,EAAY,KAAKP,OAAOnV,EAAI,KAAKmV,OAAO5S,OAAS,EAEjDoT,EAAMvF,EAAKpQ,EAAI0V,GAAatF,EAAKpQ,EAAIoQ,EAAK7N,OAASmT,EACnDE,EAASxF,EAAKpQ,EAAI0V,EAOjBX,OALH3E,EAAKrQ,EAAI0V,GAAarF,EAAKrQ,EAAIqQ,EAAKhO,MAAQqT,EAC9CV,EAAQY,EAAM,EAAIC,EAAS,EAAIb,EACtB3E,EAAKrQ,EAAI0V,IAClBV,EAAQY,EAAM,EAAIC,EAAS,EAAIb,GAE1BA,IA8CR,CAAA,IAAA,SA3CM3E,MAAAA,SAAAA,GACD,GAAA,KAAKoF,MAAMjV,OAAQ,CACfwD,IAAAA,EAAI,KAAK8R,SAASzF,GACpBrM,IAAO,IAAPA,EAAU,OAAO,KAAKyR,MAAMzR,GAAGkR,OAAO7E,GAKxC,GAFCmF,KAAAA,QAAQhS,KAAK6M,GAEd,KAAKmF,QAAQhV,OAAS,KAAK6U,YAAc,KAAKE,MAAQ,KAAKD,UAAW,CAC9C,IAAtB,KAAKG,MAAMjV,QAAc,KAAKuV,YAG3B/R,IADHA,IAAAA,EAAI,EACDA,EAAI,KAAKwR,QAAQhV,QAAQ,CACxBwU,IAAAA,EAAQ,KAAKc,SAAS,KAAKN,QAAQxR,KAC1B,IAAXgR,EAAc,KAAKS,MAAMT,GAAOE,OAAO,KAAKM,QAAQpN,OAAOpE,EAAG,GAAG,IAChEA,QA4BV,CAAA,IAAA,WAtBQqM,MAAAA,SAAAA,GACD2E,IAAAA,EAAQ,KAAKc,SAASzF,GACxBmF,EAAU,KAAKA,QAEf,GAAA,KAAKC,MAAMjV,OACTwU,IAAW,IAAXA,EACFQ,EAAUA,EAAQpB,OAAO,KAAKqB,MAAMT,GAAOgB,SAAS3F,QAC/C,CAAA,IAAA,GAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IAEc,IAAA,IAAY,EAAZ,EAAA,KAAKoF,MAAO,OAAA,cAAA,GAAA,EAAA,EAAA,QAAA,MAAA,GAAA,EAAA,CAApBQ,IAAAA,EAAoB,EAAA,MAC7BT,EAAUA,EAAQpB,OAAO6B,EAAKD,SAAS3F,KAHpC,MAAA,GAAA,GAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,MAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,MAAA,IAOFmF,OAAAA,IAQR,CAAA,IAAA,QALO,MAAA,WACDA,KAAAA,QAAU,GADT,IAAA,GAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IAEa,IAAA,IAAY,EAAZ,EAAA,KAAKC,MAAO,OAAA,cAAA,GAAA,EAAA,EAAA,QAAA,MAAA,GAAA,EAAA,CAAA,EAAA,MACxBS,SAHD,MAAA,GAAA,GAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,MAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,MAAA,QAKP,EAAA,GAAA,QAAA,QAAA;;AC6HF,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,SAAA,EA3OD,IAAA,EAAA,QAAA,eAYA,EAAA,EAAA,QAAA,cACA,EAAA,EAAA,QAAA,gBAEA,EAAA,EAAA,QAAA,uBACA,EAAA,EAAA,QAAA,yBACA,EAAA,EAAA,QAAA,yBACA,EAAA,EAAA,QAAA,0BACA,EAAA,EAAA,QAAA,gCAwNC,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAA,SAAA,EAAA,GAAA,GAAA,GAAA,EAAA,WAAA,OAAA,EAAA,IAAA,EAAA,GAAA,GAAA,MAAA,EAAA,IAAA,IAAA,KAAA,EAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,GAAA,CAAA,IAAA,EAAA,OAAA,gBAAA,OAAA,yBAAA,OAAA,yBAAA,EAAA,GAAA,GAAA,EAAA,KAAA,EAAA,IAAA,OAAA,eAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,OAAA,EAAA,QAAA,EAAA,EAAA,SAAA,EAAA,GAAA,OAAA,EAAA,mBAAA,QAAA,iBAAA,OAAA,SAAA,SAAA,GAAA,cAAA,GAAA,SAAA,GAAA,OAAA,GAAA,mBAAA,QAAA,EAAA,cAAA,QAAA,IAAA,OAAA,UAAA,gBAAA,IAAA,GAtND,SAASC,EAAiBvE,EAAS0C,EAAUC,EAAM6B,GAC3CC,IAAAA,EAAS,CAAEC,SAAU,EAAG9D,OAAQ,IAEhC+D,EAAUhC,EAAKyB,SAASpE,EAAQC,SAAStC,UAHa,GAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IAIxCgH,IAJwC,IAI/B,EAJ+B,EAAA,WAIjDC,IACHnW,EALoD,EAAA,MAKtC+N,OAGhBiI,GAAAA,EAAOC,SAAW,EAAG,CACjBG,IAAAA,EAAe7E,EAAQ3D,KAAKyI,WAAWrW,EAAM4N,MAC/CwI,GAAAA,KACGJ,EAAO7D,OAAOD,MAAQkE,EAAalE,KAAOoE,QAAQnE,OAAOD,MAIxDxB,OAHJsF,EAAO7D,OAAOD,KAAOkE,EAAalE,KAClC8D,EAAOC,SAAW,EAEdvF,EAAKhG,oBAAoB1K,EAAM6P,YAAa0B,EAAQ1B,aAAe1F,EAAvE,+BACE,CAAO,GAAA,IAGTnK,EAAMqH,MAAM+O,EAAc7E,EAAS0C,EAAUC,GAC7C3C,EAAQ3D,KAAKhN,IAAMwV,EACnB7E,EAAQY,OAAOoE,SAAU,EAErBR,IACFA,EAAUrS,cAAgBqS,EAAUrS,eAAiB,GACrDqS,EAAUrS,cAAcP,KAAK,IAAIzD,EAAJ,QAAU0W,EAAazW,EAAGyW,EAAaxW,KAGtE,CAAO,GAAA,IAMToW,GAAAA,EAAOC,SAAW,GAGhB1E,EAAQ3D,KAAKhN,IAAI0S,SAAStT,EAAM4N,KAAKhN,MAAQsJ,EAAjD,mBAAqE,CAC7D7H,IAAAA,EAAQrC,EAAM4N,KAAKhN,IACzBoV,EAAOC,SAAW,EAClB1E,EAAQ3D,KAAKhN,IAAMyB,EACnBkP,EAAQY,OAAOoE,SAAU,EAGnB/D,IAAAA,EAAQxS,EAAMgU,mBAAqBhU,EAAMwS,MAAME,SAAW1S,EAAMwS,MAAMC,UAOxE+D,OAJehE,EAAMiE,KAAK,SAAA/B,GACpBA,OAAAA,EAAK9G,KAAKjN,MAAM4S,OAAOhC,EAAQ3D,KAAKhN,MAAQ8T,EAAK9G,KAAKhN,IAAI2S,OAAOhC,EAAQ3D,KAAKjN,QACnF+T,EAAK9G,KAAKjN,MAAM4S,OAAOhC,EAAQ3D,KAAKjN,QAAU+T,EAAK9G,KAAKhN,IAAI2S,OAAOhC,EAAQ3D,KAAKhN,OAErE,CAAO,GAAA,IAEvB4R,EAAMhP,QAAQ,SAAAkR,GAEZA,EAAKgC,sBAAsB1W,GAAOmD,KAAKoO,GAGvCA,EAAQiB,MAAME,SAASvP,KAAKuR,KAG9BlC,EAAMrP,KAAKoO,GACXA,EAAQiB,MAAME,SAASvP,KAAKnD,GAExB+V,IACFA,EAAUY,MAAQZ,EAAUY,OAAS,GACrCZ,EAAUY,MAAMxT,KAAK,IAAIzD,EAAJ,QAAU2C,EAAM1C,EAAG0C,EAAMzC,KAGhD,CAAO,GAAA,IAKPoW,GAAAA,EAAOC,SAAW,EAAG,CAErB1E,IAAAA,EAAAA,EAAQ3D,KAAKhN,IAAI2O,eAAevP,EAAM4N,KAAKjN,MAAOX,EAAM4N,KAAKhN,KADvDQ,EAAAA,EAAAA,UAAWC,EAAAA,EAAAA,YAAaC,EAAAA,EAAAA,UAAWvB,EAAAA,EAAAA,QAEvCqB,GAAAA,EAAY8I,EAAqBA,mBAAAA,EAAjC,oBAAuD5I,GAAa,GAAKA,GAAavB,EAAS,CAC3FsC,IAAAA,EAAQhB,EAMVqP,OALJsF,EAAOC,SAAW,EAClB1E,EAAQ3D,KAAKhN,IAAMyB,EACnBkP,EAAQY,OAAOoE,SAAU,EAGrB7F,EAAKhG,oBAAoB1K,EAAM6P,YAAa0B,EAAQ1B,aAAe1F,EAAvE,+BACE,CAAO,GAAA,IAGTnK,EAAMqH,MAAMhF,EAAOkP,EAAS0C,EAAUC,GAElC6B,IACFA,EAAUa,oBAAsBb,EAAUa,qBAAuB,GACjEb,EAAUa,oBAAoBzT,KAAK,IAAIzD,EAAJ,QAAU2C,EAAM1C,EAAG0C,EAAMzC,KAG9D,CAAO,GAAA,OA3FOsW,EAAAA,EAAS,OAAA,cAAA,GAAA,EAAA,EAAA,QAAA,MAAA,GAAA,EAAA,CAAA,IAAA,EAAA,IAAA,GAAA,WAAA,EAAA,GAAA,OAAA,EAAA,GAJ+B,MAAA,GAAA,GAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,MAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,MAAA,GAoGrD,OAAA,EAGT,SAASW,EAAYC,GACbC,IAAAA,EAAc,GAChB,IAACD,EAAgB3E,OAAOoE,QAAS,CAC7BS,IAAAA,EAAW,SAACnH,EAAW1P,EAAQ+R,EAAMC,GAAWF,OAAAA,EAAegF,QAAAA,eAAeH,EAAgBlJ,KAAKhN,IAAKiP,EAAW1P,EAAQ+R,EAAMC,IAGjI+E,EAAmB,SAACrH,GAAcmH,OAAAA,EAASnH,EAAWiH,EAAgB3W,SAAU,EAAG2W,EAAgB3E,SAEnGgF,EAAiB,SAACtH,GAAcmH,OAAAA,EAASnH,EAAWpG,EAAZ,uBAAoCqN,EAAgB3E,OAAOI,QAAUlI,EAAjC,sCAAyE,IAErJ+M,EAAmBF,EAAiBJ,EAAgBjH,aACpDwH,EAAc9J,EAAQ+J,QAAAA,UAAUF,EAAiBxJ,MAEnDkJ,GAAAA,EAAgB3E,OAAOI,QAAS,CAC5BgF,IAAAA,EAAiBL,EAAiBJ,EAAgBjH,YAAca,EAAK7F,YAAYhB,EAAjB,gBAChE2N,EAAYjK,EAAQ+J,QAAAA,UAAUC,EAAe3J,MAC7C6J,EAAUD,EAAYH,EAAcG,EAAYH,EAGlDI,GAFJV,EAAY5T,KAAKqU,EAAYH,EAAcE,EAAiBH,GAExDK,EAAUzN,EAAd,oCACMnK,GAAAA,KAAKoD,SAAW6G,EAApB,2BAAgD,CACxC4N,IAAAA,EAAoBR,EAAiBJ,EAAgBjH,YAAc,GAAKa,EAAK7F,YAAYjB,EAAjB,eAC9EmN,EAAY5T,KAAKuU,QACZ,GAAI7X,KAAKoD,SAAW6G,EAApB,2BAAgD,CAC/C6N,IAAAA,EAAqBT,EAAiBJ,EAAgBjH,YAAc,GAAKa,EAAK7F,YAAYjB,EAAjB,eAC/EmN,EAAY5T,KAAKwU,SAGZN,EAAcpN,EAAlB,oCACL8M,EAAY5T,KAAKiU,GAGfC,GAAAA,EAAcpN,EAAlB,mCACMpK,GAAAA,KAAKoD,SAAW8G,EAApB,2BAAgD,CACxC6N,IAAAA,EAAaT,EAAeL,EAAgBjH,YAAc,GAAKa,EAAK7F,YAAYjB,EAAjB,eACrEmN,EAAY5T,KAAKyU,QACZ,GAAI/X,KAAKoD,SAAW8G,EAApB,2BAAgD,CAC/C8N,IAAAA,EAAcV,EAAeL,EAAgBjH,YAAc,GAAKa,EAAK7F,YAAYjB,EAAjB,eACtEmN,EAAY5T,KAAK0U,IAKFd,IA3Ce,IAAA,EAAA,WA2CzBe,IAAAA,EAAUf,EAAhB,GACHe,EAAOC,iBAAmB,WAExBjB,EAAgBtE,MAAME,SAASlP,QAAQ,SAAAkR,GACrCoD,EAAOtF,MAAMC,UAAUtP,KAAKuR,GAC5BA,EAAKgC,sBAAsBI,GAAiB3T,KAAK2U,KAGnDhB,EAAgBtE,MAAME,SAASvP,KAAK2U,GACpCA,EAAOtF,MAAMC,UAAUtP,KAAK2T,KATXC,EAAAA,EAAAA,EAAAA,EAAa,OAAA,IAAA,IAa3BA,OAAAA,EAGF,SAASiB,EAASpM,GACjBmK,IAAAA,EAAY,GAElBtI,EAAM7B,KAAK/L,KAAKoD,UAEVgV,IAAAA,EAAQ,GACRC,EAAc,IAAI9F,EAAJ,QAAYxG,EAAM,IAAIlM,EAAJ,QAAUkM,EAAKjM,EAAI+J,EAAnB,uBAA2CkC,EAAKhM,GAAI,EAAG,CAAE2S,SAAS,IAClG4F,EAAoBlG,EAAemC,QAAAA,aAAa8D,GAChDE,EAAS,IAAI1Y,EAAJ,QAAUwY,EAAYtK,KAAKjN,MAAMhB,EAAI+J,EAArC,uBAA6DyO,EAAkBvK,KAAKhN,IAAIhB,GACvGuY,EAAkBvK,KAAK0G,OAAO8D,GAC9BD,EAAkB3F,MAAMC,UAAUtP,KAAK+U,GACvCA,EAAY1F,MAAMC,UAAUtP,KAAKgV,GACjCF,EAAM9U,KAAK+U,GACXD,EAAM9U,KAAKgV,GAQJF,IANDhE,IAAAA,EAAW,GAGXoE,EAAa,CAAE1Y,EAAGiM,EAAKjM,EAAGC,EAAGgM,EAAKhM,EAAGoC,MAAO0H,EAA/B,uBAAuDvH,OAAQuH,EAAAA,wBAC5EwK,EAAO,IAAIY,EAAJ,QAAauD,EAAY/N,EAAzB,qBAA+CC,EAA/C,qBAnBgB,EAAA,WAuBvB+N,IAAAA,EAAOL,EAAM,GAAG/F,KAChBqG,EAAS,EACbN,EAAMzU,QAAQ,SAAC+N,EAAS5N,GAClB4N,EAAQW,KAAOoG,IACjBA,EAAO/G,EAAQW,KACfqG,EAAS5U,KAIP6U,IAAAA,EAAaP,EAAMlQ,OAAOwQ,EAAQ,GAAG,GAC1BzC,EAAiB0C,EAAYvE,EAAUC,EAAM6B,KAExDyC,EAAWT,kBACbS,EAAWT,mBAEbS,EAAWnE,WAAWJ,EAAUC,GAChC2C,EAAY2B,GAAYhV,QAAQ,SAAA+N,GAC9BA,EAAQW,MAAQsG,EAAWtG,KAAO,EAClC+F,EAAM9U,KAAKoO,OApBV0G,EAAM9X,QAAU8T,EAAS9T,OAASwJ,EAAzC,qBAA8D,IA0BxCsK,IADlBwE,IAAAA,EAAK,EACaxE,EAAAA,EAAAA,EAAAA,EAAU,OAAA,IAAA,CAAVA,EAAjB,GACKwE,GAAKA,IAGRxE,OAAAA;;ACjOR,aATM,SAASyE,EAAYlW,EAAS+O,GACnC/O,EAAQE,YAAc6O,EAAQY,OAAOI,QAAU,UAAY,UAC3D/P,EAAQC,UAAY8O,EAAQvP,MAE5BQ,EAAQqD,YACRrD,EAAQsD,OAAOyL,EAAQ3D,KAAKjN,MAAMhB,EAAG4R,EAAQ3D,KAAKjN,MAAMf,GACxD4C,EAAQuD,OAAOwL,EAAQ3D,KAAKhN,IAAIjB,EAAG4R,EAAQ3D,KAAKhN,IAAIhB,GACpD4C,EAAQwD,YACRxD,EAAQyD,SACT,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,YAAA;;ACGD,aAZA,IAAA,EAAA,EAAA,QAAA,uBACA,EAAA,EAAA,QAAA,qBACA,EAAA,EAAA,QAAA,oBACA,EAAA,EAAA,QAAA,cASA,SAAA,EAAA,GAAA,GAAA,GAAA,EAAA,WAAA,OAAA,EAAA,IAAA,EAAA,GAAA,GAAA,MAAA,EAAA,IAAA,IAAA,KAAA,EAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,GAAA,CAAA,IAAA,EAAA,OAAA,gBAAA,OAAA,yBAAA,OAAA,yBAAA,EAAA,GAAA,GAAA,EAAA,KAAA,EAAA,IAAA,OAAA,eAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,OAAA,EAAA,QAAA,EAAA,EAAA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GANA,IAAMlE,EAASsC,SAASK,eAAe,UACjClC,EAAUT,EAAO4W,WAAW,MAClC5W,EAAOC,MAA4B,IAApB8B,OAAOiF,WACtBhH,EAAOI,OAAS2B,OAAOkF,YACvB4P,EAAYlQ,KAAK3G,EAAQS,GAEzB6B,SAASK,eAAe,YAAYoE,iBAAiB,QAAS,SAAAtC,GAC5DhE,EAAQqW,UAAU,EAAG,EAAG9W,EAAOC,MAAOD,EAAOI,QAEvCyJ,IAAAA,EAAO,IAAIlM,EAAJ,QAAUqC,EAAOC,MAAQ,EAAGD,EAAOI,OAAS,GACxC2W,EAAUd,SAASpM,GAC3BpI,QAAQ,SAAA+N,GAAWwH,OAAAA,EAAKL,YAAYlW,EAAS+O","file":"src.0dc3da7a.map","sourceRoot":"..","sourcesContent":["const EPSILON = 0.00000001;\n\nexport default class Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  length() {\n    return Math.sqrt(this.length2());\n  }\n\n  length2() {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  distance(other) {\n    const v = other.minus(this);\n    return v.length();\n  }\n\n  distance2(other) {\n    const v = other.minus(this);\n    return v.length2();\n  }\n\n  equals(other) {\n    const diff = this.minus(other);\n    return diff.length2() < EPSILON;\n  }\n\n  scalarMultiply(s) {\n    return new Point(this.x * s, this.y * s);\n  }\n\n  add(other) {\n    return new Point(this.x + other.x, this.y + other.y);\n  }\n\n  minus(other) {\n    return new Point(this.x - other.x, this.y - other.y);\n  }\n\n  dot(other) {\n    return this.x * other.x + this.y * other.y;\n  }\n\n  cross(other) {\n    return this.x * other.y - this.y * other.x;\n  }\n\n  angle(other) {\n    const radians = Math.acos(this.dot(other) / (this.length() * other.length()));\n    return radians * 180 / Math.PI;\n  }\n\n  project(other) {\n    return other.scalarMultiply(this.dot(other) / other.length2());\n  }\n\n  distanceToLine(start, end) {\n    const toStart = this.minus(start);\n    const line = end.minus(start);\n    const projected = toStart.project(line);\n    const result = start.add(projected);\n    const dot = toStart.dot(line);\n    const sign = dot < 0 ? -1 : dot > 0 ? 1 : 0;\n\n    return {\n      distance2: result.distance2(this),\n      pointOnLine: result,\n      // distance along line of projected point\n      lineProj2:  sign * projected.length2(),\n      length2: line.length2()\n    }\n  }\n}\n","export default class Circle {\n  constructor(x, y, d) {\n    this.x = x;\n    this.y = y;\n    this.r = d / 2;\n  }\n}\n","import Point from './Point.js';\n\nexport default class Polygon {\n  constructor(edges, color) {\n    this.edges = edges;\n    this.color = color;\n  }\n\n  /* Calculates the bounding box for a given Polygon. */\n  boundingBox(options) {\n    let minX = options.canvas.width, maxX = 0;\n    let minY = options.canvas.height, maxY = 0;\n    for (const point of this.edges) {\n      minX = point.x < minX ? point.x : minX;\n      maxX = point.x > maxX ? point.x : maxX;\n      minY = point.y < minY ? point.y : minY;\n      maxY = point.y > maxY ? point.y : maxY;\n    }\n    this.boundaries = [\n      new Point(minX, minY), // top left\n      new Point(maxX, minY), // top right\n      new Point(maxX, maxY), // bottom right\n      new Point(minX, maxY)  // bottom left\n    ];\n\n    // DEBUG MODE: draw bounding box\n    if (options.debugMode) {\n      options.context.lineWidth = 1;\n      options.context.strokeStyle = '#FF0000';\n      options.context.strokeRect(minX, minY, maxX - minX, maxY - minY);\n      options.context.lineWidth = options.currentSize;\n    }\n  }\n\n  /* Uses stratified sampling to scatter points within the Polygon for roads. */\n  scatterPoints(options) {\n    // we don't want to generate roads in parks or water\n    if (this.color === 'parks' || this.color === 'water') return;\n\n    const points = [];\n    // scatter points using stratified sampling within bounding box\n    const minX = this.boundaries[0].x, minY = this.boundaries[0].y;\n    const maxX = this.boundaries[1].x, maxY = this.boundaries[3].y;\n    for (let x = minX; x < maxX; x+=options.scale) {\n      for (let y = minY; y < maxY; y+=options.scale) {\n        // TODO: change scatter based on brush? (ex. less scatter on skyscrapers)\n        const offsetX = Math.min(x + Math.random() * options.scale, maxX);\n        const offsetY = Math.min(y + Math.random() * options.scale, maxY);\n        points.push(new Point(Math.round(offsetX), Math.round(offsetY)));\n      }\n    }\n\n    // DEBUG MODE: draw all of the stratified sampled points\n    if (options.debugMode) {\n      for (const point of points) {\n        options.context.fillStyle = '#000';\n        options.context.fillRect(point.x, point.y, 1, 1);\n      }\n    }\n\n    // map edge points y values to their x values\n    const edgesMap = {};\n    this.edges.forEach(point => {\n      if (edgesMap[point.y]) {\n        edgesMap[point.y].push(point.x);\n      } else {\n        edgesMap[point.y] = [point.x];\n      }\n    });\n\n    // starting at the point, go right and count the edges we hit\n    // TODO: handle when points cross tangent to the polygon\n    this.points = [];\n    points.forEach(point => {\n      // keep track of the last time we crossed the polygon's edge\n      let lastCrossing = 0;\n      let intersections = 0;\n      for (let i = point.x; i < maxX + 1; i++) {\n        if (edgesMap[point.y].includes(i)) {\n          // only count the intersection if the point isn't immediately next\n          if (i - lastCrossing > 1) intersections++;\n          lastCrossing = i;\n        }\n      }\n      // points are in the polygon if they hit an odd number of edges\n      if (intersections % 2 !== 0) this.points.push(point);\n    });\n\n    // DEBUG MODE: draw the points within the polygon in red\n    if (options.debugMode) {\n      for (const point of this.points) {\n        options.context.fillStyle = '#FF0000';\n        options.context.fillRect(point.x, point.y, 1, 1);\n      }\n    }\n  }\n}\n","import Point from './classes/Point.js';\nimport Circle from './classes/Circle.js';\nimport Polygon from './classes/Polygon.js';\n\nconst SUPPORTS_POINTER = 'PointerEvent' in window;\nconst SUPPORTS_TOUCH = 'ontouchstart' in window;\nconst options = {\n  drawing: false,\n  // create arrays to keep track of painting\n  xClicks: [],\n  yClicks: [],\n  dragClicks: [],\n  // brush parameters\n  currentBrush: document.querySelector('.active').classList[1],\n  lastBrush: document.querySelector('.active').classList[1],\n  currentSize: parseInt(document.getElementById('brush-size').value),\n  brushes: Array.prototype.slice.call(document.getElementsByClassName('brush')),\n  brushColors: {\n    skyscrapers: 'rgb(203,203,203)',\n    residential: 'rgb(252,139,148)',\n    commercial: 'rgb(191,140,190)',\n    water: 'rgb(180,207,226)',\n    parks: 'rgb(140,191,142)'\n  },\n  // data for storing canvas colors\n  clickData: { skyscrapers: [], residential: [], commercial: [], water: [], parks: [] },\n  innerPoints: { skyscrapers: [], residential: [], commercial: [], water: [], parks: [] },\n  polygons: [],\n  polygonIndex: 0,\n  // other parameters\n  debugMode: false,\n  scale: 20 // TODO: make this chooseable?\n}\n\n/* FUNCTIONS */\n\nfunction render() {\n  for (let i = 0; i < options.xClicks.length; i++) {\n    options.context.strokeStyle = options.brushColors[options.currentBrush];\n    options.context.lineWidth = options.currentSize;\n\n    options.context.beginPath();\n    if (options.dragClicks[i] && i > 0) {\n      options.context.moveTo(options.xClicks[i - 1], options.yClicks[i - 1]);\n    } else {\n      options.context.moveTo(options.xClicks[i] - 1, options.yClicks[i] - 1);\n    }\n\n    options.context.lineTo(options.xClicks[i], options.yClicks[i]);\n    options.context.closePath();\n    options.context.stroke();\n  }\n}\n\nfunction addClick(x, y, dragging) {\n  options.xClicks.push(x);\n  options.yClicks.push(y);\n  options.dragClicks.push(dragging);\n\n  // add to data for generation\n  options.clickData[options.currentBrush].push(new Circle(x, y, options.currentSize));\n}\n\nfunction clearActiveBrushes() {\n  options.brushes.forEach(brush => {\n    brush.classList.remove('active');\n  });\n}\n\nfunction onEventDown(event) {\n  const i = options.clickData[options.lastBrush].length - 1;\n  if (i > -1) options.polygons.push(detectEdges(options.clickData[options.lastBrush][i], options.lastBrush));\n\n  const mouseX = event.pageX - canvas.offsetLeft;\n  const mouseY = event.pageY - canvas.offsetTop;\n  options.drawing = true;\n  addClick(mouseX, mouseY);\n  render();\n}\n\nfunction onEventMove(event) {\n  if (options.drawing) {\n    addClick(event.pageX - canvas.offsetLeft, event.pageY - canvas.offsetTop, true);\n    render();\n  }\n}\n\nfunction onEventUp(event) {\n  options.drawing = false;\n  // clear clicks on up so we don't redraw anything\n  options.xClicks = [];\n  options.yClicks = [];\n  options.dragClicks = [];\n}\n\nfunction detectEdges(circle, color) {\n  const edges = [];\n  const rgb = options.brushColors[color].slice(4, -1).split(',');\n\n  // start at the rightmost pixel of the circle\n  let x = circle.x + circle.r - 1;\n  let y = circle.y;\n\n  // find the rightmost pixel of this color\n  // TODO: do this better\n  let currX = circle.x + circle.r - 1;\n  let n = options.context.getImageData(currX++, y, 1, 1).data;\n  while (n[0] == rgb[0] && n[1] == rgb[1] && n[2] == rgb[2]) {\n    x = currX;\n    n = options.context.getImageData(currX++, y, 1, 1).data;\n  }\n\n  const start = new Point(x - 1, y);\n\n  // recursive function to determine a polygon's edges\n  const addEdge = (point, prev) => {\n    const neighbors = [\n      new Point(point.x + 1, point.y    ),\n      new Point(point.x + 1, point.y + 1),\n      new Point(point.x,     point.y + 1),\n      new Point(point.x - 1, point.y + 1),\n      new Point(point.x - 1, point.y    ),\n      new Point(point.x - 1, point.y - 1),\n      new Point(point.x,     point.y - 1),\n      new Point(point.x + 1, point.y - 1)\n    ];\n\n    // order neighbors so that it starts right after prev\n    const prevIndex = neighbors.findIndex(p => p.x === prev.x && p.y === prev.y);\n    if (prevIndex < 7) {\n      for (let i = 0; i < prevIndex + 1; i++) {\n        neighbors.splice(7, 0, neighbors.shift());\n      }\n    }\n\n    // check if any of the eight surrounding pixels are a different color\n    const firstNot = neighbors.findIndex(p => {\n      const pixel = options.context.getImageData(p.x, p.y, 1, 1).data;\n      return Math.abs(pixel[0] - rgb[0]) > 5 ||\n             Math.abs(pixel[1] - rgb[1]) > 5 ||\n             Math.abs(pixel[2] - rgb[2]) > 5;\n    });\n\n    // find the first neighbor that is the same color and not the previous point\n    const firstSame = neighbors.findIndex(p => {\n      const pixel = options.context.getImageData(p.x, p.y, 1, 1).data;\n      return (p.x !== prev.x || p.y !== prev.y) &&\n        Math.abs(pixel[0] - rgb[0]) < 6 &&\n        Math.abs(pixel[1] - rgb[1]) < 6 &&\n        Math.abs(pixel[2] - rgb[2]) < 6;\n    });\n\n    if (firstNot !== -1) {\n      edges.push(new Point(point.x, point.y));\n      const next = neighbors[firstSame];\n      // continue until we reach the original starting point\n      if (next.x === start.x && next.y === start.y) return;\n      return addEdge(next, point);\n    }\n  }\n\n  addEdge(start, start);\n  return new Polygon(edges, color);\n}\n\nfunction interpretInput() {\n  // detect edges for the last click\n  const i = options.clickData[options.currentBrush].length - 1;\n  if (i > -1) options.polygons.push(detectEdges(options.clickData[options.currentBrush][i], options.currentBrush));\n\n  for (const polygon of options.polygons) {\n    polygon.boundingBox(options);\n    polygon.scatterPoints(options);\n  }\n}\n\nexport function init(canvas, context) {\n  /* SETUP */\n  context.lineJoin = 'round';\n  options.canvas = canvas;\n  options.context = context;\n\n  // brush logic\n  const brushSize = document.getElementById('brush-size');\n  const currentBrushSize = document.getElementById('current-brush-size');\n\n  /* EVENT LISTENERS */\n\n  // update the canvas size on window resize\n  window.addEventListener('resize', () => {\n    canvas.width = window.innerWidth * 0.85;\n    canvas.height = window.innerHeight;\n    render();\n  });\n\n  if (SUPPORTS_POINTER) {\n    canvas.addEventListener('pointerdown', event => { onEventDown(event) });\n    canvas.addEventListener('pointermove', event => { onEventMove(event) });\n    canvas.addEventListener('pointerup', event => { onEventUp(event) });\n    canvas.addEventListener('pointercancel', event => { onEventUp(event) });\n  } else if (SUPPORTS_TOUCH) {\n    canvas.addEventListener('touchstart', event => { onEventDown(event) });\n    canvas.addEventListener('touchmove', event => { onEventMove(event) });\n    canvas.addEventListener('touchend', event => { onEventUp(event) });\n    canvas.addEventListener('touchcancel', event => { onEventUp(event) });\n  } else {\n    canvas.addEventListener('mousedown', event => { onEventDown(event) });\n    canvas.addEventListener('mousemove', event => { onEventMove(event) });\n    canvas.addEventListener('mouseup', event => { onEventUp(event) });\n    canvas.addEventListener('mouseleave', event => { onEventUp(event) });\n  }\n\n  options.brushes.forEach(brush => {\n    brush.addEventListener('click', () => {\n      clearActiveBrushes();\n      options.lastBrush = options.currentBrush;\n      options.currentBrush = brush.classList[1];\n      brush.classList.add('active');\n    });\n  });\n\n  brushSize.addEventListener('input', event => {\n    options.currentSize = parseInt(brushSize.value);\n    currentBrushSize.innerText = brushSize.value;\n  });\n\n  document.getElementById('debug').addEventListener('change', event => {\n    options.debugMode = event.target.checked;\n    document.getElementById('debug-controls').style.display = options.debugMode ? 'block' : 'none';\n  });\n\n  document.getElementById('edges').addEventListener('click', event => {\n    // DEBUG MODE: draw edge outlines\n    for (const polygon of options.polygons) {\n      for (const point of polygon.edges) {\n        context.fillStyle = '#000';\n        context.fillRect(point.x, point.y, 1, 1);\n      }\n    }\n  });\n\n  document.getElementById('analyze').addEventListener('click', event => {\n    // DEBUG MODE: draw bounding boxes and scatter points\n    interpretInput();\n    event.target.disabled = true;\n    event.target.classList.add('disabled');\n  });\n}\n","export const DEFAULT_SEGMENT_WIDTH = 1;\nexport const HIGHWAY_SEGMENT_WIDTH = 2;\nexport const DEFAULT_SEGMENT_LENGTH = 25;\nexport const HIGHWAY_SEGMENT_LENGTH = 30;\nexport const SEGMENT_COUNT_LIMIT = 500;\n\nexport const BRANCH_ANGLE = 3; // in degrees\nexport const FORWARD_ANGLE = 10; // in degrees\n\nexport const HIGHWAY_BRANCH_PROBABILITY = 0.05;\nexport const DEFAULT_BRANCH_PROBABILITY = 0.4;\n\nexport const HIGHWAY_BRANCH_POPULATION_THRESHOLD = 0.1;\nexport const NORMAL_BRANCH_POPULATION_THRESHOLD = 0.1;\n\nexport const ROAD_SNAP_DISTANCE = 5;\nexport const MINIMUM_INTERSECTION_DEVIATION = 30; // in degrees\n\nexport const MIN_SPEED_PROPORTION = 0.1;\nexport const NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY = 5;\n\nexport const QUADTREE_MAX_OBJECTS = 10;\nexport const QUADTREE_MAX_LEVELS = 10;\n","function randomRange(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nexport function minDegreeDifference(a, b) {\n  const diff = Math.abs(a - b) % 180;\n  return Math.min(diff, Math.abs(diff - 180));\n}\n\nexport function randomAngle(limit) {\n  const nonUniformNorm = Math.pow(Math.abs(limit), 3);\n  let value = 0;\n  while (value === 0 || Math.random() < Math.pow(Math.abs(value), 3) / nonUniformNorm) {\n    value = randomRange(-limit, limit);\n  }\n  return value;\n}\n\nexport function minAndIndex(array) {\n  let min = array[0];\n  let min_i = 0;\n  array.forEach((entry, i) => {\n    if (entry < min) {\n      min = entry;\n      min_i = i;\n    }\n  });\n  return [min, min_i];\n}\n\nexport function maxAndIndex(array) {\n  let max = array[0];\n  let max_i = 0;\n  array.forEach((entry, i) => {\n    if (entry > max) {\n      max = entry;\n      max_i = i;\n    }\n  });\n  return [max, max_i];\n}\n","/*\n * Adapted from https://github.com/josephg/noisejs\n */\n\nclass Grad {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  dot2(x, y) {\n    return this.x * x + this.y * y;\n  }\n}\n\nconst grad3 = [\n  new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),\n  new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),\n  new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)\n];\n\nconst p = [151,160,137,91,90,15,\n131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\nconst perm = new Array(512);\nconst gradP = new Array(512);\n\nexport function seed(seed) {\n  if (seed > 0 && seed < 1) {\n    // Scale the seed out\n    seed *= 65536;\n  }\n\n  seed = Math.floor(seed);\n  if (seed < 256) {\n    seed |= seed << 8;\n  }\n\n  for (let i = 0; i < 256; i++) {\n    const v = i & 1 ? p[i] ^ (seed & 255) : p[i] ^ ((seed>>8) & 255);\n    perm[i] = perm[i + 256] = v;\n    gradP[i] = gradP[i + 256] = grad3[v % 12];\n  }\n}\n\nseed(0);\n\n// Skewing and unskewing factors for 2, 3, and 4 dimensions\nconst F2 = 0.5 * (Math.sqrt(3) - 1);\nconst G2 = (3 - Math.sqrt(3)) / 6;\n\nconst F3 = 1 / 3;\nconst G3 = 1 / 6;\n\n// 2D simplex noise\nexport function simplex2(xin, yin) {\n  let n0, n1, n2; // Noise contributions from the three corners\n  // Skew the input space to determine which simplex cell we're in\n  const s = (xin + yin) * F2; // Hairy factor for 2D\n  let i = Math.floor(xin + s);\n  let j = Math.floor(yin + s);\n  const t = (i + j) * G2;\n  const x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n  const y0 = yin - j + t;\n  // For the 2D case, the simplex shape is an equilateral triangle.\n  // Determine which simplex we are in.\n  // Offsets for second (middle) corner of simplex in (i,j) coords\n  const i1 = x0 > y0 ? 1 : 0;\n  const j1 = x0 > y0 ? 0 : 1;\n  // x0 > y0 is lower triangle, XY order: (0,0)->(1,0)->(1,1)\n  // otherwise is upper triangle, YX order: (0,0)->(0,1)->(1,1)\n  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n  // c = (3-sqrt(3))/6\n  const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n  const y1 = y0 - j1 + G2;\n  const x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n  const y2 = y0 - 1 + 2 * G2;\n  // Work out the hashed gradient indices of the three simplex corners\n  i &= 255;\n  j &= 255;\n  const gi0 = gradP[i + perm[j]];\n  const gi1 = gradP[i + i1 + perm[j + j1]];\n  const gi2 = gradP[i + 1 + perm[j + 1]];\n  // Calculate the contribution from the three corners\n  let t0 = 0.5 - x0 * x0 - y0 * y0;\n  if (t0 < 0) {\n    n0 = 0;\n  } else {\n    t0 *= t0;\n    n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\n  }\n  let t1 = 0.5 - x1 * x1 - y1 * y1;\n  if(t1 < 0) {\n    n1 = 0;\n  } else {\n    t1 *= t1;\n    n1 = t1 * t1 * gi1.dot2(x1, y1);\n  }\n  let t2 = 0.5 - x2 * x2 - y2 * y2;\n  if (t2 < 0) {\n    n2 = 0;\n  } else {\n    t2 *= t2;\n    n2 = t2 * t2 * gi2.dot2(x2, y2);\n  }\n  // Add contributions from each corner to get the final noise value.\n  // The result is scaled to return values in the interval [-1,1].\n  return 70 * (n0 + n1 + n2);\n}\n","import * as noise from './../perlin.js';\n\nexport default class Heatmap {\n  static populationAt(x, y) {\n    const one = (noise.simplex2(x / 500, y / 500) + 1) / 2;\n    const two = (noise.simplex2(x / 1000 + 50, y / 1000 + 50) + 1) / 2;\n    const three = (noise.simplex2(x / 1000 + 100, y / 1000 + 100) + 1) / 2;\n    return Math.pow((one * two + three) / 2, 2);\n  }\n\n  static popOnRoad(road) {\n    return (Heatmap.populationAt(road.start.x, road.start.y) + Heatmap.populationAt(road.end.x, road.end.y)) / 2;\n  }\n}\n","import Point from './Point.js';\n\nexport default class Collision {\n  static get Type() {\n    return { RECT: 'rect', LINE: 'line', CIRCLE: 'circle' };\n  }\n\n  constructor(object, type, properties) {\n    this.object = object;\n    this.type = type;\n    this.properties = properties;\n    this.collisionRevision = 0;\n    this.limitsRevision = undefined;\n    this.cachedLimits = undefined;\n  }\n\n  updateCollisionProperties(properties) {\n    this.collisionRevision++;\n    for (const prop in properties) {\n      this.properties[prop] = properties[prop];\n    }\n  }\n\n  minCorner(axis) {\n    let minCorner = this.properties.corners[0];\n    this.properties.corners.forEach(corner => {\n      if (corner[axis] < minCorner[axis]) minCorner = corner;\n    });\n    return minCorner;\n  }\n\n  maxCorner(axis) {\n    let maxCorner = this.properties.corners[0];\n    this.properties.corners.forEach(corner => {\n      if (corner[axis] > maxCorner[axis]) maxCorner = corner;\n    });\n    return maxCorner;\n  }\n\n  limits() {\n    if (this.collisionRevision !== this.limitsRevision) {\n      this.limitsRevision = this.collisionRevision;\n      if (this.type === Collision.Type.RECT) {\n        minX = this.minCorner('x').x;\n        minY = this.minCorner('y').y;\n        this.cachedLimits = {\n          x: minX,\n          y: minY,\n          width: this.maxCorner('x').x - minX,\n          height: this.maxCorner('y').y - minY,\n          object: this.object\n        }\n      } else if (this.type === Collision.Type.LINE) {\n        this.cachedLimits = {\n          x: Math.min(this.properties.start.x, this.properties.end.x),\n          y: Math.min(this.properties.start.y, this.properties.end.y),\n          width: Math.abs(this.properties.start.x - this.properties.end.x),\n          height: Math.abs(this.properties.start.y - this.properties.end.y),\n          object: this.object\n        }\n      } else if (this.type === Collision.Type.CIRCLE) {\n        this.cachedLimits = {\n          x: this.properties.center.x - this.properties.radius,\n          y: this.properties.center.y - this.properties.radius,\n          width: this.properties.radius * 2,\n          height: this.properties.radius * 2,\n          object: this.object\n        }\n      }\n    }\n    return this.cachedLimits;\n  }\n\n  collide(other) {\n    // avoid expensive collision check if possible\n    const limits = this.limits();\n    const otherLimits = other.limits();\n    if (limits && otherLimits &&\n        (limits.x + limits.width < otherLimits.x || otherLimits.x + otherLimits.width < limits.x) &&\n        (limits.y + limits.height < otherLimits.y || otherLimits.y + otherLimits.height < limits.y)) {\n      return false;\n    }\n\n    if (this.type === Collision.Type.CIRCLE) {\n      if (other.type === Collision.Type.RECT) {\n        other.rectCircleCollision(this);\n      }\n    } else if (this.type === Collision.Type.RECT) {\n      if (other.type !== Collision.Type.CIRCLE) {\n        this.rectRectIntersection(other);\n      } else {\n        this.rectCircleCollision(other);\n      }\n    } else if (this.type === Collision.Type.LINE) {\n      if (other.type !== Collision.Type.CIRCLE) {\n        this.rectRectIntersection(other);\n      }\n    }\n  }\n\n  rectCircleCollision(circle) {\n    // this must be a rectangle or line to call this function\n    if (this.type === Collision.Type.CIRCLE) return;\n    // other must be a circle to call this function\n    if (circle.type !== Collision.Type.CIRCLE) return;\n\n    // get the correct properties\n    const properties = this.type === Collision.Type.LINE ? this.rectPropsFromLine() : this.properties;\n    const corners = properties.corners;\n    const radius = circle.properties.radius;\n\n    // check for corner intersections with circle\n    for (const corner of corners) {\n      if (corner.distance2(circle.properties.center) <= radius * radius) {\n        return true;\n      }\n\n      // check for edge intersections with circle\n      for (let i = 0; i < corners.length; i++) {\n        const start = corners[i];\n        const end = corners[(i + 1) % corners.length];\n        const {distance2, pointOnLine, lineProj2, length2} = circle.properties.center.distanceToLine(start, end);\n        if (lineProj2 > 0 && lineProj2 < length2 && distance2 <= radius * radius) {\n          return true;\n        }\n      }\n\n      // check that the circle is not enclosed by the rectangle\n      const axes = [corners[3].minus(corners[0]), corners[3].minus(corners[2])];\n      const center0 = circle.properties.center.minus(corners[0]);\n      const center2 = circle.properties.center.minus(corners[2]);\n      const projections = [center0.project(axes[0]), center2.project(axes[1])];\n      const dots = [center0.dot(axes[0]), center2.dot(axes[1])];\n      if (dots[0] < 0 || projections[0].length2() > axes[0].length2() ||\n          dots[1] < 0 || projections[1].length2() > axes[1].length2()) {\n        return false;\n      }\n      return true;\n    }\n  }\n\n  rectPropsFromLine() {\n    // this must be a line to call this function\n    if (this.type !== Collision.Type.LINE) return;\n\n    const direction = this.properties.end.minus(this.properties.start);\n    const perpendicular = new Point(-direction.y, direction.x);\n    const halfWidth = perpendicular.scalarMultiply(0.5 * this.properties.width / perpendicular.length());\n    return {\n      corners: [\n        this.properties.start.add(halfWidth),\n        this.properties.start.minus(halfWidth),\n        this.properties.end.minus(halfWidth),\n        this.properties.end.add(halfWidth)\n      ]\n    }\n  }\n\n  rectRectIntersection(rect) {\n    // this must be a rectangle or line to call this function\n    if (this.type === Collision.Type.CIRCLE) return;\n    // other must be a rectangle or line to call this function\n    if (rect.type === Collision.Type.CIRCLE) return;\n\n    const cornersA = this.type === Collision.Type.LINE ? this.rectPropsFromLine().corners : this.properties.corners;\n    const cornersB = rect.type === Collision.Type.LINE ? rect.rectPropsFromLine().corners : rect.properties.corners;\n    const axes = [\n      cornersA[3].minus(cornersA[0]),\n      cornersA[3].minus(cornersA[2]),\n      cornersB[0].minus(cornersB[1]),\n      cornersB[0].minus(cornersB[3])\n    ]\n\n    // find axes with overlaps\n    const overlaps = [];\n    for (const axis of axes) {\n      const projectionsA = cornersA.map(corner => corner.project(axis));\n      const projectionsB = cornersB.map(corner => corner.project(axis));\n\n      const positionsA = projectionsA.map(vector => vector.dot(axis));\n      const positionsB = projectionsB.map(vector => vector.dot(axis));\n\n      const [maxA, maxA_i] = util.maxAndIndex(positionsA);\n      const [minA, minA_i] = util.minAndIndex(positionsA);\n      const [maxB, maxB_i] = util.maxAndIndex(positionsB);\n      const [minB, minB_i] = util.minAndIndex(positionsB);\n\n      // if the rectangles don't overlaps on at least one axis, they don't collide\n      if (maxA < minB || maxB < minA) {\n        return false;\n      } else {\n        // calculate the overlap between the rectangles on this axis\n        const maxAminB = projectionsA[maxA_i].minus(projectionsB[minB_i]);\n        const maxBminA = projectionsB[maxB_i].minus(projectionsA[minA_i]);\n        if (maxAminB.length2() < maxBminA.length2()) overlaps.push(maxAminB);\n        // the rectangles overlap on the other side, so invert the vector\n        else overlaps.push(maxBminA.scalarMultiply(-1));\n      }\n    }\n\n    // find axis with the least overlap\n    let minVector = overlaps[0];\n    overlaps.forEach(vector => {\n      if (vector.length2() < minVector.length2()) minVector = vector;\n    });\n\n    // return displacement required to remove the rectangle from the collision\n    return minVector.scalarMultiply(-1);\n  }\n}\n","import Point from './Point.js';\n\nexport default class Road {\n  constructor(start, end, segment) {\n    this.start = start;\n    this.end = end;\n    this.segment = segment;\n  }\n\n  setStart(start) {\n    this.start = start;\n    this.segment.collider.updateCollisionProperties({ start: start });\n    this.segment.roadRevision++;\n  }\n\n  setEnd(end) {\n    this.end = end;\n    this.segment.collider.updateCollisionProperties({ end: end });\n    this.segment.roadRevision++;\n  }\n\n  intersects(other) {\n    const r = this.end.minus(this.start);\n    const s = other.end.minus(other.start);\n    const starts = other.start.minus(this.start);\n\n    const numerator = starts.cross(r);\n    const denominator = r.cross(s);\n\n    if (denominator === 0 || numerator === 0) return false;\n\n    const u = numerator / denominator;\n    const t = starts.cross(s) / denominator;\n    const epsilon = 0.001;\n    const intersect = t > epsilon && t < 1 - epsilon && u > epsilon && u < 1 - epsilon;\n    return intersect ? new Point(this.start.x + t * r.x, this.start.y + t * r.y) : intersect;\n  }\n}\n","import Segment from './Segment.js';\nimport Point from './Point.js';\n\nexport default class SegmentFactory {\n  static fromExisting(segment, time, road, params) {\n    time = time || segment.time;\n    road = road || segment.road;\n    params = params || segment.params;\n    return new Segment(road.start, road.end, time, params);\n  }\n\n  static usingDirection(start, direction = 90, length = DEFAULT_SEGMENT_LENGTH, time = 0, params = {}) {\n    // convert direction to radians\n    direction *= Math.PI / 180;\n    const x = start.x + length * Math.sin(direction);\n    const y = start.y + length * Math.cos(direction);\n    return new Segment(start, new Point(x, y), time, params);\n  }\n}\n","import { DEFAULT_SEGMENT_WIDTH,\n         HIGHWAY_SEGMENT_WIDTH,\n         MIN_SPEED_PROPORTION } from './../config.js';\n\nimport Collision from './Collision.js';\nimport Road from './Road.js';\nimport Point from './Point.js';\nimport SegmentFactory from './SegmentFactory.js';\n\nexport default class Segment {\n  static get End() {\n    return { START: 'start', END: 'end' };\n  }\n\n  constructor(start, end, time = 0, params = {}) {\n    this.start = start;\n    this.end = end;\n    this.time = time;\n    this.params = params;\n\n    this.width = params.highway ? HIGHWAY_SEGMENT_WIDTH : DEFAULT_SEGMENT_WIDTH;\n    this.collider = new Collision(this, Collision.Type.LINE, {start: start, end: end, width: this.width});\n\n    this.roadRevision = 0;\n    this.road = new Road(start, end, this);\n\n    // time-step delay before this road is evaluated\n    this.time = time;\n    // meta-information relevant to global goals\n    this.params = params;\n\n    this.links = { backwards: [], forwards: [] };\n\n    this.users = [];\n    this.maxSpeed = params.highway ? 1200 : 800;\n    this.capacity = params.highway ? 12 : 6;\n  }\n\n  currentSpeed() {\n    return Math.min(MIN_SPEED_PROPORTION, 1 - Math.max(0, this.users.length - 1) / this.capacity) * this.maxSpeed;\n  }\n\n  direction() {\n    if (this.directionRevision !== this.roadRevision) {\n      this.directionRevision = this.roadRevision;\n      const vertical = new Point(0, 1);\n      const vector = this.road.end.minus(this.road.start);\n      const cross = vertical.cross(vector);\n      // we want the opposite of the cross sign\n      const sign = cross > 0 ? -1 : cross < 0 ? 1 : 0;\n      this.cachedDirection = sign * vertical.angle(vector);\n    }\n    return this.cachedDirection;\n  }\n\n  length() {\n    if (this.lengthRevision !== this.roadRevision) {\n      this.lengthRevision = this.roadRevision;\n      this.cachedLength = this.road.start.distance(this.road.end);\n    }\n    return this.cachedLength;\n  }\n\n  startIsBackwards() {\n    if (this.links.backwards.length) {\n      return this.links.backwards[0].road.start.equals(this.road.start) ||\n             this.links.backwards[0].road.end.equals(this.road.start);\n    } else {\n      return this.links.forwards[0].road.start.equals(this.road.end) ||\n             this.links.forwards[0].road.end.equals(this.road.end);\n    }\n  }\n\n  cost() {\n    return this.length() / this.currentSpeed();\n  }\n\n  costTo(other, fromFraction) {\n    const segmentEnd = this.endContaining(other);\n    const fraction = fromFraction ? (segmentEnd === Segment.End.START ? fromFraction : 1 - fromFraction) : 0.5;\n    return this.cost() * fraction;\n  }\n\n  neighbors() {\n    return this.links.forwards.concat(this.links.backwards);\n  }\n\n  endContaining(segment) {\n    const backwards = this.startIsBackwards();\n    if (this.links.backwards.includes(segment)) {\n      return backwards ? Segment.End.START : Segment.End.END;\n    } else if (this.links.forwards.includes(segment)) {\n      return backwards ? Segment.End.END : Segment.End.START;\n    }\n  }\n\n  linksForEndContaining(segment) {\n    if (this.links.backwards.includes(segment)) return this.links.backwards;\n    else if (this.links.forwards.includes(segment)) return this.links.forwards;\n  }\n\n  split(point, segment, segments, tree) {\n    const backwards = this.startIsBackwards();\n\n    const splitPart = SegmentFactory.fromExisting(this);\n    splitPart.addSegment(segments, tree);\n    splitPart.road.setEnd(point);\n    this.road.setStart(point);\n\n    splitPart.links.backwards = this.links.backwards.slice(0);\n    splitPart.links.forwards = this.links.forwards.slice(0);\n\n    // determine which links correspond to which end of the split segment\n    const firstSplit = backwards ? splitPart : this;\n    const secondSplit = backwards ? this : splitPart;\n    const fixLinks = backwards ? splitPart.links.backwards : splitPart.links.forwards;\n\n    fixLinks.forEach(link => {\n      let index = link.links.backwards.indexOf(this);\n      if (index !== -1) {\n        link.links.backwards[index] = splitPart;\n      } else {\n        index = link.links.forwards.indexOf(this);\n        link.links.forwards[index] = splitPart;\n      }\n    });\n\n    firstSplit.links.forwards = [segment, secondSplit];\n    secondSplit.links.backwards = [segment, firstSplit];\n\n    segment.links.forwards.push(firstSplit);\n    segment.links.forwards.push(secondSplit);\n  }\n\n  addSegment(segments, tree) {\n    segments.push(this);\n    tree.insert(this.collider.limits());\n  }\n}\n","export default class QuadTree {\n  constructor(bounds, maxObjects = 10, maxLevels = 4, level = 0) {\n    this.bounds = bounds;\n    this.maxObjects = maxObjects;\n    this.maxLevels = maxLevels;\n    this.level = level;\n\n    this.objects = [];\n    this.nodes = [];\n  }\n\n  subdivide() {\n    const width = Math.round(this.bounds.width / 2);\n    const height = Math.round(this.bounds.height / 2);\n    const x = Math.round(this.bounds.x);\n    const y = Math.round(this.bounds.y);\n\n    // top right node\n    this.nodes[0] = new QuadTree({\n      x: x + width,\n      y: y,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n\n    // top left node\n    this.nodes[1] = new QuadTree({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n\n    // bottom left node\n    this.nodes[2] = new QuadTree({\n      x: x,\n      y: y + height,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n\n    // bottom right node\n    this.nodes[3] = new QuadTree({\n      x: x + width,\n      y: y + height,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n  }\n\n  // determines which node the given rectangle is in\n  getIndex(rect) {\n    let index = -1;\n    const midpointX = this.bounds.x + this.bounds.width / 2;\n    const midpointY = this.bounds.y + this.bounds.height / 2;\n\n    const top = rect.y < midpointY && rect.y + rect.height < midpointY;\n    const bottom = rect.y > midpointY;\n\n    if (rect.x < midpointX && rect.x + rect.width < midpointX) {\n      index = top ? 1 : bottom ? 2 : index;\n    } else if (rect.x > midpointX) {\n      index = top ? 0 : bottom ? 3 : index;\n    }\n    return index;\n  }\n\n  insert(rect) {\n    if (this.nodes.length) {\n      const i = this.getIndex(rect);\n      if (i !== -1) return this.nodes[i].insert(rect);\n    }\n\n    this.objects.push(rect);\n\n    if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {\n      if (this.nodes.length === 0) this.subdivide();\n\n      let i = 0;\n      while (i < this.objects.length) {\n        const index = this.getIndex(this.objects[i]);\n        if (index !== -1) this.nodes[index].insert(this.objects.splice(i, 1)[0]);\n        else i++;\n      }\n    }\n  }\n\n  // returns all objects that collide with the given object\n  retrieve(rect) {\n    const index = this.getIndex(rect);\n    let objects = this.objects;\n\n    if (this.nodes.length) {\n      if (index !== -1) {\n        objects = objects.concat(this.nodes[index].retrieve(rect));\n      } else {\n        // check against all subnodes\n        for (const node of this.nodes) {\n          objects = objects.concat(node.retrieve(rect));\n        }\n      }\n    }\n    return objects;\n  }\n\n  clear() {\n    this.objects = [];\n    for (const node of this.nodes) {\n      node.clear();\n    }\n  }\n}\n","import { ROAD_SNAP_DISTANCE,\n         MINIMUM_INTERSECTION_DEVIATION,\n         DEFAULT_SEGMENT_LENGTH,\n         HIGHWAY_SEGMENT_LENGTH,\n         NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY,\n         BRANCH_ANGLE, FORWARD_ANGLE,\n         HIGHWAY_BRANCH_POPULATION_THRESHOLD,\n         NORMAL_BRANCH_POPULATION_THRESHOLD,\n         HIGHWAY_BRANCH_PROBABILITY,\n         DEFAULT_BRANCH_PROBABILITY,\n         QUADTREE_PARAMS, QUADTREE_MAX_OBJECTS, QUADTREE_MAX_LEVELS,\n         SEGMENT_COUNT_LIMIT } from './config.js';\nimport * as util from './util.js';\nimport * as noise from './perlin.js';\n\nimport Point from './classes/Point.js';\nimport Heatmap from './classes/Heatmap.js';\nimport Segment from './classes/Segment.js';\nimport QuadTree from './classes/QuadTree.js';\nimport SegmentFactory from './classes/SegmentFactory.js';\n\nfunction localConstraints(segment, segments, tree, debugData) {\n  const action = { priority: 0, params: {} };\n\n  const matches = tree.retrieve(segment.collider.limits());\n  for (const match of matches) {\n    const other = match.object;\n\n    // intersection check\n    if (action.priority < 5) {\n      const intersection = segment.road.intersects(other.road);\n      if (intersection) {\n        if (!action.params.time || intersection.time < actions.params.time) {\n          action.params.time = intersection.time;\n          action.priority = 4;\n          // if intersecting lines are too similar don't continue\n          if (util.minDegreeDifference(other.direction(), segment.direction()) < MINIMUM_INTERSECTION_DEVIATION) {\n            return false;\n          }\n\n          other.split(intersection, segment, segments, tree);\n          segment.road.end = intersection;\n          segment.params.severed = true;\n\n          if (debugData) {\n            debugData.intersections = debugData.intersections || [];\n            debugData.intersections.push(new Point(intersection.x, intersection.y));\n          }\n\n          return true;\n        }\n      }\n    }\n\n    // snap to crossing within radius check\n    if (action.priority < 4) {\n      // current segment's start must have been checked to have been created\n      // other segment's start must have a corresponding end\n      if (segment.road.end.distance(other.road.end) <= ROAD_SNAP_DISTANCE) {\n        const point = other.road.end;\n        action.priority = 3;\n        segment.road.end = point;\n        segment.params.severed = true;\n\n        // update other's links corresponding to other.road.end\n        const links = other.startIsBackwards() ? other.links.forwards : other.links.backwards;\n\n        // check for duplicate lines, don't add if it exists\n        const duplicates = links.some(link => {\n          return (link.road.start.equals(segment.road.end) && link.road.end.equals(segment.road.start)) ||\n            (link.road.start.equals(segment.road.start) && link.road.end.equals(segment.road.end));\n        });\n        if (duplicates) return false;\n\n        links.forEach(link => {\n          // pick links of remaining segments at junction corresponding to other.road.end\n          link.linksForEndContaining(other).push(segment);\n\n          // add junction segments to snapped segment\n          segment.links.forwards.push(link);\n        });\n\n        links.push(segment);\n        segment.links.forwards.push(other);\n\n        if (debugData) {\n          debugData.snaps = debugData.snaps || [];\n          debugData.snaps.push(new Point(point.x, point.y));\n        }\n\n        return true;\n      }\n    }\n\n    // intersection with radius check\n    if (action.priority < 3) {\n      const { distance2, pointOnLine, lineProj2, length2 } =\n        segment.road.end.distanceToLine(other.road.start, other.road.end);\n      if (distance2 < ROAD_SNAP_DISTANCE * ROAD_SNAP_DISTANCE && lineProj2 >= 0 && lineProj2 <= length2) {\n        const point = pointOnLine;\n        action.priority = 2;\n        segment.road.end = point;\n        segment.params.severed = true;\n\n        // if intersecting lines are too similar don't continue\n        if (util.minDegreeDifference(other.direction(), segment.direction()) < MINIMUM_INTERSECTION_DEVIATION) {\n          return false;\n        }\n\n        other.split(point, segment, segments, tree);\n\n        if (debugData) {\n          debugData.intersectionsRadius = debugData.intersectionsRadius || [];\n          debugData.intersectionsRadius.push(new Point(point.x, point.y));\n        }\n\n        return true;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction globalGoals(previousSegment) {\n  const newBranches = [];\n  if (!previousSegment.params.severed) {\n    const template = (direction, length, time, params) => SegmentFactory.usingDirection(previousSegment.road.end, direction, length, time, params);\n\n    // used for highways or going straight on a normal branch\n    const templateContinue = (direction) => template(direction, previousSegment.length(), 0, previousSegment.params);\n    // not using params, i.e. not highways\n    const templateBranch = (direction) => template(direction, DEFAULT_SEGMENT_LENGTH, previousSegment.params.highway ? NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY : 0);\n\n    const continueStraight = templateContinue(previousSegment.direction());\n    const straightPop = Heatmap.popOnRoad(continueStraight.road);\n\n    if (previousSegment.params.highway) {\n      const randomStraight = templateContinue(previousSegment.direction() + util.randomAngle(FORWARD_ANGLE));\n      const randomPop = Heatmap.popOnRoad(randomStraight.road);\n      const roadPop = randomPop > straightPop ? randomPop : straightPop;\n      newBranches.push(randomPop > straightPop ? randomStraight : continueStraight);\n\n      if (roadPop > HIGHWAY_BRANCH_POPULATION_THRESHOLD) {\n        if (Math.random() < HIGHWAY_BRANCH_PROBABILITY) {\n          const leftHighwayBranch = templateContinue(previousSegment.direction() - 90 + util.randomAngle(BRANCH_ANGLE));\n          newBranches.push(leftHighwayBranch);\n        } else if (Math.random() < HIGHWAY_BRANCH_PROBABILITY) {\n          const rightHighwayBranch = templateContinue(previousSegment.direction() + 90 + util.randomAngle(BRANCH_ANGLE));\n          newBranches.push(rightHighwayBranch);\n        }\n      }\n    } else if (straightPop > NORMAL_BRANCH_POPULATION_THRESHOLD) {\n      newBranches.push(continueStraight);\n    }\n\n    if (straightPop > NORMAL_BRANCH_POPULATION_THRESHOLD) {\n      if (Math.random() < DEFAULT_BRANCH_PROBABILITY) {\n        const leftBranch = templateBranch(previousSegment.direction() - 90 + util.randomAngle(BRANCH_ANGLE));\n        newBranches.push(leftBranch);\n      } else if (Math.random() < DEFAULT_BRANCH_PROBABILITY) {\n        const rightBranch = templateBranch(previousSegment.direction() + 90 + util.randomAngle(BRANCH_ANGLE));\n        newBranches.push(rightBranch);\n      }\n    }\n  }\n\n  for (const branch of newBranches) {\n    branch.setUpBranchLinks = () => {\n      // set up links between each current branch and each existing branch stemming from the previous segment\n      previousSegment.links.forwards.forEach(link => {\n        branch.links.backwards.push(link);\n        link.linksForEndContaining(previousSegment).push(branch);\n      });\n\n      previousSegment.links.forwards.push(branch);\n      branch.links.backwards.push(previousSegment);\n    }\n  }\n\n  return newBranches;\n}\n\nexport function generate(seed) {\n  const debugData = {};\n  // TODO: change this to use seed data from user input\n  noise.seed(Math.random());\n\n  const queue = [];\n  const rootSegment = new Segment(seed, new Point(seed.x + HIGHWAY_SEGMENT_LENGTH, seed.y), 0, { highway: true });\n  const oppositeDirection = SegmentFactory.fromExisting(rootSegment);\n  const newEnd = new Point(rootSegment.road.start.x - HIGHWAY_SEGMENT_LENGTH, oppositeDirection.road.end.y);\n  oppositeDirection.road.setEnd(newEnd);\n  oppositeDirection.links.backwards.push(rootSegment);\n  rootSegment.links.backwards.push(oppositeDirection);\n  queue.push(rootSegment);\n  queue.push(oppositeDirection);\n\n  const segments = [];\n  // TODO: bounds should be the bounding box of the polygon\n  // TODO: maxObjects should vary based on the type of city area\n  const treeParams = { x: seed.x, y: seed.y, width: HIGHWAY_SEGMENT_LENGTH, height: HIGHWAY_SEGMENT_LENGTH };\n  const tree = new QuadTree(treeParams, QUADTREE_MAX_OBJECTS, QUADTREE_MAX_LEVELS);\n\n  while (queue.length && segments.length < SEGMENT_COUNT_LIMIT) {\n    // pop smallest road from the priority queue (i.e. smallest time)\n    let minT = queue[0].time;\n    let minT_i = 0;\n    queue.forEach((segment, i) => {\n      if (segment.time < minT) {\n        minT = segment.time;\n        minT_i = i;\n      }\n    });\n\n    const minSegment = queue.splice(minT_i, 1)[0];\n    const accepted = localConstraints(minSegment, segments, tree, debugData);\n    if (accepted) {\n      if (minSegment.setUpBranchLinks) {\n        minSegment.setUpBranchLinks();\n      }\n      minSegment.addSegment(segments, tree);\n      globalGoals(minSegment).forEach(segment => {\n        segment.time += minSegment.time + 1;\n        queue.push(segment);\n      });\n    }\n  }\n\n  let id = 0;\n  for (const segment of segments) {\n    segment.id = id++;\n  }\n\n  return segments;\n}\n","export function drawSegment(context, segment) {\n  context.strokeStyle = segment.params.highway ? '#FF0000' : '#000000';\n  context.lineWidth = segment.width;\n\n  context.beginPath();\n  context.moveTo(segment.road.start.x, segment.road.start.y);\n  context.lineTo(segment.road.end.x, segment.road.end.y);\n  context.closePath();\n  context.stroke();\n}\n","import Point from './classes/Point.js';\nimport * as interaction from './interaction.js';\nimport * as generator from './generation.js';\nimport * as draw from './draw.js';\n\n// set up canvas and interaction\nconst canvas = document.getElementById('canvas');\nconst context = canvas.getContext('2d');\ncanvas.width = window.innerWidth * 0.85; // canvas is 85vw\ncanvas.height = window.innerHeight;\ninteraction.init(canvas, context);\n\ndocument.getElementById('generate').addEventListener('click', event => {\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  // seed is the point at which the highway starts\n  const seed = new Point(canvas.width / 2, canvas.height / 2);\n  const segments = generator.generate(seed);\n  segments.forEach(segment => draw.drawSegment(context, segment));\n});\n"]}