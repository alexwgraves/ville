{"version":3,"sources":["src/classes/Point.js","src/classes/Circle.js","src/classes/Polygon.js","src/config.js","src/util.js","src/perlin.js","src/classes/Heatmap.js","src/classes/Collision.js","src/classes/Road.js","src/classes/SegmentFactory.js","src/classes/Segment.js","src/classes/QuadTree.js","src/classes/Building.js","src/classes/BuildingFactory.js","src/generation.js","src/draw.js","src/interaction.js","src/index.js"],"names":["EPSILON","Point","x","y","Math","sqrt","length2","other","v","minus","length","diff","s","radians","acos","dot","PI","scalarMultiply","start","end","toStart","line","projected","project","result","add","sign","distance2","pointOnLine","lineProj2","Circle","d","r","Polygon","edges","color","options","minX","canvas","width","maxX","minY","height","maxY","point","boundaries","debugMode","context","lineWidth","strokeStyle","strokeRect","currentSize","points","scale","offsetX","min","random","offsetY","push","round","fillStyle","fillRect","edgesMap","forEach","lastCrossing","intersections","i","includes","DEFAULT_SEGMENT_WIDTH","HIGHWAY_SEGMENT_WIDTH","DEFAULT_SEGMENT_LENGTH","HIGHWAY_SEGMENT_LENGTH","SEGMENT_COUNT_LIMIT","BRANCH_ANGLE","FORWARD_ANGLE","SKYSCRAPER_BRANCH_ANGLE","SKYSCRAPER_FORWARD_ANGLE","HIGHWAY_BRANCH_PROBABILITY","DEFAULT_BRANCH_PROBABILITY","HIGHWAY_BRANCH_POPULATION_THRESHOLD","NORMAL_BRANCH_POPULATION_THRESHOLD","ROAD_SNAP_DISTANCE","MINIMUM_INTERSECTION_DEVIATION","MIN_SPEED_PROPORTION","NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY","QUADTREE_MAX_OBJECTS","QUADTREE_MAX_LEVELS","BUILDING_PLACEMENT_LOOP_LIMIT","randomRange","max","minDegreeDifference","a","b","abs","randomAngle","limit","value","nonUniformNorm","pow","minAndIndex","array","min_i","entry","maxAndIndex","max_i","Grad","z","grad3","p","perm","Array","gradP","seed","floor","F2","G2","F3","G3","simplex2","xin","yin","n0","j","t","x0","y0","i1","j1","x1","y1","x2","y2","gi0","gi1","gi2","t0","t1","t2","dot2","Heatmap","one","noise","two","three","road","populationAt","Collision","object","type","properties","collisionRevision","RECT","LINE","CIRCLE","prop","axis","minCorner","corners","corner","maxCorner","limitsRevision","Type","cachedLimits","center","radius","limits","otherLimits","rectCircleCollision","rectRectIntersection","circle","rectPropsFromLine","distanceToLine","axes","center0","center2","projections","dots","direction","perpendicular","halfWidth","rect","cornersA","cornersB","overlaps","projectionsA","map","projectionsB","positionsA","vector","positionsB","util","maxA","maxA_i","minA","minA_i","maxB","maxB_i","minB","minB_i","maxAminB","maxBminA","minVector","Road","segment","collider","updateCollisionProperties","roadRevision","starts","numerator","cross","denominator","u","intersect","SegmentFactory","time","params","Segment","sin","cos","highway","links","backwards","forwards","users","maxSpeed","capacity","START","END","directionRevision","vertical","cachedDirection","angle","lengthRevision","cachedLength","distance","equals","currentSpeed","fromFraction","segmentEnd","endContaining","fraction","End","cost","concat","startIsBackwards","segments","tree","splitPart","fromExisting","addSegment","setEnd","setStart","slice","firstSplit","secondSplit","link","index","indexOf","insert","QuadTree","bounds","maxObjects","maxLevels","level","objects","nodes","midpointX","midpointY","top","bottom","getIndex","subdivide","splice","retrieve","node","clear","Building","diagonal","aspectRatio","aspectDegree","atan","generateCorners","supply","demand","RESIDENTIAL","OTHER","BuildingFactory","byType","template","count","buildings","randomRadius","building","setCenter","setDirection","permitBuilding","collisionCount","potentialCollisions","collide","localConstraints","action","priority","matches","match","intersection","intersects","actions","split","severed","duplicates","some","linksForEndContaining","globalGoals","previousSegment","newBranches","usingDirection","templateContinue","templateBranch","continueStraight","straightPop","popOnRoad","F_ANGLE","B_ANGLE","randomStraight","randomPop","roadPop","leftHighwayBranch","rightHighwayBranch","leftBranch","rightBranch","branch","setUpBranchLinks","generate","queue","rootSegment","oppositeDirection","newEnd","treeParams","minT","minT_i","minSegment","id","newBuildings","aroundSegment","fromProbability","drawSegment","beginPath","moveTo","lineTo","closePath","stroke","drawBuilding","fill","SUPPORTS_POINTER","window","SUPPORTS_TOUCH","drawing","xClicks","yClicks","dragClicks","currentBrush","document","querySelector","classList","lastBrush","parseInt","getElementById","brushes","prototype","call","getElementsByClassName","brushColors","skyscrapers","residential","commercial","water","parks","clickData","innerPoints","polygons","polygonIndex","render","addClick","dragging","clearActiveBrushes","brush","remove","onEventDown","event","detectEdges","mouseX","pageX","offsetLeft","mouseY","pageY","offsetTop","onEventMove","onEventUp","n","rgb","currX","getImageData","data","addEdge","prev","neighbors","prevIndex","findIndex","shift","firstNot","pixel","firstSame","next","interpretInput","polygon","boundingBox","scatterPoints","init","lineJoin","brushSize","currentBrushSize","addEventListener","innerWidth","innerHeight","innerText","target","checked","style","display","disabled","generator","getCenter","draw","getContext","interaction"],"mappings":"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","file":"src.8ab56b85.map","sourceRoot":"..","sourcesContent":["const EPSILON = 0.00000001;\n\nexport default class Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  length() {\n    return Math.sqrt(this.length2());\n  }\n\n  length2() {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  distance(other) {\n    const v = other.minus(this);\n    return v.length();\n  }\n\n  distance2(other) {\n    const v = other.minus(this);\n    return v.length2();\n  }\n\n  equals(other) {\n    const diff = this.minus(other);\n    return diff.length2() < EPSILON;\n  }\n\n  scalarMultiply(s) {\n    return new Point(this.x * s, this.y * s);\n  }\n\n  add(other) {\n    return new Point(this.x + other.x, this.y + other.y);\n  }\n\n  minus(other) {\n    return new Point(this.x - other.x, this.y - other.y);\n  }\n\n  dot(other) {\n    return this.x * other.x + this.y * other.y;\n  }\n\n  cross(other) {\n    return this.x * other.y - this.y * other.x;\n  }\n\n  angle(other) {\n    const radians = Math.acos(this.dot(other) / (this.length() * other.length()));\n    return radians * 180 / Math.PI;\n  }\n\n  project(other) {\n    return other.scalarMultiply(this.dot(other) / other.length2());\n  }\n\n  distanceToLine(start, end) {\n    const toStart = this.minus(start);\n    const line = end.minus(start);\n    const projected = toStart.project(line);\n    const result = start.add(projected);\n    const dot = toStart.dot(line);\n    const sign = dot < 0 ? -1 : dot > 0 ? 1 : 0;\n\n    return {\n      distance2: result.distance2(this),\n      pointOnLine: result,\n      // distance along line of projected point\n      lineProj2:  sign * projected.length2(),\n      length2: line.length2()\n    }\n  }\n}\n","export default class Circle {\n  constructor(x, y, d) {\n    this.x = x;\n    this.y = y;\n    this.r = d / 2;\n  }\n}\n","import Point from './Point.js';\n\nexport default class Polygon {\n  constructor(edges, color) {\n    this.edges = edges;\n    this.color = color;\n  }\n\n  getCenter(options) {\n    let minX = options.canvas.width, maxX = 0;\n    let minY = options.canvas.height, maxY = 0;\n    for (const point of this.edges) {\n      minX = point.x < minX ? point.x : minX;\n      maxX = point.x > maxX ? point.x : maxX;\n      minY = point.y < minY ? point.y : minY;\n      maxY = point.y > maxY ? point.y : maxY;\n    }\n\n    // find center from average of min and max\n    return new Point((minX + maxX) / 2, (minY + maxY) / 2);\n  }\n\n  /* Calculates the bounding box for a given Polygon. */\n  boundingBox(options) {\n    let minX = options.canvas.width, maxX = 0;\n    let minY = options.canvas.height, maxY = 0;\n    for (const point of this.edges) {\n      minX = point.x < minX ? point.x : minX;\n      maxX = point.x > maxX ? point.x : maxX;\n      minY = point.y < minY ? point.y : minY;\n      maxY = point.y > maxY ? point.y : maxY;\n    }\n    this.boundaries = [\n      new Point(minX, minY), // top left\n      new Point(maxX, minY), // top right\n      new Point(maxX, maxY), // bottom right\n      new Point(minX, maxY)  // bottom left\n    ];\n\n    // DEBUG MODE: draw bounding box\n    if (options.debugMode) {\n      options.context.lineWidth = 1;\n      options.context.strokeStyle = '#FF0000';\n      options.context.strokeRect(minX, minY, maxX - minX, maxY - minY);\n      options.context.lineWidth = options.currentSize;\n    }\n  }\n\n  /* Uses stratified sampling to scatter points within the Polygon for roads. */\n  scatterPoints(options) {\n    // we don't want to generate roads in parks or water\n    if (this.color === 'parks' || this.color === 'water') return;\n\n    const points = [];\n    // scatter points using stratified sampling within bounding box\n    const minX = this.boundaries[0].x, minY = this.boundaries[0].y;\n    const maxX = this.boundaries[1].x, maxY = this.boundaries[3].y;\n    for (let x = minX; x < maxX; x+=options.scale) {\n      for (let y = minY; y < maxY; y+=options.scale) {\n        // TODO: change scatter based on brush? (ex. less scatter on skyscrapers)\n        const offsetX = Math.min(x + Math.random() * options.scale, maxX);\n        const offsetY = Math.min(y + Math.random() * options.scale, maxY);\n        points.push(new Point(Math.round(offsetX), Math.round(offsetY)));\n      }\n    }\n\n    // DEBUG MODE: draw all of the stratified sampled points\n    if (options.debugMode) {\n      for (const point of points) {\n        options.context.fillStyle = '#000';\n        options.context.fillRect(point.x, point.y, 1, 1);\n      }\n    }\n\n    // map edge points y values to their x values\n    const edgesMap = {};\n    this.edges.forEach(point => {\n      if (edgesMap[point.y]) {\n        edgesMap[point.y].push(point.x);\n      } else {\n        edgesMap[point.y] = [point.x];\n      }\n    });\n\n    // starting at the point, go right and count the edges we hit\n    // TODO: handle when points cross tangent to the polygon\n    this.points = [];\n    points.forEach(point => {\n      // keep track of the last time we crossed the polygon's edge\n      let lastCrossing = 0;\n      let intersections = 0;\n      for (let i = point.x; i < maxX + 1; i++) {\n        if (edgesMap[point.y].includes(i)) {\n          // only count the intersection if the point isn't immediately next\n          if (i - lastCrossing > 1) intersections++;\n          lastCrossing = i;\n        }\n      }\n      // points are in the polygon if they hit an odd number of edges\n      if (intersections % 2 !== 0) this.points.push(point);\n    });\n\n    // DEBUG MODE: draw the points within the polygon in red\n    if (options.debugMode) {\n      for (const point of this.points) {\n        options.context.fillStyle = '#FF0000';\n        options.context.fillRect(point.x, point.y, 1, 1);\n      }\n    }\n  }\n}\n","export const DEFAULT_SEGMENT_WIDTH = 1;\nexport const HIGHWAY_SEGMENT_WIDTH = 2;\nexport const DEFAULT_SEGMENT_LENGTH = 25;\nexport const HIGHWAY_SEGMENT_LENGTH = 30;\nexport const SEGMENT_COUNT_LIMIT = 500;\n\nexport const BRANCH_ANGLE = 3; // in degrees\nexport const FORWARD_ANGLE = 10; // in degrees\nexport const SKYSCRAPER_BRANCH_ANGLE = 1; // in degrees\nexport const SKYSCRAPER_FORWARD_ANGLE = 1; // in degrees\n\nexport const HIGHWAY_BRANCH_PROBABILITY = 0.05;\nexport const DEFAULT_BRANCH_PROBABILITY = 0.4;\n\nexport const HIGHWAY_BRANCH_POPULATION_THRESHOLD = 0.1;\nexport const NORMAL_BRANCH_POPULATION_THRESHOLD = 0.1;\n\nexport const ROAD_SNAP_DISTANCE = 5;\nexport const MINIMUM_INTERSECTION_DEVIATION = 30; // in degrees\n\nexport const MIN_SPEED_PROPORTION = 0.1;\nexport const NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY = 5;\n\nexport const QUADTREE_MAX_OBJECTS = 10;\nexport const QUADTREE_MAX_LEVELS = 10;\n\nexport const BUILDING_PLACEMENT_LOOP_LIMIT = 3;\n","export function randomRange(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nexport function minDegreeDifference(a, b) {\n  const diff = Math.abs(a - b) % 180;\n  return Math.min(diff, Math.abs(diff - 180));\n}\n\nexport function randomAngle(limit) {\n  const nonUniformNorm = Math.pow(Math.abs(limit), 3);\n  let value = 0;\n  while (value === 0 || Math.random() < Math.pow(Math.abs(value), 3) / nonUniformNorm) {\n    value = randomRange(-limit, limit);\n  }\n  return value;\n}\n\nexport function minAndIndex(array) {\n  let min = array[0];\n  let min_i = 0;\n  array.forEach((entry, i) => {\n    if (entry < min) {\n      min = entry;\n      min_i = i;\n    }\n  });\n  return [min, min_i];\n}\n\nexport function maxAndIndex(array) {\n  let max = array[0];\n  let max_i = 0;\n  array.forEach((entry, i) => {\n    if (entry > max) {\n      max = entry;\n      max_i = i;\n    }\n  });\n  return [max, max_i];\n}\n","/*\n * Adapted from https://github.com/josephg/noisejs\n */\n\nclass Grad {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  dot2(x, y) {\n    return this.x * x + this.y * y;\n  }\n}\n\nconst grad3 = [\n  new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),\n  new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),\n  new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)\n];\n\nconst p = [151,160,137,91,90,15,\n131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\nconst perm = new Array(512);\nconst gradP = new Array(512);\n\nexport function seed(seed) {\n  if (seed > 0 && seed < 1) {\n    // Scale the seed out\n    seed *= 65536;\n  }\n\n  seed = Math.floor(seed);\n  if (seed < 256) {\n    seed |= seed << 8;\n  }\n\n  for (let i = 0; i < 256; i++) {\n    const v = i & 1 ? p[i] ^ (seed & 255) : p[i] ^ ((seed>>8) & 255);\n    perm[i] = perm[i + 256] = v;\n    gradP[i] = gradP[i + 256] = grad3[v % 12];\n  }\n}\n\nseed(0);\n\n// Skewing and unskewing factors for 2, 3, and 4 dimensions\nconst F2 = 0.5 * (Math.sqrt(3) - 1);\nconst G2 = (3 - Math.sqrt(3)) / 6;\n\nconst F3 = 1 / 3;\nconst G3 = 1 / 6;\n\n// 2D simplex noise\nexport function simplex2(xin, yin) {\n  let n0, n1, n2; // Noise contributions from the three corners\n  // Skew the input space to determine which simplex cell we're in\n  const s = (xin + yin) * F2; // Hairy factor for 2D\n  let i = Math.floor(xin + s);\n  let j = Math.floor(yin + s);\n  const t = (i + j) * G2;\n  const x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n  const y0 = yin - j + t;\n  // For the 2D case, the simplex shape is an equilateral triangle.\n  // Determine which simplex we are in.\n  // Offsets for second (middle) corner of simplex in (i,j) coords\n  const i1 = x0 > y0 ? 1 : 0;\n  const j1 = x0 > y0 ? 0 : 1;\n  // x0 > y0 is lower triangle, XY order: (0,0)->(1,0)->(1,1)\n  // otherwise is upper triangle, YX order: (0,0)->(0,1)->(1,1)\n  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n  // c = (3-sqrt(3))/6\n  const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n  const y1 = y0 - j1 + G2;\n  const x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n  const y2 = y0 - 1 + 2 * G2;\n  // Work out the hashed gradient indices of the three simplex corners\n  i &= 255;\n  j &= 255;\n  const gi0 = gradP[i + perm[j]];\n  const gi1 = gradP[i + i1 + perm[j + j1]];\n  const gi2 = gradP[i + 1 + perm[j + 1]];\n  // Calculate the contribution from the three corners\n  let t0 = 0.5 - x0 * x0 - y0 * y0;\n  if (t0 < 0) {\n    n0 = 0;\n  } else {\n    t0 *= t0;\n    n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\n  }\n  let t1 = 0.5 - x1 * x1 - y1 * y1;\n  if(t1 < 0) {\n    n1 = 0;\n  } else {\n    t1 *= t1;\n    n1 = t1 * t1 * gi1.dot2(x1, y1);\n  }\n  let t2 = 0.5 - x2 * x2 - y2 * y2;\n  if (t2 < 0) {\n    n2 = 0;\n  } else {\n    t2 *= t2;\n    n2 = t2 * t2 * gi2.dot2(x2, y2);\n  }\n  // Add contributions from each corner to get the final noise value.\n  // The result is scaled to return values in the interval [-1,1].\n  return 70 * (n0 + n1 + n2);\n}\n","import * as noise from './../perlin.js';\n\nexport default class Heatmap {\n  static populationAt(x, y) {\n    const one = (noise.simplex2(x / 500, y / 500) + 1) / 2;\n    const two = (noise.simplex2(x / 1000 + 50, y / 1000 + 50) + 1) / 2;\n    const three = (noise.simplex2(x / 1000 + 100, y / 1000 + 100) + 1) / 2;\n    return Math.pow((one * two + three) / 2, 2);\n  }\n\n  static popOnRoad(road) {\n    return (Heatmap.populationAt(road.start.x, road.start.y) + Heatmap.populationAt(road.end.x, road.end.y)) / 2;\n  }\n}\n","import * as util from './../util.js';\n\nimport Point from './Point.js';\n\nexport default class Collision {\n  static get Type() {\n    return { RECT: 'rect', LINE: 'line', CIRCLE: 'circle' };\n  }\n\n  constructor(object, type, properties) {\n    this.object = object;\n    this.type = type;\n    this.properties = properties;\n    this.collisionRevision = 0;\n  }\n\n  updateCollisionProperties(properties) {\n    this.collisionRevision++;\n    for (const prop in properties) {\n      this.properties[prop] = properties[prop];\n    }\n  }\n\n  minCorner(axis) {\n    let minCorner = this.properties.corners[0];\n    this.properties.corners.forEach(corner => {\n      if (corner[axis] < minCorner[axis]) minCorner = corner;\n    });\n    return minCorner;\n  }\n\n  maxCorner(axis) {\n    let maxCorner = this.properties.corners[0];\n    this.properties.corners.forEach(corner => {\n      if (corner[axis] > maxCorner[axis]) maxCorner = corner;\n    });\n    return maxCorner;\n  }\n\n  limits() {\n    if (this.collisionRevision !== this.limitsRevision) {\n      this.limitsRevision = this.collisionRevision;\n      if (this.type === Collision.Type.RECT) {\n        const minX = this.minCorner('x').x;\n        const minY = this.minCorner('y').y;\n        this.cachedLimits = {\n          x: minX,\n          y: minY,\n          width: this.maxCorner('x').x - minX,\n          height: this.maxCorner('y').y - minY,\n          object: this.object\n        }\n      } else if (this.type === Collision.Type.LINE) {\n        this.cachedLimits = {\n          x: Math.min(this.properties.start.x, this.properties.end.x),\n          y: Math.min(this.properties.start.y, this.properties.end.y),\n          width: Math.abs(this.properties.start.x - this.properties.end.x),\n          height: Math.abs(this.properties.start.y - this.properties.end.y),\n          object: this.object\n        }\n      } else if (this.type === Collision.Type.CIRCLE) {\n        this.cachedLimits = {\n          x: this.properties.center.x - this.properties.radius,\n          y: this.properties.center.y - this.properties.radius,\n          width: this.properties.radius * 2,\n          height: this.properties.radius * 2,\n          object: this.object\n        }\n      }\n    }\n    return this.cachedLimits;\n  }\n\n  collide(other) {\n    // avoid expensive collision check if possible\n    const limits = this.limits();\n    const otherLimits = other.limits();\n    if (limits && otherLimits &&\n        (limits.x + limits.width < otherLimits.x || otherLimits.x + otherLimits.width < limits.x) &&\n        (limits.y + limits.height < otherLimits.y || otherLimits.y + otherLimits.height < limits.y)) {\n      return false;\n    }\n\n    if (this.type === Collision.Type.CIRCLE) {\n      if (other.type === Collision.Type.RECT) {\n        return other.rectCircleCollision(this);\n      }\n    } else if (this.type === Collision.Type.RECT) {\n      if (other.type !== Collision.Type.CIRCLE) {\n        return this.rectRectIntersection(other);\n      } else {\n        return this.rectCircleCollision(other);\n      }\n    } else if (this.type === Collision.Type.LINE) {\n      if (other.type !== Collision.Type.CIRCLE) {\n        return this.rectRectIntersection(other);\n      }\n    }\n  }\n\n  rectCircleCollision(circle) {\n    // this must be a rectangle or line to call this function\n    if (this.type === Collision.Type.CIRCLE) return;\n    // other must be a circle to call this function\n    if (circle.type !== Collision.Type.CIRCLE) return;\n\n    // get the correct properties\n    const properties = this.type === Collision.Type.LINE ? this.rectPropsFromLine() : this.properties;\n    const corners = properties.corners;\n    const center = circle.properties.center;\n    const radius = circle.properties.radius;\n\n    // check for corner intersections with circle\n    for (const corner of corners) {\n      if (corner.distance2(center) <= radius * radius) return true;\n    }\n\n    // check for edge intersections with circle\n    for (let i = 0; i < corners.length; i++) {\n      const start = corners[i];\n      const end = corners[(i + 1) % corners.length];\n      const {distance2, pointOnLine, lineProj2, length2} = center.distanceToLine(start, end);\n      if (lineProj2 > 0 && lineProj2 < length2 && distance2 <= radius * radius) return true;\n    }\n\n    // check that the circle is not enclosed by the rectangle\n    const axes = [corners[3].minus(corners[0]), corners[3].minus(corners[2])];\n    const center0 = center.minus(corners[0]);\n    const center2 = center.minus(corners[2]);\n    const projections = [center0.project(axes[0]), center2.project(axes[1])];\n    const dots = [center0.dot(axes[0]), center2.dot(axes[1])];\n    if (dots[0] < 0 || projections[0].length2() > axes[0].length2() ||\n        dots[1] < 0 || projections[1].length2() > axes[1].length2()) {\n      return false;\n    }\n    return true;\n  }\n\n  rectPropsFromLine() {\n    // this must be a line to call this function\n    if (this.type !== Collision.Type.LINE) return;\n\n    const direction = this.properties.end.minus(this.properties.start);\n    const perpendicular = new Point(-direction.y, direction.x);\n    const halfWidth = perpendicular.scalarMultiply(0.5 * this.properties.width / perpendicular.length());\n    return {\n      corners: [\n        this.properties.start.add(halfWidth),\n        this.properties.start.minus(halfWidth),\n        this.properties.end.minus(halfWidth),\n        this.properties.end.add(halfWidth)\n      ]\n    }\n  }\n\n  rectRectIntersection(rect) {\n    // this must be a rectangle or line to call this function\n    if (this.type === Collision.Type.CIRCLE) return;\n    // other must be a rectangle or line to call this function\n    if (rect.type === Collision.Type.CIRCLE) return;\n\n    const cornersA = this.type === Collision.Type.LINE ? this.rectPropsFromLine().corners : this.properties.corners;\n    const cornersB = rect.type === Collision.Type.LINE ? rect.rectPropsFromLine().corners : rect.properties.corners;\n    const axes = [\n      cornersA[3].minus(cornersA[0]),\n      cornersA[3].minus(cornersA[2]),\n      cornersB[0].minus(cornersB[1]),\n      cornersB[0].minus(cornersB[3])\n    ];\n\n    // find axes with overlaps\n    const overlaps = [];\n    for (const axis of axes) {\n      const projectionsA = cornersA.map(corner => corner.project(axis));\n      const projectionsB = cornersB.map(corner => corner.project(axis));\n\n      const positionsA = projectionsA.map(vector => vector.dot(axis));\n      const positionsB = projectionsB.map(vector => vector.dot(axis));\n\n      const [maxA, maxA_i] = util.maxAndIndex(positionsA);\n      const [minA, minA_i] = util.minAndIndex(positionsA);\n      const [maxB, maxB_i] = util.maxAndIndex(positionsB);\n      const [minB, minB_i] = util.minAndIndex(positionsB);\n\n      // if the rectangles don't overlap on at least one axis, they don't collide\n      if (maxA < minB || maxB < minA) {\n        return false;\n      } else {\n        // calculate the overlap between the rectangles on this axis\n        const maxAminB = projectionsA[maxA_i].minus(projectionsB[minB_i]);\n        const maxBminA = projectionsB[maxB_i].minus(projectionsA[minA_i]);\n        if (maxAminB.length2() < maxBminA.length2()) overlaps.push(maxAminB);\n        // the rectangles overlap on the other side, so invert the vector\n        else overlaps.push(maxBminA.scalarMultiply(-1));\n      }\n    }\n\n    // find axis with the least overlap\n    let minVector = overlaps[0];\n    overlaps.forEach(vector => {\n      if (vector.length2() < minVector.length2()) minVector = vector;\n    });\n\n    // return displacement required to remove the rectangle from the collision\n    return minVector.scalarMultiply(-1);\n  }\n}\n","import Point from './Point.js';\n\nexport default class Road {\n  constructor(start, end, segment) {\n    this.start = start;\n    this.end = end;\n    this.segment = segment;\n  }\n\n  setStart(start) {\n    this.start = start;\n    this.segment.collider.updateCollisionProperties({ start: start });\n    this.segment.roadRevision++;\n  }\n\n  setEnd(end) {\n    this.end = end;\n    this.segment.collider.updateCollisionProperties({ end: end });\n    this.segment.roadRevision++;\n  }\n\n  intersects(other) {\n    const r = this.end.minus(this.start);\n    const s = other.end.minus(other.start);\n    const starts = other.start.minus(this.start);\n\n    const numerator = starts.cross(r);\n    const denominator = r.cross(s);\n\n    if (denominator === 0 || numerator === 0) return false;\n\n    const u = numerator / denominator;\n    const t = starts.cross(s) / denominator;\n    const epsilon = 0.001;\n    const intersect = t > epsilon && t < 1 - epsilon && u > epsilon && u < 1 - epsilon;\n    return intersect ? new Point(this.start.x + t * r.x, this.start.y + t * r.y) : intersect;\n  }\n}\n","import Segment from './Segment.js';\nimport Point from './Point.js';\n\nexport default class SegmentFactory {\n  static fromExisting(segment, time, road, params) {\n    time = time || segment.time;\n    road = road || segment.road;\n    params = params || segment.params;\n    return new Segment(road.start, road.end, time, params);\n  }\n\n  static usingDirection(start, direction = 90, length = DEFAULT_SEGMENT_LENGTH, time = 0, params = {}) {\n    // convert direction to radians\n    direction *= Math.PI / 180;\n    const x = start.x + length * Math.sin(direction);\n    const y = start.y + length * Math.cos(direction);\n    return new Segment(start, new Point(x, y), time, params);\n  }\n}\n","import { DEFAULT_SEGMENT_WIDTH,\n         HIGHWAY_SEGMENT_WIDTH,\n         MIN_SPEED_PROPORTION } from './../config.js';\n\nimport Collision from './Collision.js';\nimport Road from './Road.js';\nimport Point from './Point.js';\nimport SegmentFactory from './SegmentFactory.js';\n\nexport default class Segment {\n  static get End() {\n    return { START: 'start', END: 'end' };\n  }\n\n  constructor(start, end, time = 0, params = {}) {\n    this.start = start;\n    this.end = end;\n    this.time = time;\n    this.params = params;\n\n    this.width = params.highway ? HIGHWAY_SEGMENT_WIDTH : DEFAULT_SEGMENT_WIDTH;\n    this.collider = new Collision(this, Collision.Type.LINE, {start: start, end: end, width: this.width});\n\n    this.roadRevision = 0;\n    this.road = new Road(start, end, this);\n\n    // time-step delay before this road is evaluated\n    this.time = time;\n    // meta-information relevant to global goals\n    this.params = params;\n\n    this.links = { backwards: [], forwards: [] };\n\n    this.users = [];\n    this.maxSpeed = params.highway ? 1200 : 800;\n    this.capacity = params.highway ? 12 : 6;\n  }\n\n  currentSpeed() {\n    return Math.min(MIN_SPEED_PROPORTION, 1 - Math.max(0, this.users.length - 1) / this.capacity) * this.maxSpeed;\n  }\n\n  direction() {\n    if (this.directionRevision !== this.roadRevision) {\n      this.directionRevision = this.roadRevision;\n      const vertical = new Point(0, 1);\n      const vector = this.road.end.minus(this.road.start);\n      const cross = vertical.cross(vector);\n      // we want the opposite of the cross sign\n      const sign = cross > 0 ? -1 : cross < 0 ? 1 : 0;\n      this.cachedDirection = sign * vertical.angle(vector);\n    }\n    return this.cachedDirection;\n  }\n\n  length() {\n    if (this.lengthRevision !== this.roadRevision) {\n      this.lengthRevision = this.roadRevision;\n      this.cachedLength = this.road.start.distance(this.road.end);\n    }\n    return this.cachedLength;\n  }\n\n  startIsBackwards() {\n    if (this.links.backwards.length) {\n      return this.links.backwards[0].road.start.equals(this.road.start) ||\n             this.links.backwards[0].road.end.equals(this.road.start);\n    } else {\n      return this.links.forwards[0].road.start.equals(this.road.end) ||\n             this.links.forwards[0].road.end.equals(this.road.end);\n    }\n  }\n\n  cost() {\n    return this.length() / this.currentSpeed();\n  }\n\n  costTo(other, fromFraction) {\n    const segmentEnd = this.endContaining(other);\n    const fraction = fromFraction ? (segmentEnd === Segment.End.START ? fromFraction : 1 - fromFraction) : 0.5;\n    return this.cost() * fraction;\n  }\n\n  neighbors() {\n    return this.links.forwards.concat(this.links.backwards);\n  }\n\n  endContaining(segment) {\n    const backwards = this.startIsBackwards();\n    if (this.links.backwards.includes(segment)) {\n      return backwards ? Segment.End.START : Segment.End.END;\n    } else if (this.links.forwards.includes(segment)) {\n      return backwards ? Segment.End.END : Segment.End.START;\n    }\n  }\n\n  linksForEndContaining(segment) {\n    if (this.links.backwards.includes(segment)) return this.links.backwards;\n    else if (this.links.forwards.includes(segment)) return this.links.forwards;\n  }\n\n  split(point, segment, segments, tree) {\n    const backwards = this.startIsBackwards();\n\n    const splitPart = SegmentFactory.fromExisting(this);\n    splitPart.addSegment(segments, tree);\n    splitPart.road.setEnd(point);\n    this.road.setStart(point);\n\n    splitPart.links.backwards = this.links.backwards.slice(0);\n    splitPart.links.forwards = this.links.forwards.slice(0);\n\n    // determine which links correspond to which end of the split segment\n    const firstSplit = backwards ? splitPart : this;\n    const secondSplit = backwards ? this : splitPart;\n    const fixLinks = backwards ? splitPart.links.backwards : splitPart.links.forwards;\n\n    fixLinks.forEach(link => {\n      let index = link.links.backwards.indexOf(this);\n      if (index !== -1) {\n        link.links.backwards[index] = splitPart;\n      } else {\n        index = link.links.forwards.indexOf(this);\n        link.links.forwards[index] = splitPart;\n      }\n    });\n\n    firstSplit.links.forwards = [segment, secondSplit];\n    secondSplit.links.backwards = [segment, firstSplit];\n\n    segment.links.forwards.push(firstSplit);\n    segment.links.forwards.push(secondSplit);\n  }\n\n  addSegment(segments, tree) {\n    segments.push(this);\n    tree.insert(this.collider.limits());\n  }\n}\n","export default class QuadTree {\n  constructor(bounds, maxObjects = 10, maxLevels = 4, level = 0) {\n    this.bounds = bounds;\n    this.maxObjects = maxObjects;\n    this.maxLevels = maxLevels;\n    this.level = level;\n\n    this.objects = [];\n    this.nodes = [];\n  }\n\n  subdivide() {\n    const width = Math.round(this.bounds.width / 2);\n    const height = Math.round(this.bounds.height / 2);\n    const x = Math.round(this.bounds.x);\n    const y = Math.round(this.bounds.y);\n\n    // top right node\n    this.nodes[0] = new QuadTree({\n      x: x + width,\n      y: y,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n\n    // top left node\n    this.nodes[1] = new QuadTree({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n\n    // bottom left node\n    this.nodes[2] = new QuadTree({\n      x: x,\n      y: y + height,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n\n    // bottom right node\n    this.nodes[3] = new QuadTree({\n      x: x + width,\n      y: y + height,\n      width: width,\n      height: height\n    }, this.maxObjects, this.maxLevels, this.level + 1);\n  }\n\n  // determines which node the given rectangle is in\n  getIndex(rect) {\n    let index = -1;\n    const midpointX = this.bounds.x + this.bounds.width / 2;\n    const midpointY = this.bounds.y + this.bounds.height / 2;\n\n    const top = rect.y < midpointY && rect.y + rect.height < midpointY;\n    const bottom = rect.y > midpointY;\n\n    if (rect.x < midpointX && rect.x + rect.width < midpointX) {\n      index = top ? 1 : bottom ? 2 : index;\n    } else if (rect.x > midpointX) {\n      index = top ? 0 : bottom ? 3 : index;\n    }\n    return index;\n  }\n\n  insert(rect) {\n    if (this.nodes.length) {\n      const i = this.getIndex(rect);\n      if (i !== -1) return this.nodes[i].insert(rect);\n    }\n\n    this.objects.push(rect);\n\n    if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {\n      if (this.nodes.length === 0) this.subdivide();\n\n      let i = 0;\n      while (i < this.objects.length) {\n        const index = this.getIndex(this.objects[i]);\n        if (index !== -1) this.nodes[index].insert(this.objects.splice(i, 1)[0]);\n        else i++;\n      }\n    }\n  }\n\n  // returns all objects that collide with the given object\n  retrieve(rect) {\n    const index = this.getIndex(rect);\n    let objects = this.objects;\n\n    if (this.nodes.length) {\n      if (index !== -1) {\n        objects = objects.concat(this.nodes[index].retrieve(rect));\n      } else {\n        // check against all subnodes\n        for (const node of this.nodes) {\n          objects = objects.concat(node.retrieve(rect));\n        }\n      }\n    }\n    return objects;\n  }\n\n  clear() {\n    this.objects = [];\n    for (const node of this.nodes) {\n      node.clear();\n    }\n  }\n}\n","import Collision from './Collision.js';\nimport Point from './Point.js';\n\nexport default class Building {\n  static get Type() {\n    return { RESIDENTIAL: 'residential', OTHER: 'other' };\n  }\n\n  constructor(center, direction, diagonal, type, aspectRatio = 1) {\n    this.center = center;\n    this.direction = direction;\n    this.diagonal = diagonal;\n    this.type = type;\n\n    // degrees to deviate either end to produce desired aspect ratio\n    this.aspectDegree = Math.atan(aspectRatio) * 180 / Math.PI;\n    this.corners = this.generateCorners();\n\n    this.collider = new Collision(this, Collision.Type.RECT, { corners: this.corners });\n    this.supply = [];\n    this.demand = [];\n  }\n\n  generateCorners() {\n    return [\n      new Point(\n        this.center.x + this.diagonal * Math.sin((+this.aspectDegree + this.direction) * Math.PI / 180),\n        this.center.y + this.diagonal * Math.cos((+this.aspectDegree + this.direction) * Math.PI / 180)),\n      new Point(\n        this.center.x + this.diagonal * Math.sin((-this.aspectDegree + this.direction) * Math.PI / 180),\n        this.center.y + this.diagonal * Math.cos((-this.aspectDegree + this.direction) * Math.PI / 180)),\n      new Point(\n        this.center.x + this.diagonal * Math.sin((180 + this.aspectDegree + this.direction) * Math.PI / 180),\n        this.center.y + this.diagonal * Math.cos((180 + this.aspectDegree + this.direction) * Math.PI / 180)),\n      new Point(\n        this.center.x + this.diagonal * Math.sin((180 - this.aspectDegree + this.direction) * Math.PI / 180),\n        this.center.y + this.diagonal * Math.cos((180 - this.aspectDegree + this.direction) * Math.PI / 180))\n    ]\n  }\n\n  setCenter(center) {\n    this.center = center;\n    this.corners = this.generateCorners();\n    this.collider.updateCollisionProperties({ corners: this.corners });\n  }\n\n  setDirection(direction) {\n    this.direction = direction;\n    this.corners = this.generateCorners();\n    this.collider.updateCollisionProperties({ corners: this.corners });\n  }\n}\n","import { BUILDING_PLACEMENT_LOOP_LIMIT } from './../config.js';\nimport { randomRange } from './../util.js';\n\nimport Building from './Building.js';\nimport Point from './Point.js';\n\nexport default class BuildingFactory {\n  static fromProbability() {\n    // TODO: make this dependent on what city area we're in instead\n    if (Math.random() < 0.4) return BuildingFactory.byType(Building.Type.OTHER);\n    return BuildingFactory.byType(Building.Type.RESIDENTIAL);\n  }\n\n  static byType(type) {\n    if (type === Building.Type.RESIDENTIAL) {\n      return new Building(new Point(0, 0), 0, 5, Building.Type.RESIDENTIAL);\n    } else {\n      return new Building(new Point(0, 0), 0, 8, Building.Type.OTHER, randomRange(0.5, 2));\n    }\n  }\n\n  static aroundSegment(template, segment, count, radius, tree) {\n    const buildings = [];\n    for (let i = 0; i < count; i++) {\n      const randomAngle = Math.random() * 2 * Math.PI;\n      const randomRadius = Math.random() * radius;\n      const center = new Point(\n        0.5 * (segment.road.start.x + segment.road.end.x) + randomRadius * Math.sin(randomAngle),\n        0.5 * (segment.road.start.y + segment.road.end.y) + randomRadius * Math.cos(randomAngle)\n      );\n      const building = template();\n      building.setCenter(center);\n      building.setDirection(segment.direction());\n\n      let permitBuilding = false;\n      for (let i = 0; i < BUILDING_PLACEMENT_LOOP_LIMIT; i++) {\n        let collisionCount = 0;\n        // query tree since building limits may have changed from previous collision\n        const potentialCollisions = tree.retrieve(building.collider.limits()).concat(buildings);\n        for (let object of potentialCollisions) {\n          // unpack if necessary\n          if (object.object) object = object.object;\n\n          const result = building.collider.collide(object.collider);\n          if (result) {\n            collisionCount++;\n            if (i === BUILDING_PLACEMENT_LOOP_LIMIT - 1) break;\n\n            // shift building to avoid colliding with existing object\n            building.setCenter(building.center.add(result));\n          }\n        }\n\n        if (collisionCount === 0) {\n          permitBuilding = true;\n          break;\n        }\n      }\n\n      if (permitBuilding) buildings.push(building);\n    }\n\n    return buildings;\n  }\n}\n","import { ROAD_SNAP_DISTANCE,\n         MINIMUM_INTERSECTION_DEVIATION,\n         DEFAULT_SEGMENT_LENGTH,\n         HIGHWAY_SEGMENT_LENGTH,\n         NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY,\n         BRANCH_ANGLE, FORWARD_ANGLE,\n         SKYSCRAPER_BRANCH_ANGLE, SKYSCRAPER_FORWARD_ANGLE,\n         HIGHWAY_BRANCH_POPULATION_THRESHOLD,\n         NORMAL_BRANCH_POPULATION_THRESHOLD,\n         HIGHWAY_BRANCH_PROBABILITY,\n         DEFAULT_BRANCH_PROBABILITY,\n         QUADTREE_PARAMS, QUADTREE_MAX_OBJECTS, QUADTREE_MAX_LEVELS,\n         SEGMENT_COUNT_LIMIT } from './config.js';\nimport * as util from './util.js';\nimport * as noise from './perlin.js';\n\nimport Point from './classes/Point.js';\nimport Heatmap from './classes/Heatmap.js';\nimport Segment from './classes/Segment.js';\nimport QuadTree from './classes/QuadTree.js';\nimport SegmentFactory from './classes/SegmentFactory.js';\nimport BuildingFactory from './classes/BuildingFactory.js';\n\nfunction localConstraints(segment, segments, tree) {\n  const action = { priority: 0, params: {} };\n\n  const matches = tree.retrieve(segment.collider.limits());\n  for (const match of matches) {\n    const other = match.object;\n\n    // intersection check\n    if (action.priority < 5) {\n      const intersection = segment.road.intersects(other.road);\n      if (intersection) {\n        if (!action.params.time || intersection.time < actions.params.time) {\n          action.params.time = intersection.time;\n          action.priority = 4;\n          // if intersecting lines are too similar don't continue\n          if (util.minDegreeDifference(other.direction(), segment.direction()) < MINIMUM_INTERSECTION_DEVIATION) {\n            return false;\n          }\n\n          other.split(intersection, segment, segments, tree);\n          segment.road.end = intersection;\n          segment.params.severed = true;\n\n          return true;\n        }\n      }\n    }\n\n    // snap to crossing within radius check\n    if (action.priority < 4) {\n      // current segment's start must have been checked to have been created\n      // other segment's start must have a corresponding end\n      if (segment.road.end.distance(other.road.end) <= ROAD_SNAP_DISTANCE) {\n        const point = other.road.end;\n        action.priority = 3;\n        segment.road.end = point;\n        segment.params.severed = true;\n\n        // update other's links corresponding to other.road.end\n        const links = other.startIsBackwards() ? other.links.forwards : other.links.backwards;\n\n        // check for duplicate lines, don't add if it exists\n        const duplicates = links.some(link => {\n          return (link.road.start.equals(segment.road.end) && link.road.end.equals(segment.road.start)) ||\n            (link.road.start.equals(segment.road.start) && link.road.end.equals(segment.road.end));\n        });\n        if (duplicates) return false;\n\n        links.forEach(link => {\n          // pick links of remaining segments at junction corresponding to other.road.end\n          link.linksForEndContaining(other).push(segment);\n\n          // add junction segments to snapped segment\n          segment.links.forwards.push(link);\n        });\n\n        links.push(segment);\n        segment.links.forwards.push(other);\n\n        return true;\n      }\n    }\n\n    // intersection with radius check\n    if (action.priority < 3) {\n      const { distance2, pointOnLine, lineProj2, length2 } =\n        segment.road.end.distanceToLine(other.road.start, other.road.end);\n      if (distance2 < ROAD_SNAP_DISTANCE * ROAD_SNAP_DISTANCE && lineProj2 >= 0 && lineProj2 <= length2) {\n        const point = pointOnLine;\n        action.priority = 2;\n        segment.road.end = point;\n        segment.params.severed = true;\n\n        // if intersecting lines are too similar don't continue\n        if (util.minDegreeDifference(other.direction(), segment.direction()) < MINIMUM_INTERSECTION_DEVIATION) {\n          return false;\n        }\n\n        other.split(point, segment, segments, tree);\n\n        return true;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction globalGoals(previousSegment, color) {\n  const newBranches = [];\n  if (!previousSegment.params.severed) {\n    const template = (direction, length, time, params) => SegmentFactory.usingDirection(previousSegment.road.end, direction, length, time, params);\n\n    // used for highways or going straight on a normal branch\n    const templateContinue = (direction) => template(direction, previousSegment.length(), 0, previousSegment.params);\n    // not using params, i.e. not highways\n    const templateBranch = (direction) => template(direction, DEFAULT_SEGMENT_LENGTH, previousSegment.params.highway ? NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY : 0);\n\n    const continueStraight = templateContinue(previousSegment.direction());\n    const straightPop = Heatmap.popOnRoad(continueStraight.road);\n\n    const F_ANGLE = color === 'skyscrapers' ? SKYSCRAPER_FORWARD_ANGLE : FORWARD_ANGLE;\n    const B_ANGLE = color === 'skyscrapers' ? SKYSCRAPER_BRANCH_ANGLE : BRANCH_ANGLE;\n\n    if (previousSegment.params.highway) {\n      const randomStraight = templateContinue(previousSegment.direction() + util.randomAngle(F_ANGLE));\n      const randomPop = Heatmap.popOnRoad(randomStraight.road);\n      const roadPop = randomPop > straightPop ? randomPop : straightPop;\n      newBranches.push(randomPop > straightPop ? randomStraight : continueStraight);\n\n      if (roadPop > HIGHWAY_BRANCH_POPULATION_THRESHOLD) {\n        if (Math.random() < HIGHWAY_BRANCH_PROBABILITY) {\n          const leftHighwayBranch = templateContinue(previousSegment.direction() - 90 + util.randomAngle(B_ANGLE));\n          newBranches.push(leftHighwayBranch);\n        } else if (Math.random() < HIGHWAY_BRANCH_PROBABILITY) {\n          const rightHighwayBranch = templateContinue(previousSegment.direction() + 90 + util.randomAngle(B_ANGLE));\n          newBranches.push(rightHighwayBranch);\n        }\n      }\n    } else if (straightPop > NORMAL_BRANCH_POPULATION_THRESHOLD) {\n      newBranches.push(continueStraight);\n    }\n\n    if (straightPop > NORMAL_BRANCH_POPULATION_THRESHOLD) {\n      if (Math.random() < DEFAULT_BRANCH_PROBABILITY) {\n        const leftBranch = templateBranch(previousSegment.direction() - 90 + util.randomAngle(B_ANGLE));\n        newBranches.push(leftBranch);\n      } else if (Math.random() < DEFAULT_BRANCH_PROBABILITY) {\n        const rightBranch = templateBranch(previousSegment.direction() + 90 + util.randomAngle(B_ANGLE));\n        newBranches.push(rightBranch);\n      }\n    }\n  }\n\n  for (const branch of newBranches) {\n    branch.setUpBranchLinks = () => {\n      // set up links between each current branch and each existing branch stemming from the previous segment\n      previousSegment.links.forwards.forEach(link => {\n        branch.links.backwards.push(link);\n        link.linksForEndContaining(previousSegment).push(branch);\n      });\n\n      previousSegment.links.forwards.push(branch);\n      branch.links.backwards.push(previousSegment);\n    }\n  }\n\n  return newBranches;\n}\n\nexport function generate(seed, color) {\n  noise.seed(Math.random());\n\n  const queue = [];\n  const rootSegment = new Segment(seed, new Point(seed.x + HIGHWAY_SEGMENT_LENGTH, seed.y), 0, { highway: true });\n  const oppositeDirection = SegmentFactory.fromExisting(rootSegment);\n  const newEnd = new Point(rootSegment.road.start.x - HIGHWAY_SEGMENT_LENGTH, oppositeDirection.road.end.y);\n  oppositeDirection.road.setEnd(newEnd);\n  oppositeDirection.links.backwards.push(rootSegment);\n  rootSegment.links.backwards.push(oppositeDirection);\n  queue.push(rootSegment);\n  queue.push(oppositeDirection);\n\n  const segments = [];\n  // TODO: bounds should be the bounding box of the polygon\n  const treeParams = { x: seed.x, y: seed.y, width: HIGHWAY_SEGMENT_LENGTH, height: HIGHWAY_SEGMENT_LENGTH };\n  // TODO: maxObjects should vary based on the type of city area\n  const tree = new QuadTree(treeParams, QUADTREE_MAX_OBJECTS, QUADTREE_MAX_LEVELS);\n\n  while (queue.length && segments.length < SEGMENT_COUNT_LIMIT) {\n    // pop smallest road from the priority queue (i.e. smallest time)\n    let minT = queue[0].time;\n    let minT_i = 0;\n    queue.forEach((segment, i) => {\n      if (segment.time < minT) {\n        minT = segment.time;\n        minT_i = i;\n      }\n    });\n\n    const minSegment = queue.splice(minT_i, 1)[0];\n    const accepted = localConstraints(minSegment, segments, tree);\n    if (accepted) {\n      if (minSegment.setUpBranchLinks) {\n        minSegment.setUpBranchLinks();\n      }\n      minSegment.addSegment(segments, tree);\n      globalGoals(minSegment, color).forEach(segment => {\n        segment.time += minSegment.time + 1;\n        queue.push(segment);\n      });\n    }\n  }\n\n  let id = 0;\n  for (const segment of segments) {\n    segment.id = id++;\n  }\n\n  // building generation\n  let buildings = [];\n  segments.forEach(segment => {\n    const newBuildings = BuildingFactory.aroundSegment(BuildingFactory.fromProbability, segment, 5, 40, tree);\n    newBuildings.forEach(building => tree.insert(building.collider.limits()));\n    buildings = buildings.concat(newBuildings);\n  });\n\n  return { segments, buildings };\n}\n","export function drawSegment(context, segment) {\n  context.strokeStyle = segment.params.highway ? '#FF0000' : '#000000';\n  context.lineWidth = segment.width;\n\n  context.beginPath();\n  context.moveTo(segment.road.start.x, segment.road.start.y);\n  context.lineTo(segment.road.end.x, segment.road.end.y);\n  context.closePath();\n  context.stroke();\n}\n\nexport function drawBuilding(context, building) {\n  context.fillStyle = 'rgba(0,0,0,0.2)';\n  // context.fillStyle = '#000000';\n\n  context.beginPath();\n  context.moveTo(building.corners[0].x, building.corners[0].y);\n  context.lineTo(building.corners[1].x, building.corners[1].y);\n  context.lineTo(building.corners[2].x, building.corners[2].y);\n  context.lineTo(building.corners[3].x, building.corners[3].y);\n  context.closePath();\n  context.fill();\n}\n","import Point from './classes/Point.js';\nimport Circle from './classes/Circle.js';\nimport Polygon from './classes/Polygon.js';\nimport * as generator from './generation.js';\nimport * as draw from './draw.js';\n\nconst SUPPORTS_POINTER = 'PointerEvent' in window;\nconst SUPPORTS_TOUCH = 'ontouchstart' in window;\nconst options = {\n  drawing: false,\n  // create arrays to keep track of painting\n  xClicks: [],\n  yClicks: [],\n  dragClicks: [],\n  // brush parameters\n  currentBrush: document.querySelector('.active').classList[1],\n  lastBrush: document.querySelector('.active').classList[1],\n  currentSize: parseInt(document.getElementById('brush-size').value),\n  brushes: Array.prototype.slice.call(document.getElementsByClassName('brush')),\n  brushColors: {\n    skyscrapers: 'rgb(203,203,203)',\n    residential: 'rgb(252,139,148)',\n    commercial: 'rgb(191,140,190)',\n    water: 'rgb(180,207,226)',\n    parks: 'rgb(140,191,142)'\n  },\n  // data for storing canvas colors\n  clickData: { skyscrapers: [], residential: [], commercial: [], water: [], parks: [] },\n  innerPoints: { skyscrapers: [], residential: [], commercial: [], water: [], parks: [] },\n  polygons: [],\n  polygonIndex: 0,\n  // other parameters\n  debugMode: false,\n  scale: 20 // TODO: make this chooseable?\n}\n\n/* FUNCTIONS */\n\nfunction render() {\n  for (let i = 0; i < options.xClicks.length; i++) {\n    options.context.strokeStyle = options.brushColors[options.currentBrush];\n    options.context.lineWidth = options.currentSize;\n\n    options.context.beginPath();\n    if (options.dragClicks[i] && i > 0) {\n      options.context.moveTo(options.xClicks[i - 1], options.yClicks[i - 1]);\n    } else {\n      options.context.moveTo(options.xClicks[i] - 1, options.yClicks[i] - 1);\n    }\n\n    options.context.lineTo(options.xClicks[i], options.yClicks[i]);\n    options.context.closePath();\n    options.context.stroke();\n  }\n}\n\nfunction addClick(x, y, dragging) {\n  options.xClicks.push(x);\n  options.yClicks.push(y);\n  options.dragClicks.push(dragging);\n\n  // add to data for generation\n  options.clickData[options.currentBrush].push(new Circle(x, y, options.currentSize));\n}\n\nfunction clearActiveBrushes() {\n  options.brushes.forEach(brush => {\n    brush.classList.remove('active');\n  });\n}\n\nfunction onEventDown(event) {\n  const i = options.clickData[options.lastBrush].length - 1;\n  if (i > -1) options.polygons.push(detectEdges(options.clickData[options.lastBrush][i], options.lastBrush));\n\n  const mouseX = event.pageX - canvas.offsetLeft;\n  const mouseY = event.pageY - canvas.offsetTop;\n  options.drawing = true;\n  addClick(mouseX, mouseY);\n  render();\n}\n\nfunction onEventMove(event) {\n  if (options.drawing) {\n    addClick(event.pageX - canvas.offsetLeft, event.pageY - canvas.offsetTop, true);\n    render();\n  }\n}\n\nfunction onEventUp(event) {\n  options.drawing = false;\n  // clear clicks on up so we don't redraw anything\n  options.xClicks = [];\n  options.yClicks = [];\n  options.dragClicks = [];\n}\n\nfunction detectEdges(circle, color) {\n  const edges = [];\n  const rgb = options.brushColors[color].slice(4, -1).split(',');\n\n  // start at the rightmost pixel of the circle\n  let x = circle.x + circle.r - 1;\n  let y = circle.y;\n\n  // find the rightmost pixel of this color\n  // TODO: do this better\n  let currX = circle.x + circle.r - 1;\n  let n = options.context.getImageData(currX++, y, 1, 1).data;\n  while (n[0] == rgb[0] && n[1] == rgb[1] && n[2] == rgb[2]) {\n    x = currX;\n    n = options.context.getImageData(currX++, y, 1, 1).data;\n  }\n\n  const start = new Point(x - 1, y);\n\n  // recursive function to determine a polygon's edges\n  const addEdge = (point, prev) => {\n    const neighbors = [\n      new Point(point.x + 1, point.y    ),\n      new Point(point.x + 1, point.y + 1),\n      new Point(point.x,     point.y + 1),\n      new Point(point.x - 1, point.y + 1),\n      new Point(point.x - 1, point.y    ),\n      new Point(point.x - 1, point.y - 1),\n      new Point(point.x,     point.y - 1),\n      new Point(point.x + 1, point.y - 1)\n    ];\n\n    // order neighbors so that it starts right after prev\n    const prevIndex = neighbors.findIndex(p => p.x === prev.x && p.y === prev.y);\n    if (prevIndex < 7) {\n      for (let i = 0; i < prevIndex + 1; i++) {\n        neighbors.splice(7, 0, neighbors.shift());\n      }\n    }\n\n    // check if any of the eight surrounding pixels are a different color\n    const firstNot = neighbors.findIndex(p => {\n      const pixel = options.context.getImageData(p.x, p.y, 1, 1).data;\n      return Math.abs(pixel[0] - rgb[0]) > 5 ||\n             Math.abs(pixel[1] - rgb[1]) > 5 ||\n             Math.abs(pixel[2] - rgb[2]) > 5;\n    });\n\n    // find the first neighbor that is the same color and not the previous point\n    const firstSame = neighbors.findIndex(p => {\n      const pixel = options.context.getImageData(p.x, p.y, 1, 1).data;\n      return (p.x !== prev.x || p.y !== prev.y) &&\n        Math.abs(pixel[0] - rgb[0]) < 6 &&\n        Math.abs(pixel[1] - rgb[1]) < 6 &&\n        Math.abs(pixel[2] - rgb[2]) < 6;\n    });\n\n    if (firstNot !== -1) {\n      edges.push(new Point(point.x, point.y));\n      const next = neighbors[firstSame];\n      // continue until we reach the original starting point\n      if (next.x === start.x && next.y === start.y) return;\n      return addEdge(next, point);\n    }\n  }\n\n  addEdge(start, start);\n  return new Polygon(edges, color);\n}\n\nfunction interpretInput() {\n  // detect edges for the last click\n  const i = options.clickData[options.currentBrush].length - 1;\n  if (i > -1) options.polygons.push(detectEdges(options.clickData[options.currentBrush][i], options.currentBrush));\n\n  for (const polygon of options.polygons) {\n    polygon.boundingBox(options);\n    polygon.scatterPoints(options);\n  }\n}\n\nexport function init(canvas, context) {\n  /* SETUP */\n  context.lineJoin = 'round';\n  options.canvas = canvas;\n  options.context = context;\n\n  // brush logic\n  const brushSize = document.getElementById('brush-size');\n  const currentBrushSize = document.getElementById('current-brush-size');\n\n  /* EVENT LISTENERS */\n\n  // update the canvas size on window resize\n  window.addEventListener('resize', () => {\n    canvas.width = window.innerWidth * 0.85;\n    canvas.height = window.innerHeight;\n    render();\n  });\n\n  if (SUPPORTS_POINTER) {\n    canvas.addEventListener('pointerdown', event => { onEventDown(event) });\n    canvas.addEventListener('pointermove', event => { onEventMove(event) });\n    canvas.addEventListener('pointerup', event => { onEventUp(event) });\n    canvas.addEventListener('pointercancel', event => { onEventUp(event) });\n  } else if (SUPPORTS_TOUCH) {\n    canvas.addEventListener('touchstart', event => { onEventDown(event) });\n    canvas.addEventListener('touchmove', event => { onEventMove(event) });\n    canvas.addEventListener('touchend', event => { onEventUp(event) });\n    canvas.addEventListener('touchcancel', event => { onEventUp(event) });\n  } else {\n    canvas.addEventListener('mousedown', event => { onEventDown(event) });\n    canvas.addEventListener('mousemove', event => { onEventMove(event) });\n    canvas.addEventListener('mouseup', event => { onEventUp(event) });\n    canvas.addEventListener('mouseleave', event => { onEventUp(event) });\n  }\n\n  options.brushes.forEach(brush => {\n    brush.addEventListener('click', () => {\n      clearActiveBrushes();\n      options.lastBrush = options.currentBrush;\n      options.currentBrush = brush.classList[1];\n      brush.classList.add('active');\n    });\n  });\n\n  brushSize.addEventListener('input', event => {\n    options.currentSize = parseInt(brushSize.value);\n    currentBrushSize.innerText = brushSize.value;\n  });\n\n  document.getElementById('debug').addEventListener('change', event => {\n    options.debugMode = event.target.checked;\n    document.getElementById('debug-controls').style.display = options.debugMode ? 'block' : 'none';\n  });\n\n  document.getElementById('edges').addEventListener('click', event => {\n    // DEBUG MODE: draw edge outlines\n    for (const polygon of options.polygons) {\n      for (const point of polygon.edges) {\n        context.fillStyle = '#000';\n        context.fillRect(point.x, point.y, 1, 1);\n      }\n    }\n  });\n\n  document.getElementById('analyze').addEventListener('click', event => {\n    // DEBUG MODE: draw bounding boxes and scatter points\n    interpretInput();\n    event.target.disabled = true;\n    event.target.classList.add('disabled');\n  });\n\n  document.getElementById('generate').addEventListener('click', event => {\n    // detect edges for the last click\n    const i = options.clickData[options.currentBrush].length - 1;\n    if (i > -1) options.polygons.push(detectEdges(options.clickData[options.currentBrush][i], options.currentBrush));\n\n    // create road networks seeded from each polygon\n    options.polygons.forEach(polygon => {\n      if (polygon.color !== 'parks' && polygon.color !== 'water') {\n        // only generate roads for skyscrapers, commercial, and residential\n        const { segments, buildings } = generator.generate(polygon.getCenter(options), polygon.color);\n\n        // draw generation roads and building on map\n        segments.forEach(segment => draw.drawSegment(options.context, segment));\n        buildings.forEach(building => draw.drawBuilding(options.context, building));\n      }\n    });\n  });\n}\n","import Point from './classes/Point.js';\nimport * as interaction from './interaction.js';\nimport * as generator from './generation.js';\nimport * as draw from './draw.js';\n\n// set up canvas and interaction\nconst canvas = document.getElementById('canvas');\nconst context = canvas.getContext('2d');\ncanvas.width = window.innerWidth * 0.85; // canvas is 85vw\ncanvas.height = window.innerHeight;\ninteraction.init(canvas, context);\n"]}